//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.2
//
// <auto-generated>
//
// Generated from file `RpcSession.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <RpcSession.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::std::string iceC_Rpc_ContentBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ContentBrowser",
    "::Rpc::ManagedObject"
};
const ::std::string iceC_Rpc_ContentBrowser_ops[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};
const ::std::string iceC_Rpc_ContentBrowser_next_name = "next";

const ::std::string iceC_Rpc_EngineVersionBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::EngineVersionBrowser",
    "::Rpc::ManagedObject"
};
const ::std::string iceC_Rpc_EngineVersionBrowser_ops[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};
const ::std::string iceC_Rpc_EngineVersionBrowser_next_name = "next";

const ::std::string iceC_Rpc_ExtraBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ExtraBrowser",
    "::Rpc::ManagedObject"
};
const ::std::string iceC_Rpc_ExtraBrowser_ops[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};
const ::std::string iceC_Rpc_ExtraBrowser_next_name = "next";

const ::std::string iceC_Rpc_UserBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ManagedObject",
    "::Rpc::UserBrowser"
};
const ::std::string iceC_Rpc_UserBrowser_ops[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};
const ::std::string iceC_Rpc_UserBrowser_next_name = "next";

const ::std::string iceC_Rpc_ContentSubmitter_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ContentSubmitter",
    "::Rpc::ManagedObject"
};
const ::std::string iceC_Rpc_ContentSubmitter_ops[] =
{
    "cancel",
    "destroy",
    "finish",
    "getId",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setCategory",
    "setDescription",
    "setEngine",
    "setPage",
    "setParentId",
    "setStartup",
    "setTitle",
    "setVideo",
    "uploadContent",
    "uploadImage"
};
const ::std::string iceC_Rpc_ContentSubmitter_getId_name = "getId";
const ::std::string iceC_Rpc_ContentSubmitter_setTitle_name = "setTitle";
const ::std::string iceC_Rpc_ContentSubmitter_setPage_name = "setPage";
const ::std::string iceC_Rpc_ContentSubmitter_setCategory_name = "setCategory";
const ::std::string iceC_Rpc_ContentSubmitter_setEngine_name = "setEngine";
const ::std::string iceC_Rpc_ContentSubmitter_setStartup_name = "setStartup";
const ::std::string iceC_Rpc_ContentSubmitter_setParentId_name = "setParentId";
const ::std::string iceC_Rpc_ContentSubmitter_setVideo_name = "setVideo";
const ::std::string iceC_Rpc_ContentSubmitter_setDescription_name = "setDescription";
const ::std::string iceC_Rpc_ContentSubmitter_uploadImage_name = "uploadImage";
const ::std::string iceC_Rpc_ContentSubmitter_uploadContent_name = "uploadContent";
const ::std::string iceC_Rpc_ContentSubmitter_cancel_name = "cancel";
const ::std::string iceC_Rpc_ContentSubmitter_finish_name = "finish";

const ::std::string iceC_Rpc_EngineVersionSubmitter_ids[3] =
{
    "::Ice::Object",
    "::Rpc::EngineVersionSubmitter",
    "::Rpc::ManagedObject"
};
const ::std::string iceC_Rpc_EngineVersionSubmitter_ops[] =
{
    "cancel",
    "destroy",
    "finish",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setInfo",
    "setSetup",
    "setUnSetup",
    "uploadEngine"
};
const ::std::string iceC_Rpc_EngineVersionSubmitter_setSetup_name = "setSetup";
const ::std::string iceC_Rpc_EngineVersionSubmitter_setUnSetup_name = "setUnSetup";
const ::std::string iceC_Rpc_EngineVersionSubmitter_setInfo_name = "setInfo";
const ::std::string iceC_Rpc_EngineVersionSubmitter_uploadEngine_name = "uploadEngine";
const ::std::string iceC_Rpc_EngineVersionSubmitter_cancel_name = "cancel";
const ::std::string iceC_Rpc_EngineVersionSubmitter_finish_name = "finish";

const ::std::string iceC_Rpc_ExtraSubmitter_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ExtraSubmitter",
    "::Rpc::ManagedObject"
};
const ::std::string iceC_Rpc_ExtraSubmitter_ops[] =
{
    "cancel",
    "destroy",
    "finish",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setCategory",
    "setInfo",
    "setParentId",
    "setSetup",
    "setTitle",
    "uploadExtra",
    "uploadImage"
};
const ::std::string iceC_Rpc_ExtraSubmitter_setParentId_name = "setParentId";
const ::std::string iceC_Rpc_ExtraSubmitter_setTitle_name = "setTitle";
const ::std::string iceC_Rpc_ExtraSubmitter_setSetup_name = "setSetup";
const ::std::string iceC_Rpc_ExtraSubmitter_setCategory_name = "setCategory";
const ::std::string iceC_Rpc_ExtraSubmitter_setInfo_name = "setInfo";
const ::std::string iceC_Rpc_ExtraSubmitter_uploadImage_name = "uploadImage";
const ::std::string iceC_Rpc_ExtraSubmitter_uploadExtra_name = "uploadExtra";
const ::std::string iceC_Rpc_ExtraSubmitter_cancel_name = "cancel";
const ::std::string iceC_Rpc_ExtraSubmitter_finish_name = "finish";

const ::std::string iceC_Rpc_ClientBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ClientBrowser",
    "::Rpc::ManagedObject"
};
const ::std::string iceC_Rpc_ClientBrowser_ops[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};
const ::std::string iceC_Rpc_ClientBrowser_next_name = "next";

const ::std::string iceC_Rpc_ClientSubmitter_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ClientSubmitter",
    "::Rpc::ManagedObject"
};
const ::std::string iceC_Rpc_ClientSubmitter_ops[] =
{
    "cancel",
    "destroy",
    "finish",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setInfo",
    "uploadClient"
};
const ::std::string iceC_Rpc_ClientSubmitter_setInfo_name = "setInfo";
const ::std::string iceC_Rpc_ClientSubmitter_uploadClient_name = "uploadClient";
const ::std::string iceC_Rpc_ClientSubmitter_cancel_name = "cancel";
const ::std::string iceC_Rpc_ClientSubmitter_finish_name = "finish";

const ::std::string iceC_Rpc_CommentBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::CommentBrowser",
    "::Rpc::ManagedObject"
};
const ::std::string iceC_Rpc_CommentBrowser_ops[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};
const ::std::string iceC_Rpc_CommentBrowser_next_name = "next";

const ::std::string iceC_Rpc_Session_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ManagedObject",
    "::Rpc::Session"
};
const ::std::string iceC_Rpc_Session_ops[] =
{
    "addComment",
    "browseClient",
    "browseComment",
    "browseContent",
    "browseContentByParentId",
    "browseEngineVersions",
    "browseExtra",
    "browseExtraByParentId",
    "browseUsers",
    "changeContentDisplayPriority",
    "changeContentState",
    "changeEngineVersionDisplayPriority",
    "changeExtraDisplayPriority",
    "changeExtraState",
    "copyContent",
    "destroy",
    "downloadContent",
    "downloadContentImage",
    "downloadEngineVersion",
    "downloadExtra",
    "downloadExtraImage",
    "editComment",
    "editContent",
    "getClientInfo",
    "getComment",
    "getContentCategories",
    "getContentInfo",
    "getCurrentUser",
    "getCurrentUserGroup",
    "getEngineVersion",
    "getExtraCategories",
    "getExtraInfo",
    "getPages",
    "getUniformInfo",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "isUserOnline",
    "onlineUserCount",
    "queryDownloadCount",
    "refresh",
    "removeClient",
    "removeComment",
    "removeEngineVersion",
    "removeUser",
    "setContentCategories",
    "setExtraCategories",
    "setPages",
    "setUniformInfo",
    "setUserGroup",
    "submitClient",
    "submitContent",
    "submitEngineVersion",
    "submitExtra",
    "updateClient",
    "updateEngineVersion",
    "updateExtra"
};
const ::std::string iceC_Rpc_Session_refresh_name = "refresh";
const ::std::string iceC_Rpc_Session_getCurrentUser_name = "getCurrentUser";
const ::std::string iceC_Rpc_Session_getCurrentUserGroup_name = "getCurrentUserGroup";
const ::std::string iceC_Rpc_Session_setPages_name = "setPages";
const ::std::string iceC_Rpc_Session_getPages_name = "getPages";
const ::std::string iceC_Rpc_Session_setContentCategories_name = "setContentCategories";
const ::std::string iceC_Rpc_Session_getContentCategories_name = "getContentCategories";
const ::std::string iceC_Rpc_Session_setExtraCategories_name = "setExtraCategories";
const ::std::string iceC_Rpc_Session_getExtraCategories_name = "getExtraCategories";
const ::std::string iceC_Rpc_Session_setUniformInfo_name = "setUniformInfo";
const ::std::string iceC_Rpc_Session_getUniformInfo_name = "getUniformInfo";
const ::std::string iceC_Rpc_Session_browseContent_name = "browseContent";
const ::std::string iceC_Rpc_Session_browseContentByParentId_name = "browseContentByParentId";
const ::std::string iceC_Rpc_Session_getContentInfo_name = "getContentInfo";
const ::std::string iceC_Rpc_Session_downloadContentImage_name = "downloadContentImage";
const ::std::string iceC_Rpc_Session_downloadContent_name = "downloadContent";
const ::std::string iceC_Rpc_Session_submitContent_name = "submitContent";
const ::std::string iceC_Rpc_Session_copyContent_name = "copyContent";
const ::std::string iceC_Rpc_Session_editContent_name = "editContent";
const ::std::string iceC_Rpc_Session_changeContentState_name = "changeContentState";
const ::std::string iceC_Rpc_Session_changeContentDisplayPriority_name = "changeContentDisplayPriority";
const ::std::string iceC_Rpc_Session_browseEngineVersions_name = "browseEngineVersions";
const ::std::string iceC_Rpc_Session_downloadEngineVersion_name = "downloadEngineVersion";
const ::std::string iceC_Rpc_Session_removeEngineVersion_name = "removeEngineVersion";
const ::std::string iceC_Rpc_Session_submitEngineVersion_name = "submitEngineVersion";
const ::std::string iceC_Rpc_Session_updateEngineVersion_name = "updateEngineVersion";
const ::std::string iceC_Rpc_Session_getEngineVersion_name = "getEngineVersion";
const ::std::string iceC_Rpc_Session_changeEngineVersionDisplayPriority_name = "changeEngineVersionDisplayPriority";
const ::std::string iceC_Rpc_Session_browseExtra_name = "browseExtra";
const ::std::string iceC_Rpc_Session_browseExtraByParentId_name = "browseExtraByParentId";
const ::std::string iceC_Rpc_Session_getExtraInfo_name = "getExtraInfo";
const ::std::string iceC_Rpc_Session_downloadExtraImage_name = "downloadExtraImage";
const ::std::string iceC_Rpc_Session_downloadExtra_name = "downloadExtra";
const ::std::string iceC_Rpc_Session_submitExtra_name = "submitExtra";
const ::std::string iceC_Rpc_Session_updateExtra_name = "updateExtra";
const ::std::string iceC_Rpc_Session_changeExtraState_name = "changeExtraState";
const ::std::string iceC_Rpc_Session_changeExtraDisplayPriority_name = "changeExtraDisplayPriority";
const ::std::string iceC_Rpc_Session_browseClient_name = "browseClient";
const ::std::string iceC_Rpc_Session_getClientInfo_name = "getClientInfo";
const ::std::string iceC_Rpc_Session_submitClient_name = "submitClient";
const ::std::string iceC_Rpc_Session_updateClient_name = "updateClient";
const ::std::string iceC_Rpc_Session_removeClient_name = "removeClient";
const ::std::string iceC_Rpc_Session_browseUsers_name = "browseUsers";
const ::std::string iceC_Rpc_Session_setUserGroup_name = "setUserGroup";
const ::std::string iceC_Rpc_Session_removeUser_name = "removeUser";
const ::std::string iceC_Rpc_Session_browseComment_name = "browseComment";
const ::std::string iceC_Rpc_Session_getComment_name = "getComment";
const ::std::string iceC_Rpc_Session_addComment_name = "addComment";
const ::std::string iceC_Rpc_Session_editComment_name = "editComment";
const ::std::string iceC_Rpc_Session_removeComment_name = "removeComment";
const ::std::string iceC_Rpc_Session_queryDownloadCount_name = "queryDownloadCount";
const ::std::string iceC_Rpc_Session_isUserOnline_name = "isUserOnline";
const ::std::string iceC_Rpc_Session_onlineUserCount_name = "onlineUserCount";

}

bool
Rpc::ContentBrowser::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ContentBrowser_ids, iceC_Rpc_ContentBrowser_ids + 3, s);
}

::std::vector<::std::string>
Rpc::ContentBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Rpc_ContentBrowser_ids[0], &iceC_Rpc_ContentBrowser_ids[3]);
}

::std::string
Rpc::ContentBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ContentBrowser::ice_staticId()
{
    static const ::std::string typeId = "::Rpc::ContentBrowser";
    return typeId;
}

/// \cond INTERNAL
bool
Rpc::ContentBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_n;
    istr->readAll(iceP_n);
    inS.endReadParams();
    ContentItemSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_items, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ContentBrowser_ops, iceC_Rpc_ContentBrowser_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ContentBrowser_ops)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Rpc::EngineVersionBrowser::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_EngineVersionBrowser_ids, iceC_Rpc_EngineVersionBrowser_ids + 3, s);
}

::std::vector<::std::string>
Rpc::EngineVersionBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Rpc_EngineVersionBrowser_ids[0], &iceC_Rpc_EngineVersionBrowser_ids[3]);
}

::std::string
Rpc::EngineVersionBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::EngineVersionBrowser::ice_staticId()
{
    static const ::std::string typeId = "::Rpc::EngineVersionBrowser";
    return typeId;
}

/// \cond INTERNAL
bool
Rpc::EngineVersionBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_n;
    istr->readAll(iceP_n);
    inS.endReadParams();
    EngineVersionSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_items, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_EngineVersionBrowser_ops, iceC_Rpc_EngineVersionBrowser_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_EngineVersionBrowser_ops)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Rpc::ExtraBrowser::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ExtraBrowser_ids, iceC_Rpc_ExtraBrowser_ids + 3, s);
}

::std::vector<::std::string>
Rpc::ExtraBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Rpc_ExtraBrowser_ids[0], &iceC_Rpc_ExtraBrowser_ids[3]);
}

::std::string
Rpc::ExtraBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ExtraBrowser::ice_staticId()
{
    static const ::std::string typeId = "::Rpc::ExtraBrowser";
    return typeId;
}

/// \cond INTERNAL
bool
Rpc::ExtraBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_n;
    istr->readAll(iceP_n);
    inS.endReadParams();
    ExtraInfoSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_items, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ExtraBrowser_ops, iceC_Rpc_ExtraBrowser_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ExtraBrowser_ops)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Rpc::UserBrowser::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_UserBrowser_ids, iceC_Rpc_UserBrowser_ids + 3, s);
}

::std::vector<::std::string>
Rpc::UserBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Rpc_UserBrowser_ids[0], &iceC_Rpc_UserBrowser_ids[3]);
}

::std::string
Rpc::UserBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::UserBrowser::ice_staticId()
{
    static const ::std::string typeId = "::Rpc::UserBrowser";
    return typeId;
}

/// \cond INTERNAL
bool
Rpc::UserBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_n;
    istr->readAll(iceP_n);
    inS.endReadParams();
    UserSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_items, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::UserBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_UserBrowser_ops, iceC_Rpc_UserBrowser_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_UserBrowser_ops)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Rpc::ContentSubmitter::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ContentSubmitter_ids, iceC_Rpc_ContentSubmitter_ids + 3, s);
}

::std::vector<::std::string>
Rpc::ContentSubmitter::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Rpc_ContentSubmitter_ids[0], &iceC_Rpc_ContentSubmitter_ids[3]);
}

::std::string
Rpc::ContentSubmitter::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ContentSubmitter::ice_staticId()
{
    static const ::std::string typeId = "::Rpc::ContentSubmitter";
    return typeId;
}

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_getId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string iceP_id;
    ErrorCode ret = this->getId(iceP_id, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_id, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setTitle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_title;
    istr->readAll(iceP_title);
    inS.endReadParams();
    ErrorCode ret = this->setTitle(::std::move(iceP_title), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setPage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_page;
    istr->readAll(iceP_page);
    inS.endReadParams();
    ErrorCode ret = this->setPage(::std::move(iceP_page), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setCategory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_category;
    istr->readAll(iceP_category);
    inS.endReadParams();
    ErrorCode ret = this->setCategory(::std::move(iceP_category), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setEngine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->readAll(iceP_name, iceP_version);
    inS.endReadParams();
    ErrorCode ret = this->setEngine(::std::move(iceP_name), ::std::move(iceP_version), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setStartup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_startup;
    istr->readAll(iceP_startup);
    inS.endReadParams();
    ErrorCode ret = this->setStartup(::std::move(iceP_startup), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setParentId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ErrorCode ret = this->setParentId(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setVideo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_video;
    istr->readAll(iceP_video);
    inS.endReadParams();
    ErrorCode ret = this->setVideo(::std::move(iceP_video), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setDescription(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_description;
    istr->readAll(iceP_description);
    inS.endReadParams();
    ErrorCode ret = this->setDescription(::std::move(iceP_description), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_uploadImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_index;
    istr->readAll(iceP_index);
    inS.endReadParams();
    ::std::shared_ptr<UploaderPrx> iceP_uploader;
    ErrorCode ret = this->uploadImage(iceP_index, iceP_uploader, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_uploader, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_uploadContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<UploaderPrx> iceP_uploader;
    ErrorCode ret = this->uploadContent(iceP_uploader, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_uploader, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_cancel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->cancel(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_finish(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ErrorCode ret = this->finish(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ContentSubmitter_ops, iceC_Rpc_ContentSubmitter_ops + 18, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ContentSubmitter_ops)
    {
        case 0:
        {
            return _iceD_cancel(in, current);
        }
        case 1:
        {
            return _iceD_destroy(in, current);
        }
        case 2:
        {
            return _iceD_finish(in, current);
        }
        case 3:
        {
            return _iceD_getId(in, current);
        }
        case 4:
        {
            return _iceD_ice_id(in, current);
        }
        case 5:
        {
            return _iceD_ice_ids(in, current);
        }
        case 6:
        {
            return _iceD_ice_isA(in, current);
        }
        case 7:
        {
            return _iceD_ice_ping(in, current);
        }
        case 8:
        {
            return _iceD_setCategory(in, current);
        }
        case 9:
        {
            return _iceD_setDescription(in, current);
        }
        case 10:
        {
            return _iceD_setEngine(in, current);
        }
        case 11:
        {
            return _iceD_setPage(in, current);
        }
        case 12:
        {
            return _iceD_setParentId(in, current);
        }
        case 13:
        {
            return _iceD_setStartup(in, current);
        }
        case 14:
        {
            return _iceD_setTitle(in, current);
        }
        case 15:
        {
            return _iceD_setVideo(in, current);
        }
        case 16:
        {
            return _iceD_uploadContent(in, current);
        }
        case 17:
        {
            return _iceD_uploadImage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Rpc::EngineVersionSubmitter::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_EngineVersionSubmitter_ids, iceC_Rpc_EngineVersionSubmitter_ids + 3, s);
}

::std::vector<::std::string>
Rpc::EngineVersionSubmitter::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Rpc_EngineVersionSubmitter_ids[0], &iceC_Rpc_EngineVersionSubmitter_ids[3]);
}

::std::string
Rpc::EngineVersionSubmitter::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::EngineVersionSubmitter::ice_staticId()
{
    static const ::std::string typeId = "::Rpc::EngineVersionSubmitter";
    return typeId;
}

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_setSetup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_setup;
    istr->readAll(iceP_setup);
    inS.endReadParams();
    ErrorCode ret = this->setSetup(::std::move(iceP_setup), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_setUnSetup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_unsetup;
    istr->readAll(iceP_unsetup);
    inS.endReadParams();
    ErrorCode ret = this->setUnSetup(::std::move(iceP_unsetup), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_setInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    ErrorCode ret = this->setInfo(::std::move(iceP_info), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_uploadEngine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<UploaderPrx> iceP_uploader;
    ErrorCode ret = this->uploadEngine(iceP_uploader, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_uploader, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_cancel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->cancel(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_finish(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ErrorCode ret = this->finish(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_EngineVersionSubmitter_ops, iceC_Rpc_EngineVersionSubmitter_ops + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_EngineVersionSubmitter_ops)
    {
        case 0:
        {
            return _iceD_cancel(in, current);
        }
        case 1:
        {
            return _iceD_destroy(in, current);
        }
        case 2:
        {
            return _iceD_finish(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_setInfo(in, current);
        }
        case 8:
        {
            return _iceD_setSetup(in, current);
        }
        case 9:
        {
            return _iceD_setUnSetup(in, current);
        }
        case 10:
        {
            return _iceD_uploadEngine(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Rpc::ExtraSubmitter::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ExtraSubmitter_ids, iceC_Rpc_ExtraSubmitter_ids + 3, s);
}

::std::vector<::std::string>
Rpc::ExtraSubmitter::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Rpc_ExtraSubmitter_ids[0], &iceC_Rpc_ExtraSubmitter_ids[3]);
}

::std::string
Rpc::ExtraSubmitter::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ExtraSubmitter::ice_staticId()
{
    static const ::std::string typeId = "::Rpc::ExtraSubmitter";
    return typeId;
}

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_setParentId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ErrorCode ret = this->setParentId(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_setTitle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_title;
    istr->readAll(iceP_title);
    inS.endReadParams();
    ErrorCode ret = this->setTitle(::std::move(iceP_title), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_setSetup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_setup;
    istr->readAll(iceP_setup);
    inS.endReadParams();
    ErrorCode ret = this->setSetup(::std::move(iceP_setup), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_setCategory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_category;
    istr->readAll(iceP_category);
    inS.endReadParams();
    ErrorCode ret = this->setCategory(::std::move(iceP_category), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_setInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    ErrorCode ret = this->setInfo(::std::move(iceP_info), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_uploadImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<UploaderPrx> iceP_uploader;
    ErrorCode ret = this->uploadImage(iceP_uploader, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_uploader, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_uploadExtra(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<UploaderPrx> iceP_uploader;
    ErrorCode ret = this->uploadExtra(iceP_uploader, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_uploader, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_cancel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->cancel(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_finish(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ErrorCode ret = this->finish(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ExtraSubmitter_ops, iceC_Rpc_ExtraSubmitter_ops + 14, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ExtraSubmitter_ops)
    {
        case 0:
        {
            return _iceD_cancel(in, current);
        }
        case 1:
        {
            return _iceD_destroy(in, current);
        }
        case 2:
        {
            return _iceD_finish(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_setCategory(in, current);
        }
        case 8:
        {
            return _iceD_setInfo(in, current);
        }
        case 9:
        {
            return _iceD_setParentId(in, current);
        }
        case 10:
        {
            return _iceD_setSetup(in, current);
        }
        case 11:
        {
            return _iceD_setTitle(in, current);
        }
        case 12:
        {
            return _iceD_uploadExtra(in, current);
        }
        case 13:
        {
            return _iceD_uploadImage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Rpc::ClientBrowser::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ClientBrowser_ids, iceC_Rpc_ClientBrowser_ids + 3, s);
}

::std::vector<::std::string>
Rpc::ClientBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Rpc_ClientBrowser_ids[0], &iceC_Rpc_ClientBrowser_ids[3]);
}

::std::string
Rpc::ClientBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ClientBrowser::ice_staticId()
{
    static const ::std::string typeId = "::Rpc::ClientBrowser";
    return typeId;
}

/// \cond INTERNAL
bool
Rpc::ClientBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_n;
    istr->readAll(iceP_n);
    inS.endReadParams();
    ClientInfoSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_items, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ClientBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ClientBrowser_ops, iceC_Rpc_ClientBrowser_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ClientBrowser_ops)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Rpc::ClientSubmitter::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ClientSubmitter_ids, iceC_Rpc_ClientSubmitter_ids + 3, s);
}

::std::vector<::std::string>
Rpc::ClientSubmitter::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Rpc_ClientSubmitter_ids[0], &iceC_Rpc_ClientSubmitter_ids[3]);
}

::std::string
Rpc::ClientSubmitter::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ClientSubmitter::ice_staticId()
{
    static const ::std::string typeId = "::Rpc::ClientSubmitter";
    return typeId;
}

/// \cond INTERNAL
bool
Rpc::ClientSubmitter::_iceD_setInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    ErrorCode ret = this->setInfo(::std::move(iceP_info), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ClientSubmitter::_iceD_uploadClient(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<UploaderPrx> iceP_uploader;
    ErrorCode ret = this->uploadClient(iceP_uploader, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_uploader, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ClientSubmitter::_iceD_cancel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->cancel(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ClientSubmitter::_iceD_finish(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ErrorCode ret = this->finish(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ClientSubmitter::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ClientSubmitter_ops, iceC_Rpc_ClientSubmitter_ops + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ClientSubmitter_ops)
    {
        case 0:
        {
            return _iceD_cancel(in, current);
        }
        case 1:
        {
            return _iceD_destroy(in, current);
        }
        case 2:
        {
            return _iceD_finish(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_setInfo(in, current);
        }
        case 8:
        {
            return _iceD_uploadClient(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Rpc::CommentBrowser::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_CommentBrowser_ids, iceC_Rpc_CommentBrowser_ids + 3, s);
}

::std::vector<::std::string>
Rpc::CommentBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Rpc_CommentBrowser_ids[0], &iceC_Rpc_CommentBrowser_ids[3]);
}

::std::string
Rpc::CommentBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::CommentBrowser::ice_staticId()
{
    static const ::std::string typeId = "::Rpc::CommentBrowser";
    return typeId;
}

/// \cond INTERNAL
bool
Rpc::CommentBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_n;
    istr->readAll(iceP_n);
    inS.endReadParams();
    CommentSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_items, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::CommentBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_CommentBrowser_ops, iceC_Rpc_CommentBrowser_ops + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_CommentBrowser_ops)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
Rpc::Session::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_Session_ids, iceC_Rpc_Session_ids + 3, s);
}

::std::vector<::std::string>
Rpc::Session::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_Rpc_Session_ids[0], &iceC_Rpc_Session_ids[3]);
}

::std::string
Rpc::Session::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::Session::ice_staticId()
{
    static const ::std::string typeId = "::Rpc::Session";
    return typeId;
}

/// \cond INTERNAL
bool
Rpc::Session::_iceD_refresh(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    this->refresh(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getCurrentUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string iceP_user;
    ErrorCode ret = this->getCurrentUser(iceP_user, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_user, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getCurrentUserGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string iceP_group;
    ErrorCode ret = this->getCurrentUserGroup(iceP_group, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_group, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_setPages(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSeq iceP_pages;
    istr->readAll(iceP_pages);
    inS.endReadParams();
    ErrorCode ret = this->setPages(::std::move(iceP_pages), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getPages(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    StringSeq iceP_pages;
    ErrorCode ret = this->getPages(iceP_pages, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_pages, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_setContentCategories(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSeq iceP_categories;
    istr->readAll(iceP_categories);
    inS.endReadParams();
    ErrorCode ret = this->setContentCategories(::std::move(iceP_categories), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getContentCategories(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    StringSeq iceP_categories;
    ErrorCode ret = this->getContentCategories(iceP_categories, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_categories, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_setExtraCategories(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    StringSeq iceP_categories;
    istr->readAll(iceP_categories);
    inS.endReadParams();
    ErrorCode ret = this->setExtraCategories(::std::move(iceP_categories), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getExtraCategories(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    StringSeq iceP_categories;
    ErrorCode ret = this->getExtraCategories(iceP_categories, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_categories, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_setUniformInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_key;
    ::std::string iceP_value;
    istr->readAll(iceP_key, iceP_value);
    inS.endReadParams();
    ErrorCode ret = this->setUniformInfo(::std::move(iceP_key), ::std::move(iceP_value), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getUniformInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_key;
    istr->readAll(iceP_key);
    inS.endReadParams();
    ::std::string iceP_value;
    ErrorCode ret = this->getUniformInfo(::std::move(iceP_key), iceP_value, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_value, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_page;
    ::std::string iceP_category;
    ::std::string iceP_search;
    istr->readAll(iceP_page, iceP_category, iceP_search);
    inS.endReadParams();
    ::std::shared_ptr<ContentBrowserPrx> iceP_browser;
    ErrorCode ret = this->browseContent(::std::move(iceP_page), ::std::move(iceP_category), ::std::move(iceP_search), iceP_browser, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_browser, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseContentByParentId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_parentId;
    istr->readAll(iceP_parentId);
    inS.endReadParams();
    ::std::shared_ptr<ContentBrowserPrx> iceP_browser;
    ErrorCode ret = this->browseContentByParentId(::std::move(iceP_parentId), iceP_browser, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_browser, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getContentInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ContentInfo iceP_info;
    ErrorCode ret = this->getContentInfo(::std::move(iceP_id), iceP_info, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_info, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_downloadContentImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    int iceP_index;
    istr->readAll(iceP_id, iceP_index);
    inS.endReadParams();
    ::std::shared_ptr<DownloaderPrx> iceP_downloader;
    ErrorCode ret = this->downloadContentImage(::std::move(iceP_id), iceP_index, iceP_downloader, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_downloader, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_downloadContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ::std::shared_ptr<DownloaderPrx> iceP_downloader;
    ErrorCode ret = this->downloadContent(::std::move(iceP_id), iceP_downloader, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_downloader, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_submitContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<ContentSubmitterPrx> iceP_submitter;
    ErrorCode ret = this->submitContent(iceP_submitter, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_submitter, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_copyContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ::std::shared_ptr<ContentSubmitterPrx> iceP_submitter;
    ErrorCode ret = this->copyContent(::std::move(iceP_id), iceP_submitter, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_submitter, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_editContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ::std::shared_ptr<ContentSubmitterPrx> iceP_submitter;
    ErrorCode ret = this->editContent(::std::move(iceP_id), iceP_submitter, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_submitter, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_changeContentState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::string iceP_state;
    istr->readAll(iceP_id, iceP_state);
    inS.endReadParams();
    ErrorCode ret = this->changeContentState(::std::move(iceP_id), ::std::move(iceP_state), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_changeContentDisplayPriority(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    int iceP_displayPriority;
    istr->readAll(iceP_id, iceP_displayPriority);
    inS.endReadParams();
    ErrorCode ret = this->changeContentDisplayPriority(::std::move(iceP_id), iceP_displayPriority, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseEngineVersions(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    bool iceP_all;
    istr->readAll(iceP_all);
    inS.endReadParams();
    ::std::shared_ptr<EngineVersionBrowserPrx> iceP_browser;
    ErrorCode ret = this->browseEngineVersions(iceP_all, iceP_browser, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_browser, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_downloadEngineVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->readAll(iceP_name, iceP_version);
    inS.endReadParams();
    ::std::shared_ptr<DownloaderPrx> iceP_downloader;
    ErrorCode ret = this->downloadEngineVersion(::std::move(iceP_name), ::std::move(iceP_version), iceP_downloader, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_downloader, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_removeEngineVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->readAll(iceP_name, iceP_version);
    inS.endReadParams();
    ErrorCode ret = this->removeEngineVersion(::std::move(iceP_name), ::std::move(iceP_version), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_submitEngineVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->readAll(iceP_name, iceP_version);
    inS.endReadParams();
    ::std::shared_ptr<EngineVersionSubmitterPrx> iceP_submitter;
    ErrorCode ret = this->submitEngineVersion(::std::move(iceP_name), ::std::move(iceP_version), iceP_submitter, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_submitter, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_updateEngineVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->readAll(iceP_name, iceP_version);
    inS.endReadParams();
    ::std::shared_ptr<EngineVersionSubmitterPrx> iceP_submitter;
    ErrorCode ret = this->updateEngineVersion(::std::move(iceP_name), ::std::move(iceP_version), iceP_submitter, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_submitter, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getEngineVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->readAll(iceP_name, iceP_version);
    inS.endReadParams();
    EngineVersionInfo iceP_engineVersion;
    ErrorCode ret = this->getEngineVersion(::std::move(iceP_name), ::std::move(iceP_version), iceP_engineVersion, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_engineVersion, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_changeEngineVersionDisplayPriority(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    int iceP_displayPriority;
    istr->readAll(iceP_name, iceP_version, iceP_displayPriority);
    inS.endReadParams();
    ErrorCode ret = this->changeEngineVersionDisplayPriority(::std::move(iceP_name), ::std::move(iceP_version), iceP_displayPriority, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseExtra(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_category;
    ::std::string iceP_search;
    istr->readAll(iceP_category, iceP_search);
    inS.endReadParams();
    ::std::shared_ptr<ExtraBrowserPrx> iceP_browser;
    ErrorCode ret = this->browseExtra(::std::move(iceP_category), ::std::move(iceP_search), iceP_browser, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_browser, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseExtraByParentId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_parentId;
    istr->readAll(iceP_parentId);
    inS.endReadParams();
    ::std::shared_ptr<ExtraBrowserPrx> iceP_browser;
    ErrorCode ret = this->browseExtraByParentId(::std::move(iceP_parentId), iceP_browser, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_browser, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getExtraInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ExtraInfo iceP_info;
    ErrorCode ret = this->getExtraInfo(::std::move(iceP_id), iceP_info, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_info, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_downloadExtraImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ::std::shared_ptr<DownloaderPrx> iceP_downloader;
    ErrorCode ret = this->downloadExtraImage(::std::move(iceP_id), iceP_downloader, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_downloader, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_downloadExtra(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ::std::shared_ptr<DownloaderPrx> iceP_downloader;
    ErrorCode ret = this->downloadExtra(::std::move(iceP_id), iceP_downloader, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_downloader, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_submitExtra(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<ExtraSubmitterPrx> iceP_submitter;
    ErrorCode ret = this->submitExtra(iceP_submitter, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_submitter, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_updateExtra(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ::std::shared_ptr<ExtraSubmitterPrx> iceP_submitter;
    ErrorCode ret = this->updateExtra(::std::move(iceP_id), iceP_submitter, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_submitter, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_changeExtraState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::string iceP_state;
    istr->readAll(iceP_id, iceP_state);
    inS.endReadParams();
    ErrorCode ret = this->changeExtraState(::std::move(iceP_id), ::std::move(iceP_state), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_changeExtraDisplayPriority(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    int iceP_displayPriority;
    istr->readAll(iceP_id, iceP_displayPriority);
    inS.endReadParams();
    ErrorCode ret = this->changeExtraDisplayPriority(::std::move(iceP_id), iceP_displayPriority, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseClient(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<ClientBrowserPrx> iceP_browser;
    ErrorCode ret = this->browseClient(iceP_browser, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_browser, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getClientInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_version;
    istr->readAll(iceP_version);
    inS.endReadParams();
    ClientInfo iceP_info;
    ErrorCode ret = this->getClientInfo(::std::move(iceP_version), iceP_info, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_info, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_submitClient(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_version;
    istr->readAll(iceP_version);
    inS.endReadParams();
    ::std::shared_ptr<ClientSubmitterPrx> iceP_submitter;
    ErrorCode ret = this->submitClient(::std::move(iceP_version), iceP_submitter, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_submitter, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_updateClient(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_version;
    istr->readAll(iceP_version);
    inS.endReadParams();
    ::std::shared_ptr<ClientSubmitterPrx> iceP_submitter;
    ErrorCode ret = this->updateClient(::std::move(iceP_version), iceP_submitter, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_submitter, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_removeClient(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_version;
    istr->readAll(iceP_version);
    inS.endReadParams();
    ErrorCode ret = this->removeClient(::std::move(iceP_version), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::shared_ptr<UserBrowserPrx> iceP_browser;
    ErrorCode ret = this->browseUsers(iceP_browser, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_browser, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_setUserGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_username;
    ::std::string iceP_group;
    istr->readAll(iceP_username, iceP_group);
    inS.endReadParams();
    ErrorCode ret = this->setUserGroup(::std::move(iceP_username), ::std::move(iceP_group), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_removeUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_username;
    istr->readAll(iceP_username);
    inS.endReadParams();
    ErrorCode ret = this->removeUser(::std::move(iceP_username), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseComment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_targetId;
    ::std::string iceP_user;
    istr->readAll(iceP_targetId, iceP_user);
    inS.endReadParams();
    ::std::shared_ptr<CommentBrowserPrx> iceP_browser;
    ErrorCode ret = this->browseComment(::std::move(iceP_targetId), ::std::move(iceP_user), iceP_browser, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_browser, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getComment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_targetId;
    istr->readAll(iceP_targetId);
    inS.endReadParams();
    ::std::string iceP_comment;
    ErrorCode ret = this->getComment(::std::move(iceP_targetId), iceP_comment, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_comment, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_addComment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_targetId;
    ::std::string iceP_comment;
    istr->readAll(iceP_targetId, iceP_comment);
    inS.endReadParams();
    ErrorCode ret = this->addComment(::std::move(iceP_targetId), ::std::move(iceP_comment), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_editComment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::string iceP_comment;
    istr->readAll(iceP_id, iceP_comment);
    inS.endReadParams();
    ErrorCode ret = this->editComment(::std::move(iceP_id), ::std::move(iceP_comment), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_removeComment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->readAll(iceP_id);
    inS.endReadParams();
    ErrorCode ret = this->removeComment(::std::move(iceP_id), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_queryDownloadCount(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_targetId;
    istr->readAll(iceP_targetId);
    inS.endReadParams();
    int iceP_count;
    ErrorCode ret = this->queryDownloadCount(::std::move(iceP_targetId), iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_count, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_isUserOnline(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_userName;
    istr->readAll(iceP_userName);
    inS.endReadParams();
    bool iceP_result;
    ErrorCode ret = this->isUserOnline(::std::move(iceP_userName), iceP_result, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_result, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_onlineUserCount(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    int iceP_count;
    ErrorCode ret = this->onlineUserCount(iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_count, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_Session_ops, iceC_Rpc_Session_ops + 58, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_Session_ops)
    {
        case 0:
        {
            return _iceD_addComment(in, current);
        }
        case 1:
        {
            return _iceD_browseClient(in, current);
        }
        case 2:
        {
            return _iceD_browseComment(in, current);
        }
        case 3:
        {
            return _iceD_browseContent(in, current);
        }
        case 4:
        {
            return _iceD_browseContentByParentId(in, current);
        }
        case 5:
        {
            return _iceD_browseEngineVersions(in, current);
        }
        case 6:
        {
            return _iceD_browseExtra(in, current);
        }
        case 7:
        {
            return _iceD_browseExtraByParentId(in, current);
        }
        case 8:
        {
            return _iceD_browseUsers(in, current);
        }
        case 9:
        {
            return _iceD_changeContentDisplayPriority(in, current);
        }
        case 10:
        {
            return _iceD_changeContentState(in, current);
        }
        case 11:
        {
            return _iceD_changeEngineVersionDisplayPriority(in, current);
        }
        case 12:
        {
            return _iceD_changeExtraDisplayPriority(in, current);
        }
        case 13:
        {
            return _iceD_changeExtraState(in, current);
        }
        case 14:
        {
            return _iceD_copyContent(in, current);
        }
        case 15:
        {
            return _iceD_destroy(in, current);
        }
        case 16:
        {
            return _iceD_downloadContent(in, current);
        }
        case 17:
        {
            return _iceD_downloadContentImage(in, current);
        }
        case 18:
        {
            return _iceD_downloadEngineVersion(in, current);
        }
        case 19:
        {
            return _iceD_downloadExtra(in, current);
        }
        case 20:
        {
            return _iceD_downloadExtraImage(in, current);
        }
        case 21:
        {
            return _iceD_editComment(in, current);
        }
        case 22:
        {
            return _iceD_editContent(in, current);
        }
        case 23:
        {
            return _iceD_getClientInfo(in, current);
        }
        case 24:
        {
            return _iceD_getComment(in, current);
        }
        case 25:
        {
            return _iceD_getContentCategories(in, current);
        }
        case 26:
        {
            return _iceD_getContentInfo(in, current);
        }
        case 27:
        {
            return _iceD_getCurrentUser(in, current);
        }
        case 28:
        {
            return _iceD_getCurrentUserGroup(in, current);
        }
        case 29:
        {
            return _iceD_getEngineVersion(in, current);
        }
        case 30:
        {
            return _iceD_getExtraCategories(in, current);
        }
        case 31:
        {
            return _iceD_getExtraInfo(in, current);
        }
        case 32:
        {
            return _iceD_getPages(in, current);
        }
        case 33:
        {
            return _iceD_getUniformInfo(in, current);
        }
        case 34:
        {
            return _iceD_ice_id(in, current);
        }
        case 35:
        {
            return _iceD_ice_ids(in, current);
        }
        case 36:
        {
            return _iceD_ice_isA(in, current);
        }
        case 37:
        {
            return _iceD_ice_ping(in, current);
        }
        case 38:
        {
            return _iceD_isUserOnline(in, current);
        }
        case 39:
        {
            return _iceD_onlineUserCount(in, current);
        }
        case 40:
        {
            return _iceD_queryDownloadCount(in, current);
        }
        case 41:
        {
            return _iceD_refresh(in, current);
        }
        case 42:
        {
            return _iceD_removeClient(in, current);
        }
        case 43:
        {
            return _iceD_removeComment(in, current);
        }
        case 44:
        {
            return _iceD_removeEngineVersion(in, current);
        }
        case 45:
        {
            return _iceD_removeUser(in, current);
        }
        case 46:
        {
            return _iceD_setContentCategories(in, current);
        }
        case 47:
        {
            return _iceD_setExtraCategories(in, current);
        }
        case 48:
        {
            return _iceD_setPages(in, current);
        }
        case 49:
        {
            return _iceD_setUniformInfo(in, current);
        }
        case 50:
        {
            return _iceD_setUserGroup(in, current);
        }
        case 51:
        {
            return _iceD_submitClient(in, current);
        }
        case 52:
        {
            return _iceD_submitContent(in, current);
        }
        case 53:
        {
            return _iceD_submitEngineVersion(in, current);
        }
        case 54:
        {
            return _iceD_submitExtra(in, current);
        }
        case 55:
        {
            return _iceD_updateClient(in, current);
        }
        case 56:
        {
            return _iceD_updateEngineVersion(in, current);
        }
        case 57:
        {
            return _iceD_updateExtra(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentBrowserPrx::_iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ContentBrowser::NextResult>>& outAsync, int iceP_n, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentBrowser_next_name);
    outAsync->invoke(iceC_Rpc_ContentBrowser_next_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_n);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ContentBrowser::NextResult v;
            istr->readAll(v.items, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Rpc::ContentBrowserPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ContentBrowserPrx>();
}
/// \endcond

const ::std::string&
Rpc::ContentBrowserPrx::ice_staticId()
{
    return ContentBrowser::ice_staticId();
}

/// \cond INTERNAL
void
Rpc::EngineVersionBrowserPrx::_iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<EngineVersionBrowser::NextResult>>& outAsync, int iceP_n, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionBrowser_next_name);
    outAsync->invoke(iceC_Rpc_EngineVersionBrowser_next_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_n);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            EngineVersionBrowser::NextResult v;
            istr->readAll(v.items, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Rpc::EngineVersionBrowserPrx::_newInstance() const
{
    return ::IceInternal::createProxy<EngineVersionBrowserPrx>();
}
/// \endcond

const ::std::string&
Rpc::EngineVersionBrowserPrx::ice_staticId()
{
    return EngineVersionBrowser::ice_staticId();
}

/// \cond INTERNAL
void
Rpc::ExtraBrowserPrx::_iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ExtraBrowser::NextResult>>& outAsync, int iceP_n, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ExtraBrowser_next_name);
    outAsync->invoke(iceC_Rpc_ExtraBrowser_next_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_n);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ExtraBrowser::NextResult v;
            istr->readAll(v.items, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Rpc::ExtraBrowserPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ExtraBrowserPrx>();
}
/// \endcond

const ::std::string&
Rpc::ExtraBrowserPrx::ice_staticId()
{
    return ExtraBrowser::ice_staticId();
}

/// \cond INTERNAL
void
Rpc::UserBrowserPrx::_iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<UserBrowser::NextResult>>& outAsync, int iceP_n, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_UserBrowser_next_name);
    outAsync->invoke(iceC_Rpc_UserBrowser_next_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_n);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            UserBrowser::NextResult v;
            istr->readAll(v.items, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Rpc::UserBrowserPrx::_newInstance() const
{
    return ::IceInternal::createProxy<UserBrowserPrx>();
}
/// \endcond

const ::std::string&
Rpc::UserBrowserPrx::ice_staticId()
{
    return UserBrowser::ice_staticId();
}

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_getId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ContentSubmitter::GetIdResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_getId_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_getId_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ContentSubmitter::GetIdResult v;
            istr->readAll(v.id, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_setTitle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_title, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setTitle_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_setTitle_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_title);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_setPage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_page, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setPage_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_setPage_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_page);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_setCategory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_category, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setCategory_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_setCategory_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_category);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_setEngine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setEngine_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_setEngine_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_version);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_setStartup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_startup, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setStartup_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_setStartup_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_startup);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_setParentId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setParentId_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_setParentId_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_setVideo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_video, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setVideo_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_setVideo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_video);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_setDescription(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_description, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setDescription_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_setDescription_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_description);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_uploadImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ContentSubmitter::UploadImageResult>>& outAsync, int iceP_index, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_uploadImage_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_uploadImage_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_index);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ContentSubmitter::UploadImageResult v;
            istr->readAll(v.uploader, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_uploadContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ContentSubmitter::UploadContentResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_uploadContent_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_uploadContent_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ContentSubmitter::UploadContentResult v;
            istr->readAll(v.uploader, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_cancel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Rpc_ContentSubmitter_cancel_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ContentSubmitterPrx::_iceI_finish(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_finish_name);
    outAsync->invoke(iceC_Rpc_ContentSubmitter_finish_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Rpc::ContentSubmitterPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ContentSubmitterPrx>();
}
/// \endcond

const ::std::string&
Rpc::ContentSubmitterPrx::ice_staticId()
{
    return ContentSubmitter::ice_staticId();
}

/// \cond INTERNAL
void
Rpc::EngineVersionSubmitterPrx::_iceI_setSetup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_setup, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionSubmitter_setSetup_name);
    outAsync->invoke(iceC_Rpc_EngineVersionSubmitter_setSetup_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_setup);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::EngineVersionSubmitterPrx::_iceI_setUnSetup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_unsetup, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionSubmitter_setUnSetup_name);
    outAsync->invoke(iceC_Rpc_EngineVersionSubmitter_setUnSetup_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_unsetup);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::EngineVersionSubmitterPrx::_iceI_setInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionSubmitter_setInfo_name);
    outAsync->invoke(iceC_Rpc_EngineVersionSubmitter_setInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::EngineVersionSubmitterPrx::_iceI_uploadEngine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<EngineVersionSubmitter::UploadEngineResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionSubmitter_uploadEngine_name);
    outAsync->invoke(iceC_Rpc_EngineVersionSubmitter_uploadEngine_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            EngineVersionSubmitter::UploadEngineResult v;
            istr->readAll(v.uploader, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::EngineVersionSubmitterPrx::_iceI_cancel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Rpc_EngineVersionSubmitter_cancel_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::EngineVersionSubmitterPrx::_iceI_finish(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionSubmitter_finish_name);
    outAsync->invoke(iceC_Rpc_EngineVersionSubmitter_finish_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Rpc::EngineVersionSubmitterPrx::_newInstance() const
{
    return ::IceInternal::createProxy<EngineVersionSubmitterPrx>();
}
/// \endcond

const ::std::string&
Rpc::EngineVersionSubmitterPrx::ice_staticId()
{
    return EngineVersionSubmitter::ice_staticId();
}

/// \cond INTERNAL
void
Rpc::ExtraSubmitterPrx::_iceI_setParentId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_setParentId_name);
    outAsync->invoke(iceC_Rpc_ExtraSubmitter_setParentId_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ExtraSubmitterPrx::_iceI_setTitle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_title, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_setTitle_name);
    outAsync->invoke(iceC_Rpc_ExtraSubmitter_setTitle_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_title);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ExtraSubmitterPrx::_iceI_setSetup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_setup, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_setSetup_name);
    outAsync->invoke(iceC_Rpc_ExtraSubmitter_setSetup_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_setup);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ExtraSubmitterPrx::_iceI_setCategory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_category, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_setCategory_name);
    outAsync->invoke(iceC_Rpc_ExtraSubmitter_setCategory_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_category);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ExtraSubmitterPrx::_iceI_setInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_setInfo_name);
    outAsync->invoke(iceC_Rpc_ExtraSubmitter_setInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ExtraSubmitterPrx::_iceI_uploadImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ExtraSubmitter::UploadImageResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_uploadImage_name);
    outAsync->invoke(iceC_Rpc_ExtraSubmitter_uploadImage_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ExtraSubmitter::UploadImageResult v;
            istr->readAll(v.uploader, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ExtraSubmitterPrx::_iceI_uploadExtra(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ExtraSubmitter::UploadExtraResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_uploadExtra_name);
    outAsync->invoke(iceC_Rpc_ExtraSubmitter_uploadExtra_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ExtraSubmitter::UploadExtraResult v;
            istr->readAll(v.uploader, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ExtraSubmitterPrx::_iceI_cancel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Rpc_ExtraSubmitter_cancel_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ExtraSubmitterPrx::_iceI_finish(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_finish_name);
    outAsync->invoke(iceC_Rpc_ExtraSubmitter_finish_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Rpc::ExtraSubmitterPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ExtraSubmitterPrx>();
}
/// \endcond

const ::std::string&
Rpc::ExtraSubmitterPrx::ice_staticId()
{
    return ExtraSubmitter::ice_staticId();
}

/// \cond INTERNAL
void
Rpc::ClientBrowserPrx::_iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ClientBrowser::NextResult>>& outAsync, int iceP_n, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ClientBrowser_next_name);
    outAsync->invoke(iceC_Rpc_ClientBrowser_next_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_n);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ClientBrowser::NextResult v;
            istr->readAll(v.items, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Rpc::ClientBrowserPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ClientBrowserPrx>();
}
/// \endcond

const ::std::string&
Rpc::ClientBrowserPrx::ice_staticId()
{
    return ClientBrowser::ice_staticId();
}

/// \cond INTERNAL
void
Rpc::ClientSubmitterPrx::_iceI_setInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ClientSubmitter_setInfo_name);
    outAsync->invoke(iceC_Rpc_ClientSubmitter_setInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ClientSubmitterPrx::_iceI_uploadClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ClientSubmitter::UploadClientResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ClientSubmitter_uploadClient_name);
    outAsync->invoke(iceC_Rpc_ClientSubmitter_uploadClient_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ClientSubmitter::UploadClientResult v;
            istr->readAll(v.uploader, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ClientSubmitterPrx::_iceI_cancel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Rpc_ClientSubmitter_cancel_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::ClientSubmitterPrx::_iceI_finish(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_ClientSubmitter_finish_name);
    outAsync->invoke(iceC_Rpc_ClientSubmitter_finish_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Rpc::ClientSubmitterPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ClientSubmitterPrx>();
}
/// \endcond

const ::std::string&
Rpc::ClientSubmitterPrx::ice_staticId()
{
    return ClientSubmitter::ice_staticId();
}

/// \cond INTERNAL
void
Rpc::CommentBrowserPrx::_iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<CommentBrowser::NextResult>>& outAsync, int iceP_n, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_CommentBrowser_next_name);
    outAsync->invoke(iceC_Rpc_CommentBrowser_next_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_n);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            CommentBrowser::NextResult v;
            istr->readAll(v.items, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Rpc::CommentBrowserPrx::_newInstance() const
{
    return ::IceInternal::createProxy<CommentBrowserPrx>();
}
/// \endcond

const ::std::string&
Rpc::CommentBrowserPrx::ice_staticId()
{
    return CommentBrowser::ice_staticId();
}

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_refresh(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_Rpc_Session_refresh_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_getCurrentUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetCurrentUserResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_getCurrentUser_name);
    outAsync->invoke(iceC_Rpc_Session_getCurrentUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::GetCurrentUserResult v;
            istr->readAll(v.user, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_getCurrentUserGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetCurrentUserGroupResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_getCurrentUserGroup_name);
    outAsync->invoke(iceC_Rpc_Session_getCurrentUserGroup_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::GetCurrentUserGroupResult v;
            istr->readAll(v.group, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_setPages(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const StringSeq& iceP_pages, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_setPages_name);
    outAsync->invoke(iceC_Rpc_Session_setPages_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_pages);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_getPages(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetPagesResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_getPages_name);
    outAsync->invoke(iceC_Rpc_Session_getPages_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::GetPagesResult v;
            istr->readAll(v.pages, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_setContentCategories(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const StringSeq& iceP_categories, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_setContentCategories_name);
    outAsync->invoke(iceC_Rpc_Session_setContentCategories_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_categories);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_getContentCategories(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetContentCategoriesResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_getContentCategories_name);
    outAsync->invoke(iceC_Rpc_Session_getContentCategories_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::GetContentCategoriesResult v;
            istr->readAll(v.categories, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_setExtraCategories(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const StringSeq& iceP_categories, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_setExtraCategories_name);
    outAsync->invoke(iceC_Rpc_Session_setExtraCategories_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_categories);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_getExtraCategories(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetExtraCategoriesResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_getExtraCategories_name);
    outAsync->invoke(iceC_Rpc_Session_getExtraCategories_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::GetExtraCategoriesResult v;
            istr->readAll(v.categories, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_setUniformInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_key, const ::std::string& iceP_value, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_setUniformInfo_name);
    outAsync->invoke(iceC_Rpc_Session_setUniformInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_key, iceP_value);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_getUniformInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetUniformInfoResult>>& outAsync, const ::std::string& iceP_key, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_getUniformInfo_name);
    outAsync->invoke(iceC_Rpc_Session_getUniformInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_key);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::GetUniformInfoResult v;
            istr->readAll(v.value, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_browseContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseContentResult>>& outAsync, const ::std::string& iceP_page, const ::std::string& iceP_category, const ::std::string& iceP_search, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseContent_name);
    outAsync->invoke(iceC_Rpc_Session_browseContent_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_page, iceP_category, iceP_search);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::BrowseContentResult v;
            istr->readAll(v.browser, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_browseContentByParentId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseContentByParentIdResult>>& outAsync, const ::std::string& iceP_parentId, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseContentByParentId_name);
    outAsync->invoke(iceC_Rpc_Session_browseContentByParentId_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_parentId);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::BrowseContentByParentIdResult v;
            istr->readAll(v.browser, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_getContentInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetContentInfoResult>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_getContentInfo_name);
    outAsync->invoke(iceC_Rpc_Session_getContentInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::GetContentInfoResult v;
            istr->readAll(v.info, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_downloadContentImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::DownloadContentImageResult>>& outAsync, const ::std::string& iceP_id, int iceP_index, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_downloadContentImage_name);
    outAsync->invoke(iceC_Rpc_Session_downloadContentImage_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_index);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::DownloadContentImageResult v;
            istr->readAll(v.downloader, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_downloadContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::DownloadContentResult>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_downloadContent_name);
    outAsync->invoke(iceC_Rpc_Session_downloadContent_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::DownloadContentResult v;
            istr->readAll(v.downloader, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_submitContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::SubmitContentResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_submitContent_name);
    outAsync->invoke(iceC_Rpc_Session_submitContent_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::SubmitContentResult v;
            istr->readAll(v.submitter, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_copyContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::CopyContentResult>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_copyContent_name);
    outAsync->invoke(iceC_Rpc_Session_copyContent_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::CopyContentResult v;
            istr->readAll(v.submitter, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_editContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::EditContentResult>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_editContent_name);
    outAsync->invoke(iceC_Rpc_Session_editContent_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::EditContentResult v;
            istr->readAll(v.submitter, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_changeContentState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_id, const ::std::string& iceP_state, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_changeContentState_name);
    outAsync->invoke(iceC_Rpc_Session_changeContentState_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_changeContentDisplayPriority(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_id, int iceP_displayPriority, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_changeContentDisplayPriority_name);
    outAsync->invoke(iceC_Rpc_Session_changeContentDisplayPriority_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_displayPriority);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_browseEngineVersions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseEngineVersionsResult>>& outAsync, bool iceP_all, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseEngineVersions_name);
    outAsync->invoke(iceC_Rpc_Session_browseEngineVersions_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_all);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::BrowseEngineVersionsResult v;
            istr->readAll(v.browser, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_downloadEngineVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::DownloadEngineVersionResult>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_downloadEngineVersion_name);
    outAsync->invoke(iceC_Rpc_Session_downloadEngineVersion_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_version);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::DownloadEngineVersionResult v;
            istr->readAll(v.downloader, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_removeEngineVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_removeEngineVersion_name);
    outAsync->invoke(iceC_Rpc_Session_removeEngineVersion_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_version);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_submitEngineVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::SubmitEngineVersionResult>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_submitEngineVersion_name);
    outAsync->invoke(iceC_Rpc_Session_submitEngineVersion_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_version);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::SubmitEngineVersionResult v;
            istr->readAll(v.submitter, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_updateEngineVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::UpdateEngineVersionResult>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_updateEngineVersion_name);
    outAsync->invoke(iceC_Rpc_Session_updateEngineVersion_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_version);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::UpdateEngineVersionResult v;
            istr->readAll(v.submitter, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_getEngineVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetEngineVersionResult>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_getEngineVersion_name);
    outAsync->invoke(iceC_Rpc_Session_getEngineVersion_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_version);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::GetEngineVersionResult v;
            istr->readAll(v.engineVersion, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_changeEngineVersionDisplayPriority(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_version, int iceP_displayPriority, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_changeEngineVersionDisplayPriority_name);
    outAsync->invoke(iceC_Rpc_Session_changeEngineVersionDisplayPriority_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_version, iceP_displayPriority);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_browseExtra(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseExtraResult>>& outAsync, const ::std::string& iceP_category, const ::std::string& iceP_search, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseExtra_name);
    outAsync->invoke(iceC_Rpc_Session_browseExtra_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_category, iceP_search);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::BrowseExtraResult v;
            istr->readAll(v.browser, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_browseExtraByParentId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseExtraByParentIdResult>>& outAsync, const ::std::string& iceP_parentId, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseExtraByParentId_name);
    outAsync->invoke(iceC_Rpc_Session_browseExtraByParentId_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_parentId);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::BrowseExtraByParentIdResult v;
            istr->readAll(v.browser, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_getExtraInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetExtraInfoResult>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_getExtraInfo_name);
    outAsync->invoke(iceC_Rpc_Session_getExtraInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::GetExtraInfoResult v;
            istr->readAll(v.info, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_downloadExtraImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::DownloadExtraImageResult>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_downloadExtraImage_name);
    outAsync->invoke(iceC_Rpc_Session_downloadExtraImage_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::DownloadExtraImageResult v;
            istr->readAll(v.downloader, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_downloadExtra(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::DownloadExtraResult>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_downloadExtra_name);
    outAsync->invoke(iceC_Rpc_Session_downloadExtra_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::DownloadExtraResult v;
            istr->readAll(v.downloader, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_submitExtra(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::SubmitExtraResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_submitExtra_name);
    outAsync->invoke(iceC_Rpc_Session_submitExtra_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::SubmitExtraResult v;
            istr->readAll(v.submitter, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_updateExtra(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::UpdateExtraResult>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_updateExtra_name);
    outAsync->invoke(iceC_Rpc_Session_updateExtra_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::UpdateExtraResult v;
            istr->readAll(v.submitter, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_changeExtraState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_id, const ::std::string& iceP_state, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_changeExtraState_name);
    outAsync->invoke(iceC_Rpc_Session_changeExtraState_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_state);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_changeExtraDisplayPriority(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_id, int iceP_displayPriority, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_changeExtraDisplayPriority_name);
    outAsync->invoke(iceC_Rpc_Session_changeExtraDisplayPriority_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_displayPriority);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_browseClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseClientResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseClient_name);
    outAsync->invoke(iceC_Rpc_Session_browseClient_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::BrowseClientResult v;
            istr->readAll(v.browser, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_getClientInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetClientInfoResult>>& outAsync, const ::std::string& iceP_version, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_getClientInfo_name);
    outAsync->invoke(iceC_Rpc_Session_getClientInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_version);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::GetClientInfoResult v;
            istr->readAll(v.info, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_submitClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::SubmitClientResult>>& outAsync, const ::std::string& iceP_version, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_submitClient_name);
    outAsync->invoke(iceC_Rpc_Session_submitClient_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_version);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::SubmitClientResult v;
            istr->readAll(v.submitter, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_updateClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::UpdateClientResult>>& outAsync, const ::std::string& iceP_version, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_updateClient_name);
    outAsync->invoke(iceC_Rpc_Session_updateClient_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_version);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::UpdateClientResult v;
            istr->readAll(v.submitter, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_removeClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_version, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_removeClient_name);
    outAsync->invoke(iceC_Rpc_Session_removeClient_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_version);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_browseUsers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseUsersResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseUsers_name);
    outAsync->invoke(iceC_Rpc_Session_browseUsers_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::BrowseUsersResult v;
            istr->readAll(v.browser, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_setUserGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_username, const ::std::string& iceP_group, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_setUserGroup_name);
    outAsync->invoke(iceC_Rpc_Session_setUserGroup_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_username, iceP_group);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_removeUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_username, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_removeUser_name);
    outAsync->invoke(iceC_Rpc_Session_removeUser_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_username);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_browseComment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseCommentResult>>& outAsync, const ::std::string& iceP_targetId, const ::std::string& iceP_user, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseComment_name);
    outAsync->invoke(iceC_Rpc_Session_browseComment_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_targetId, iceP_user);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::BrowseCommentResult v;
            istr->readAll(v.browser, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_getComment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetCommentResult>>& outAsync, const ::std::string& iceP_targetId, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_getComment_name);
    outAsync->invoke(iceC_Rpc_Session_getComment_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_targetId);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::GetCommentResult v;
            istr->readAll(v.comment, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_addComment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_targetId, const ::std::string& iceP_comment, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_addComment_name);
    outAsync->invoke(iceC_Rpc_Session_addComment_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_targetId, iceP_comment);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_editComment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_id, const ::std::string& iceP_comment, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_editComment_name);
    outAsync->invoke(iceC_Rpc_Session_editComment_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id, iceP_comment);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_removeComment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>& outAsync, const ::std::string& iceP_id, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_removeComment_name);
    outAsync->invoke(iceC_Rpc_Session_removeComment_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_id);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_queryDownloadCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::QueryDownloadCountResult>>& outAsync, const ::std::string& iceP_targetId, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_queryDownloadCount_name);
    outAsync->invoke(iceC_Rpc_Session_queryDownloadCount_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_targetId);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::QueryDownloadCountResult v;
            istr->readAll(v.count, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_isUserOnline(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::IsUserOnlineResult>>& outAsync, const ::std::string& iceP_userName, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_isUserOnline_name);
    outAsync->invoke(iceC_Rpc_Session_isUserOnline_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_userName);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::IsUserOnlineResult v;
            istr->readAll(v.result, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
Rpc::SessionPrx::_iceI_onlineUserCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::OnlineUserCountResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_Rpc_Session_onlineUserCount_name);
    outAsync->invoke(iceC_Rpc_Session_onlineUserCount_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            Session::OnlineUserCountResult v;
            istr->readAll(v.count, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
Rpc::SessionPrx::_newInstance() const
{
    return ::IceInternal::createProxy<SessionPrx>();
}
/// \endcond

const ::std::string&
Rpc::SessionPrx::ice_staticId()
{
    return Session::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

const ::std::string iceC_Rpc_ContentBrowser_next_name = "next";

const ::std::string iceC_Rpc_EngineVersionBrowser_next_name = "next";

const ::std::string iceC_Rpc_ExtraBrowser_next_name = "next";

const ::std::string iceC_Rpc_UserBrowser_next_name = "next";

const ::std::string iceC_Rpc_ContentSubmitter_getId_name = "getId";

const ::std::string iceC_Rpc_ContentSubmitter_setTitle_name = "setTitle";

const ::std::string iceC_Rpc_ContentSubmitter_setPage_name = "setPage";

const ::std::string iceC_Rpc_ContentSubmitter_setCategory_name = "setCategory";

const ::std::string iceC_Rpc_ContentSubmitter_setEngine_name = "setEngine";

const ::std::string iceC_Rpc_ContentSubmitter_setStartup_name = "setStartup";

const ::std::string iceC_Rpc_ContentSubmitter_setParentId_name = "setParentId";

const ::std::string iceC_Rpc_ContentSubmitter_setVideo_name = "setVideo";

const ::std::string iceC_Rpc_ContentSubmitter_setDescription_name = "setDescription";

const ::std::string iceC_Rpc_ContentSubmitter_uploadImage_name = "uploadImage";

const ::std::string iceC_Rpc_ContentSubmitter_uploadContent_name = "uploadContent";

const ::std::string iceC_Rpc_ContentSubmitter_cancel_name = "cancel";

const ::std::string iceC_Rpc_ContentSubmitter_finish_name = "finish";

const ::std::string iceC_Rpc_EngineVersionSubmitter_setSetup_name = "setSetup";

const ::std::string iceC_Rpc_EngineVersionSubmitter_setUnSetup_name = "setUnSetup";

const ::std::string iceC_Rpc_EngineVersionSubmitter_setInfo_name = "setInfo";

const ::std::string iceC_Rpc_EngineVersionSubmitter_uploadEngine_name = "uploadEngine";

const ::std::string iceC_Rpc_EngineVersionSubmitter_cancel_name = "cancel";

const ::std::string iceC_Rpc_EngineVersionSubmitter_finish_name = "finish";

const ::std::string iceC_Rpc_ExtraSubmitter_setParentId_name = "setParentId";

const ::std::string iceC_Rpc_ExtraSubmitter_setTitle_name = "setTitle";

const ::std::string iceC_Rpc_ExtraSubmitter_setSetup_name = "setSetup";

const ::std::string iceC_Rpc_ExtraSubmitter_setCategory_name = "setCategory";

const ::std::string iceC_Rpc_ExtraSubmitter_setInfo_name = "setInfo";

const ::std::string iceC_Rpc_ExtraSubmitter_uploadImage_name = "uploadImage";

const ::std::string iceC_Rpc_ExtraSubmitter_uploadExtra_name = "uploadExtra";

const ::std::string iceC_Rpc_ExtraSubmitter_cancel_name = "cancel";

const ::std::string iceC_Rpc_ExtraSubmitter_finish_name = "finish";

const ::std::string iceC_Rpc_ClientBrowser_next_name = "next";

const ::std::string iceC_Rpc_ClientSubmitter_setInfo_name = "setInfo";

const ::std::string iceC_Rpc_ClientSubmitter_uploadClient_name = "uploadClient";

const ::std::string iceC_Rpc_ClientSubmitter_cancel_name = "cancel";

const ::std::string iceC_Rpc_ClientSubmitter_finish_name = "finish";

const ::std::string iceC_Rpc_CommentBrowser_next_name = "next";

const ::std::string iceC_Rpc_Session_refresh_name = "refresh";

const ::std::string iceC_Rpc_Session_getCurrentUser_name = "getCurrentUser";

const ::std::string iceC_Rpc_Session_getCurrentUserGroup_name = "getCurrentUserGroup";

const ::std::string iceC_Rpc_Session_setPages_name = "setPages";

const ::std::string iceC_Rpc_Session_getPages_name = "getPages";

const ::std::string iceC_Rpc_Session_setContentCategories_name = "setContentCategories";

const ::std::string iceC_Rpc_Session_getContentCategories_name = "getContentCategories";

const ::std::string iceC_Rpc_Session_setExtraCategories_name = "setExtraCategories";

const ::std::string iceC_Rpc_Session_getExtraCategories_name = "getExtraCategories";

const ::std::string iceC_Rpc_Session_setUniformInfo_name = "setUniformInfo";

const ::std::string iceC_Rpc_Session_getUniformInfo_name = "getUniformInfo";

const ::std::string iceC_Rpc_Session_browseContent_name = "browseContent";

const ::std::string iceC_Rpc_Session_browseContentByParentId_name = "browseContentByParentId";

const ::std::string iceC_Rpc_Session_getContentInfo_name = "getContentInfo";

const ::std::string iceC_Rpc_Session_downloadContentImage_name = "downloadContentImage";

const ::std::string iceC_Rpc_Session_downloadContent_name = "downloadContent";

const ::std::string iceC_Rpc_Session_submitContent_name = "submitContent";

const ::std::string iceC_Rpc_Session_copyContent_name = "copyContent";

const ::std::string iceC_Rpc_Session_editContent_name = "editContent";

const ::std::string iceC_Rpc_Session_changeContentState_name = "changeContentState";

const ::std::string iceC_Rpc_Session_changeContentDisplayPriority_name = "changeContentDisplayPriority";

const ::std::string iceC_Rpc_Session_browseEngineVersions_name = "browseEngineVersions";

const ::std::string iceC_Rpc_Session_downloadEngineVersion_name = "downloadEngineVersion";

const ::std::string iceC_Rpc_Session_removeEngineVersion_name = "removeEngineVersion";

const ::std::string iceC_Rpc_Session_submitEngineVersion_name = "submitEngineVersion";

const ::std::string iceC_Rpc_Session_updateEngineVersion_name = "updateEngineVersion";

const ::std::string iceC_Rpc_Session_getEngineVersion_name = "getEngineVersion";

const ::std::string iceC_Rpc_Session_changeEngineVersionDisplayPriority_name = "changeEngineVersionDisplayPriority";

const ::std::string iceC_Rpc_Session_browseExtra_name = "browseExtra";

const ::std::string iceC_Rpc_Session_browseExtraByParentId_name = "browseExtraByParentId";

const ::std::string iceC_Rpc_Session_getExtraInfo_name = "getExtraInfo";

const ::std::string iceC_Rpc_Session_downloadExtraImage_name = "downloadExtraImage";

const ::std::string iceC_Rpc_Session_downloadExtra_name = "downloadExtra";

const ::std::string iceC_Rpc_Session_submitExtra_name = "submitExtra";

const ::std::string iceC_Rpc_Session_updateExtra_name = "updateExtra";

const ::std::string iceC_Rpc_Session_changeExtraState_name = "changeExtraState";

const ::std::string iceC_Rpc_Session_changeExtraDisplayPriority_name = "changeExtraDisplayPriority";

const ::std::string iceC_Rpc_Session_browseClient_name = "browseClient";

const ::std::string iceC_Rpc_Session_getClientInfo_name = "getClientInfo";

const ::std::string iceC_Rpc_Session_submitClient_name = "submitClient";

const ::std::string iceC_Rpc_Session_updateClient_name = "updateClient";

const ::std::string iceC_Rpc_Session_removeClient_name = "removeClient";

const ::std::string iceC_Rpc_Session_browseUsers_name = "browseUsers";

const ::std::string iceC_Rpc_Session_setUserGroup_name = "setUserGroup";

const ::std::string iceC_Rpc_Session_removeUser_name = "removeUser";

const ::std::string iceC_Rpc_Session_browseComment_name = "browseComment";

const ::std::string iceC_Rpc_Session_getComment_name = "getComment";

const ::std::string iceC_Rpc_Session_addComment_name = "addComment";

const ::std::string iceC_Rpc_Session_editComment_name = "editComment";

const ::std::string iceC_Rpc_Session_removeComment_name = "removeComment";

const ::std::string iceC_Rpc_Session_queryDownloadCount_name = "queryDownloadCount";

const ::std::string iceC_Rpc_Session_isUserOnline_name = "isUserOnline";

const ::std::string iceC_Rpc_Session_onlineUserCount_name = "onlineUserCount";

}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Rpc::upCast(ContentBrowser* p) { return p; }

void
::IceProxy::Rpc::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ContentBrowser>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ContentBrowser;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentBrowser::_iceI_begin_next(::Ice::Int iceP_n, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentBrowser_next_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentBrowser_next_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentBrowser_next_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_n);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ContentBrowser_next_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentBrowser::end_next(::Rpc::ContentItemSeq& iceP_items, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentBrowser_next_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::ContentBrowser::_iceI_end_next(::Rpc::ContentItemSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentBrowser_next_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Rpc::ContentBrowser::_newInstance() const
{
    return new ContentBrowser;
}
/// \endcond

const ::std::string&
IceProxy::Rpc::ContentBrowser::ice_staticId()
{
    return ::Rpc::ContentBrowser::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Rpc::upCast(EngineVersionBrowser* p) { return p; }

void
::IceProxy::Rpc::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< EngineVersionBrowser>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new EngineVersionBrowser;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Rpc::EngineVersionBrowser::_iceI_begin_next(::Ice::Int iceP_n, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionBrowser_next_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_EngineVersionBrowser_next_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_EngineVersionBrowser_next_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_n);
        result->endWriteParams();
        result->invoke(iceC_Rpc_EngineVersionBrowser_next_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::EngineVersionBrowser::end_next(::Rpc::EngineVersionSeq& iceP_items, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_EngineVersionBrowser_next_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::EngineVersionBrowser::_iceI_end_next(::Rpc::EngineVersionSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_EngineVersionBrowser_next_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Rpc::EngineVersionBrowser::_newInstance() const
{
    return new EngineVersionBrowser;
}
/// \endcond

const ::std::string&
IceProxy::Rpc::EngineVersionBrowser::ice_staticId()
{
    return ::Rpc::EngineVersionBrowser::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Rpc::upCast(ExtraBrowser* p) { return p; }

void
::IceProxy::Rpc::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ExtraBrowser>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ExtraBrowser;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Rpc::ExtraBrowser::_iceI_begin_next(::Ice::Int iceP_n, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ExtraBrowser_next_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ExtraBrowser_next_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ExtraBrowser_next_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_n);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ExtraBrowser_next_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ExtraBrowser::end_next(::Rpc::ExtraInfoSeq& iceP_items, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraBrowser_next_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::ExtraBrowser::_iceI_end_next(::Rpc::ExtraInfoSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraBrowser_next_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Rpc::ExtraBrowser::_newInstance() const
{
    return new ExtraBrowser;
}
/// \endcond

const ::std::string&
IceProxy::Rpc::ExtraBrowser::ice_staticId()
{
    return ::Rpc::ExtraBrowser::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Rpc::upCast(UserBrowser* p) { return p; }

void
::IceProxy::Rpc::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< UserBrowser>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new UserBrowser;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Rpc::UserBrowser::_iceI_begin_next(::Ice::Int iceP_n, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_UserBrowser_next_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_UserBrowser_next_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_UserBrowser_next_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_n);
        result->endWriteParams();
        result->invoke(iceC_Rpc_UserBrowser_next_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::UserBrowser::end_next(::Rpc::UserSeq& iceP_items, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_UserBrowser_next_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::UserBrowser::_iceI_end_next(::Rpc::UserSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_UserBrowser_next_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Rpc::UserBrowser::_newInstance() const
{
    return new UserBrowser;
}
/// \endcond

const ::std::string&
IceProxy::Rpc::UserBrowser::ice_staticId()
{
    return ::Rpc::UserBrowser::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Rpc::upCast(ContentSubmitter* p) { return p; }

void
::IceProxy::Rpc::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ContentSubmitter>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ContentSubmitter;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_getId(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_getId_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_getId_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_getId_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_ContentSubmitter_getId_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_getId(::std::string& iceP_id, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_getId_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_id);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::ContentSubmitter::_iceI_end_getId(::std::string& iceP_id, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_getId_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_id);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_setTitle(const ::std::string& iceP_title, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setTitle_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_setTitle_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_setTitle_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_title);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ContentSubmitter_setTitle_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_setTitle(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_setTitle_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_setPage(const ::std::string& iceP_page, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setPage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_setPage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_setPage_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_page);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ContentSubmitter_setPage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_setPage(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_setPage_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_setCategory(const ::std::string& iceP_category, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setCategory_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_setCategory_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_setCategory_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_category);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ContentSubmitter_setCategory_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_setCategory(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_setCategory_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_setEngine(const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setEngine_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_setEngine_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_setEngine_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_version);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ContentSubmitter_setEngine_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_setEngine(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_setEngine_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_setStartup(const ::std::string& iceP_startup, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setStartup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_setStartup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_setStartup_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_startup);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ContentSubmitter_setStartup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_setStartup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_setStartup_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_setParentId(const ::std::string& iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setParentId_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_setParentId_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_setParentId_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ContentSubmitter_setParentId_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_setParentId(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_setParentId_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_setVideo(const ::std::string& iceP_video, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setVideo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_setVideo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_setVideo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_video);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ContentSubmitter_setVideo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_setVideo(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_setVideo_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_setDescription(const ::std::string& iceP_description, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_setDescription_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_setDescription_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_setDescription_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_description);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ContentSubmitter_setDescription_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_setDescription(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_setDescription_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_uploadImage(::Ice::Int iceP_index, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_uploadImage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_uploadImage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_uploadImage_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_index);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ContentSubmitter_uploadImage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_uploadImage(::Rpc::UploaderPrx& iceP_uploader, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_uploadImage_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::ContentSubmitter::_iceI_end_uploadImage(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_uploadImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_uploadContent(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_uploadContent_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_uploadContent_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_uploadContent_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_ContentSubmitter_uploadContent_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_uploadContent(::Rpc::UploaderPrx& iceP_uploader, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_uploadContent_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::ContentSubmitter::_iceI_end_uploadContent(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_uploadContent_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_cancel(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_cancel_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_cancel_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_ContentSubmitter_cancel_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Rpc::ContentSubmitter::end_cancel(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Rpc_ContentSubmitter_cancel_name);
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ContentSubmitter::_iceI_begin_finish(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ContentSubmitter_finish_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ContentSubmitter_finish_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ContentSubmitter_finish_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_ContentSubmitter_finish_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ContentSubmitter::end_finish(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ContentSubmitter_finish_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Rpc::ContentSubmitter::_newInstance() const
{
    return new ContentSubmitter;
}
/// \endcond

const ::std::string&
IceProxy::Rpc::ContentSubmitter::ice_staticId()
{
    return ::Rpc::ContentSubmitter::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Rpc::upCast(EngineVersionSubmitter* p) { return p; }

void
::IceProxy::Rpc::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< EngineVersionSubmitter>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new EngineVersionSubmitter;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Rpc::EngineVersionSubmitter::_iceI_begin_setSetup(const ::std::string& iceP_setup, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionSubmitter_setSetup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_EngineVersionSubmitter_setSetup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_EngineVersionSubmitter_setSetup_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_setup);
        result->endWriteParams();
        result->invoke(iceC_Rpc_EngineVersionSubmitter_setSetup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::EngineVersionSubmitter::end_setSetup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_EngineVersionSubmitter_setSetup_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::EngineVersionSubmitter::_iceI_begin_setUnSetup(const ::std::string& iceP_unsetup, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionSubmitter_setUnSetup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_EngineVersionSubmitter_setUnSetup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_EngineVersionSubmitter_setUnSetup_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_unsetup);
        result->endWriteParams();
        result->invoke(iceC_Rpc_EngineVersionSubmitter_setUnSetup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::EngineVersionSubmitter::end_setUnSetup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_EngineVersionSubmitter_setUnSetup_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::EngineVersionSubmitter::_iceI_begin_setInfo(const ::std::string& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionSubmitter_setInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_EngineVersionSubmitter_setInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_EngineVersionSubmitter_setInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_Rpc_EngineVersionSubmitter_setInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::EngineVersionSubmitter::end_setInfo(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_EngineVersionSubmitter_setInfo_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::EngineVersionSubmitter::_iceI_begin_uploadEngine(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionSubmitter_uploadEngine_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_EngineVersionSubmitter_uploadEngine_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_EngineVersionSubmitter_uploadEngine_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_EngineVersionSubmitter_uploadEngine_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::EngineVersionSubmitter::end_uploadEngine(::Rpc::UploaderPrx& iceP_uploader, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_EngineVersionSubmitter_uploadEngine_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::EngineVersionSubmitter::_iceI_end_uploadEngine(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_EngineVersionSubmitter_uploadEngine_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::EngineVersionSubmitter::_iceI_begin_cancel(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_EngineVersionSubmitter_cancel_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_EngineVersionSubmitter_cancel_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_EngineVersionSubmitter_cancel_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Rpc::EngineVersionSubmitter::end_cancel(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Rpc_EngineVersionSubmitter_cancel_name);
}

::Ice::AsyncResultPtr
IceProxy::Rpc::EngineVersionSubmitter::_iceI_begin_finish(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_EngineVersionSubmitter_finish_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_EngineVersionSubmitter_finish_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_EngineVersionSubmitter_finish_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_EngineVersionSubmitter_finish_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::EngineVersionSubmitter::end_finish(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_EngineVersionSubmitter_finish_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Rpc::EngineVersionSubmitter::_newInstance() const
{
    return new EngineVersionSubmitter;
}
/// \endcond

const ::std::string&
IceProxy::Rpc::EngineVersionSubmitter::ice_staticId()
{
    return ::Rpc::EngineVersionSubmitter::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Rpc::upCast(ExtraSubmitter* p) { return p; }

void
::IceProxy::Rpc::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ExtraSubmitter>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ExtraSubmitter;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Rpc::ExtraSubmitter::_iceI_begin_setParentId(const ::std::string& iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_setParentId_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ExtraSubmitter_setParentId_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ExtraSubmitter_setParentId_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ExtraSubmitter_setParentId_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ExtraSubmitter::end_setParentId(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraSubmitter_setParentId_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ExtraSubmitter::_iceI_begin_setTitle(const ::std::string& iceP_title, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_setTitle_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ExtraSubmitter_setTitle_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ExtraSubmitter_setTitle_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_title);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ExtraSubmitter_setTitle_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ExtraSubmitter::end_setTitle(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraSubmitter_setTitle_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ExtraSubmitter::_iceI_begin_setSetup(const ::std::string& iceP_setup, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_setSetup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ExtraSubmitter_setSetup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ExtraSubmitter_setSetup_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_setup);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ExtraSubmitter_setSetup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ExtraSubmitter::end_setSetup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraSubmitter_setSetup_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ExtraSubmitter::_iceI_begin_setCategory(const ::std::string& iceP_category, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_setCategory_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ExtraSubmitter_setCategory_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ExtraSubmitter_setCategory_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_category);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ExtraSubmitter_setCategory_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ExtraSubmitter::end_setCategory(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraSubmitter_setCategory_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ExtraSubmitter::_iceI_begin_setInfo(const ::std::string& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_setInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ExtraSubmitter_setInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ExtraSubmitter_setInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ExtraSubmitter_setInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ExtraSubmitter::end_setInfo(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraSubmitter_setInfo_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ExtraSubmitter::_iceI_begin_uploadImage(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_uploadImage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ExtraSubmitter_uploadImage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ExtraSubmitter_uploadImage_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_ExtraSubmitter_uploadImage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ExtraSubmitter::end_uploadImage(::Rpc::UploaderPrx& iceP_uploader, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraSubmitter_uploadImage_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::ExtraSubmitter::_iceI_end_uploadImage(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraSubmitter_uploadImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ExtraSubmitter::_iceI_begin_uploadExtra(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_uploadExtra_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ExtraSubmitter_uploadExtra_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ExtraSubmitter_uploadExtra_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_ExtraSubmitter_uploadExtra_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ExtraSubmitter::end_uploadExtra(::Rpc::UploaderPrx& iceP_uploader, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraSubmitter_uploadExtra_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::ExtraSubmitter::_iceI_end_uploadExtra(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraSubmitter_uploadExtra_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ExtraSubmitter::_iceI_begin_cancel(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ExtraSubmitter_cancel_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ExtraSubmitter_cancel_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_ExtraSubmitter_cancel_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Rpc::ExtraSubmitter::end_cancel(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Rpc_ExtraSubmitter_cancel_name);
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ExtraSubmitter::_iceI_begin_finish(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ExtraSubmitter_finish_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ExtraSubmitter_finish_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ExtraSubmitter_finish_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_ExtraSubmitter_finish_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ExtraSubmitter::end_finish(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ExtraSubmitter_finish_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Rpc::ExtraSubmitter::_newInstance() const
{
    return new ExtraSubmitter;
}
/// \endcond

const ::std::string&
IceProxy::Rpc::ExtraSubmitter::ice_staticId()
{
    return ::Rpc::ExtraSubmitter::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Rpc::upCast(ClientBrowser* p) { return p; }

void
::IceProxy::Rpc::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ClientBrowser>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ClientBrowser;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Rpc::ClientBrowser::_iceI_begin_next(::Ice::Int iceP_n, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ClientBrowser_next_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ClientBrowser_next_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ClientBrowser_next_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_n);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ClientBrowser_next_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ClientBrowser::end_next(::Rpc::ClientInfoSeq& iceP_items, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ClientBrowser_next_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::ClientBrowser::_iceI_end_next(::Rpc::ClientInfoSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ClientBrowser_next_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Rpc::ClientBrowser::_newInstance() const
{
    return new ClientBrowser;
}
/// \endcond

const ::std::string&
IceProxy::Rpc::ClientBrowser::ice_staticId()
{
    return ::Rpc::ClientBrowser::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Rpc::upCast(ClientSubmitter* p) { return p; }

void
::IceProxy::Rpc::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ClientSubmitter>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ClientSubmitter;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Rpc::ClientSubmitter::_iceI_begin_setInfo(const ::std::string& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ClientSubmitter_setInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ClientSubmitter_setInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ClientSubmitter_setInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_Rpc_ClientSubmitter_setInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ClientSubmitter::end_setInfo(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ClientSubmitter_setInfo_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ClientSubmitter::_iceI_begin_uploadClient(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ClientSubmitter_uploadClient_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ClientSubmitter_uploadClient_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ClientSubmitter_uploadClient_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_ClientSubmitter_uploadClient_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ClientSubmitter::end_uploadClient(::Rpc::UploaderPrx& iceP_uploader, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ClientSubmitter_uploadClient_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::ClientSubmitter::_iceI_end_uploadClient(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ClientSubmitter_uploadClient_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_uploader);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ClientSubmitter::_iceI_begin_cancel(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ClientSubmitter_cancel_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ClientSubmitter_cancel_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_ClientSubmitter_cancel_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Rpc::ClientSubmitter::end_cancel(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Rpc_ClientSubmitter_cancel_name);
}

::Ice::AsyncResultPtr
IceProxy::Rpc::ClientSubmitter::_iceI_begin_finish(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_ClientSubmitter_finish_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_ClientSubmitter_finish_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_ClientSubmitter_finish_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_ClientSubmitter_finish_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::ClientSubmitter::end_finish(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_ClientSubmitter_finish_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Rpc::ClientSubmitter::_newInstance() const
{
    return new ClientSubmitter;
}
/// \endcond

const ::std::string&
IceProxy::Rpc::ClientSubmitter::ice_staticId()
{
    return ::Rpc::ClientSubmitter::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Rpc::upCast(CommentBrowser* p) { return p; }

void
::IceProxy::Rpc::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< CommentBrowser>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new CommentBrowser;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Rpc::CommentBrowser::_iceI_begin_next(::Ice::Int iceP_n, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_CommentBrowser_next_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_CommentBrowser_next_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_CommentBrowser_next_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_n);
        result->endWriteParams();
        result->invoke(iceC_Rpc_CommentBrowser_next_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::CommentBrowser::end_next(::Rpc::CommentSeq& iceP_items, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_CommentBrowser_next_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::CommentBrowser::_iceI_end_next(::Rpc::CommentSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_CommentBrowser_next_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_items);
    istr->read(ret);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Rpc::CommentBrowser::_newInstance() const
{
    return new CommentBrowser;
}
/// \endcond

const ::std::string&
IceProxy::Rpc::CommentBrowser::ice_staticId()
{
    return ::Rpc::CommentBrowser::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::Rpc::upCast(Session* p) { return p; }

void
::IceProxy::Rpc::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< Session>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new Session;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_refresh(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_refresh_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_refresh_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_Session_refresh_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::Rpc::Session::end_refresh(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_Rpc_Session_refresh_name);
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_getCurrentUser(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_getCurrentUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_getCurrentUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_getCurrentUser_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_Session_getCurrentUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_getCurrentUser(::std::string& iceP_user, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getCurrentUser_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_user);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_getCurrentUser(::std::string& iceP_user, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getCurrentUser_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_user);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_getCurrentUserGroup(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_getCurrentUserGroup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_getCurrentUserGroup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_getCurrentUserGroup_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_Session_getCurrentUserGroup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_getCurrentUserGroup(::std::string& iceP_group, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getCurrentUserGroup_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_group);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_getCurrentUserGroup(::std::string& iceP_group, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getCurrentUserGroup_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_group);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_setPages(const ::Rpc::StringSeq& iceP_pages, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_setPages_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_setPages_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_setPages_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_pages);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_setPages_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_setPages(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_setPages_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_getPages(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_getPages_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_getPages_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_getPages_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_Session_getPages_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_getPages(::Rpc::StringSeq& iceP_pages, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getPages_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_pages);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_getPages(::Rpc::StringSeq& iceP_pages, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getPages_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_pages);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_setContentCategories(const ::Rpc::StringSeq& iceP_categories, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_setContentCategories_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_setContentCategories_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_setContentCategories_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_categories);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_setContentCategories_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_setContentCategories(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_setContentCategories_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_getContentCategories(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_getContentCategories_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_getContentCategories_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_getContentCategories_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_Session_getContentCategories_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_getContentCategories(::Rpc::StringSeq& iceP_categories, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getContentCategories_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_categories);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_getContentCategories(::Rpc::StringSeq& iceP_categories, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getContentCategories_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_categories);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_setExtraCategories(const ::Rpc::StringSeq& iceP_categories, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_setExtraCategories_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_setExtraCategories_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_setExtraCategories_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_categories);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_setExtraCategories_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_setExtraCategories(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_setExtraCategories_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_getExtraCategories(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_getExtraCategories_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_getExtraCategories_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_getExtraCategories_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_Session_getExtraCategories_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_getExtraCategories(::Rpc::StringSeq& iceP_categories, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getExtraCategories_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_categories);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_getExtraCategories(::Rpc::StringSeq& iceP_categories, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getExtraCategories_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_categories);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_setUniformInfo(const ::std::string& iceP_key, const ::std::string& iceP_value, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_setUniformInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_setUniformInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_setUniformInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_key);
        ostr->write(iceP_value);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_setUniformInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_setUniformInfo(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_setUniformInfo_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_getUniformInfo(const ::std::string& iceP_key, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_getUniformInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_getUniformInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_getUniformInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_key);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_getUniformInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_getUniformInfo(::std::string& iceP_value, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getUniformInfo_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_value);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_getUniformInfo(::std::string& iceP_value, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getUniformInfo_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_value);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_browseContent(const ::std::string& iceP_page, const ::std::string& iceP_category, const ::std::string& iceP_search, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseContent_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_browseContent_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_browseContent_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_page);
        ostr->write(iceP_category);
        ostr->write(iceP_search);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_browseContent_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_browseContent(::Rpc::ContentBrowserPrx& iceP_browser, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseContent_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_browseContent(::Rpc::ContentBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseContent_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_browseContentByParentId(const ::std::string& iceP_parentId, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseContentByParentId_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_browseContentByParentId_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_browseContentByParentId_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_parentId);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_browseContentByParentId_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_browseContentByParentId(::Rpc::ContentBrowserPrx& iceP_browser, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseContentByParentId_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_browseContentByParentId(::Rpc::ContentBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseContentByParentId_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_getContentInfo(const ::std::string& iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_getContentInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_getContentInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_getContentInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_getContentInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_getContentInfo(::Rpc::ContentInfo& iceP_info, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getContentInfo_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_info);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_getContentInfo(::Rpc::ContentInfo& iceP_info, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getContentInfo_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_info);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_downloadContentImage(const ::std::string& iceP_id, ::Ice::Int iceP_index, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_downloadContentImage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_downloadContentImage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_downloadContentImage_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        ostr->write(iceP_index);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_downloadContentImage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_downloadContentImage(::Rpc::DownloaderPrx& iceP_downloader, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_downloadContentImage_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_downloader);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_downloadContentImage(::Rpc::DownloaderPrx& iceP_downloader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_downloadContentImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_downloader);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_downloadContent(const ::std::string& iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_downloadContent_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_downloadContent_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_downloadContent_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_downloadContent_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_downloadContent(::Rpc::DownloaderPrx& iceP_downloader, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_downloadContent_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_downloader);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_downloadContent(::Rpc::DownloaderPrx& iceP_downloader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_downloadContent_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_downloader);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_submitContent(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_submitContent_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_submitContent_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_submitContent_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_Session_submitContent_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_submitContent(::Rpc::ContentSubmitterPrx& iceP_submitter, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_submitContent_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_submitContent(::Rpc::ContentSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_submitContent_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_copyContent(const ::std::string& iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_copyContent_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_copyContent_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_copyContent_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_copyContent_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_copyContent(::Rpc::ContentSubmitterPrx& iceP_submitter, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_copyContent_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_copyContent(::Rpc::ContentSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_copyContent_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_editContent(const ::std::string& iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_editContent_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_editContent_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_editContent_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_editContent_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_editContent(::Rpc::ContentSubmitterPrx& iceP_submitter, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_editContent_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_editContent(::Rpc::ContentSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_editContent_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_changeContentState(const ::std::string& iceP_id, const ::std::string& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_changeContentState_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_changeContentState_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_changeContentState_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_changeContentState_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_changeContentState(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_changeContentState_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_changeContentDisplayPriority(const ::std::string& iceP_id, ::Ice::Int iceP_displayPriority, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_changeContentDisplayPriority_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_changeContentDisplayPriority_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_changeContentDisplayPriority_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        ostr->write(iceP_displayPriority);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_changeContentDisplayPriority_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_changeContentDisplayPriority(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_changeContentDisplayPriority_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_browseEngineVersions(bool iceP_all, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseEngineVersions_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_browseEngineVersions_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_browseEngineVersions_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_all);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_browseEngineVersions_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_browseEngineVersions(::Rpc::EngineVersionBrowserPrx& iceP_browser, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseEngineVersions_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_browseEngineVersions(::Rpc::EngineVersionBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseEngineVersions_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_downloadEngineVersion(const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_downloadEngineVersion_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_downloadEngineVersion_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_downloadEngineVersion_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_version);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_downloadEngineVersion_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_downloadEngineVersion(::Rpc::DownloaderPrx& iceP_downloader, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_downloadEngineVersion_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_downloader);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_downloadEngineVersion(::Rpc::DownloaderPrx& iceP_downloader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_downloadEngineVersion_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_downloader);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_removeEngineVersion(const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_removeEngineVersion_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_removeEngineVersion_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_removeEngineVersion_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_version);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_removeEngineVersion_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_removeEngineVersion(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_removeEngineVersion_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_submitEngineVersion(const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_submitEngineVersion_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_submitEngineVersion_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_submitEngineVersion_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_version);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_submitEngineVersion_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_submitEngineVersion(::Rpc::EngineVersionSubmitterPrx& iceP_submitter, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_submitEngineVersion_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_submitEngineVersion(::Rpc::EngineVersionSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_submitEngineVersion_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_updateEngineVersion(const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_updateEngineVersion_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_updateEngineVersion_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_updateEngineVersion_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_version);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_updateEngineVersion_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_updateEngineVersion(::Rpc::EngineVersionSubmitterPrx& iceP_submitter, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_updateEngineVersion_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_updateEngineVersion(::Rpc::EngineVersionSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_updateEngineVersion_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_getEngineVersion(const ::std::string& iceP_name, const ::std::string& iceP_version, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_getEngineVersion_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_getEngineVersion_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_getEngineVersion_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_version);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_getEngineVersion_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_getEngineVersion(::Rpc::EngineVersionInfo& iceP_engineVersion, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getEngineVersion_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_engineVersion);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_getEngineVersion(::Rpc::EngineVersionInfo& iceP_engineVersion, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getEngineVersion_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_engineVersion);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_changeEngineVersionDisplayPriority(const ::std::string& iceP_name, const ::std::string& iceP_version, ::Ice::Int iceP_displayPriority, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_changeEngineVersionDisplayPriority_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_changeEngineVersionDisplayPriority_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_changeEngineVersionDisplayPriority_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_version);
        ostr->write(iceP_displayPriority);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_changeEngineVersionDisplayPriority_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_changeEngineVersionDisplayPriority(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_changeEngineVersionDisplayPriority_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_browseExtra(const ::std::string& iceP_category, const ::std::string& iceP_search, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseExtra_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_browseExtra_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_browseExtra_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_category);
        ostr->write(iceP_search);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_browseExtra_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_browseExtra(::Rpc::ExtraBrowserPrx& iceP_browser, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseExtra_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_browseExtra(::Rpc::ExtraBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseExtra_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_browseExtraByParentId(const ::std::string& iceP_parentId, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseExtraByParentId_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_browseExtraByParentId_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_browseExtraByParentId_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_parentId);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_browseExtraByParentId_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_browseExtraByParentId(::Rpc::ExtraBrowserPrx& iceP_browser, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseExtraByParentId_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_browseExtraByParentId(::Rpc::ExtraBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseExtraByParentId_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_getExtraInfo(const ::std::string& iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_getExtraInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_getExtraInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_getExtraInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_getExtraInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_getExtraInfo(::Rpc::ExtraInfo& iceP_info, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getExtraInfo_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_info);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_getExtraInfo(::Rpc::ExtraInfo& iceP_info, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getExtraInfo_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_info);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_downloadExtraImage(const ::std::string& iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_downloadExtraImage_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_downloadExtraImage_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_downloadExtraImage_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_downloadExtraImage_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_downloadExtraImage(::Rpc::DownloaderPrx& iceP_downloader, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_downloadExtraImage_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_downloader);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_downloadExtraImage(::Rpc::DownloaderPrx& iceP_downloader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_downloadExtraImage_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_downloader);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_downloadExtra(const ::std::string& iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_downloadExtra_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_downloadExtra_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_downloadExtra_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_downloadExtra_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_downloadExtra(::Rpc::DownloaderPrx& iceP_downloader, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_downloadExtra_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_downloader);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_downloadExtra(::Rpc::DownloaderPrx& iceP_downloader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_downloadExtra_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_downloader);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_submitExtra(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_submitExtra_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_submitExtra_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_submitExtra_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_Session_submitExtra_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_submitExtra(::Rpc::ExtraSubmitterPrx& iceP_submitter, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_submitExtra_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_submitExtra(::Rpc::ExtraSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_submitExtra_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_updateExtra(const ::std::string& iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_updateExtra_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_updateExtra_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_updateExtra_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_updateExtra_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_updateExtra(::Rpc::ExtraSubmitterPrx& iceP_submitter, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_updateExtra_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_updateExtra(::Rpc::ExtraSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_updateExtra_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_changeExtraState(const ::std::string& iceP_id, const ::std::string& iceP_state, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_changeExtraState_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_changeExtraState_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_changeExtraState_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        ostr->write(iceP_state);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_changeExtraState_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_changeExtraState(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_changeExtraState_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_changeExtraDisplayPriority(const ::std::string& iceP_id, ::Ice::Int iceP_displayPriority, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_changeExtraDisplayPriority_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_changeExtraDisplayPriority_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_changeExtraDisplayPriority_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        ostr->write(iceP_displayPriority);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_changeExtraDisplayPriority_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_changeExtraDisplayPriority(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_changeExtraDisplayPriority_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_browseClient(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseClient_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_browseClient_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_browseClient_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_Session_browseClient_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_browseClient(::Rpc::ClientBrowserPrx& iceP_browser, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseClient_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_browseClient(::Rpc::ClientBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseClient_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_getClientInfo(const ::std::string& iceP_version, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_getClientInfo_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_getClientInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_getClientInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_version);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_getClientInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_getClientInfo(::Rpc::ClientInfo& iceP_info, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getClientInfo_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_info);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_getClientInfo(::Rpc::ClientInfo& iceP_info, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getClientInfo_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_info);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_submitClient(const ::std::string& iceP_version, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_submitClient_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_submitClient_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_submitClient_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_version);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_submitClient_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_submitClient(::Rpc::ClientSubmitterPrx& iceP_submitter, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_submitClient_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_submitClient(::Rpc::ClientSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_submitClient_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_updateClient(const ::std::string& iceP_version, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_updateClient_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_updateClient_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_updateClient_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_version);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_updateClient_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_updateClient(::Rpc::ClientSubmitterPrx& iceP_submitter, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_updateClient_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_updateClient(::Rpc::ClientSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_updateClient_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_submitter);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_removeClient(const ::std::string& iceP_version, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_removeClient_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_removeClient_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_removeClient_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_version);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_removeClient_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_removeClient(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_removeClient_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_browseUsers(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseUsers_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_browseUsers_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_browseUsers_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_Session_browseUsers_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_browseUsers(::Rpc::UserBrowserPrx& iceP_browser, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseUsers_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_browseUsers(::Rpc::UserBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseUsers_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_setUserGroup(const ::std::string& iceP_username, const ::std::string& iceP_group, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_setUserGroup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_setUserGroup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_setUserGroup_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_username);
        ostr->write(iceP_group);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_setUserGroup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_setUserGroup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_setUserGroup_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_removeUser(const ::std::string& iceP_username, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_removeUser_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_removeUser_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_removeUser_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_username);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_removeUser_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_removeUser(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_removeUser_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_browseComment(const ::std::string& iceP_targetId, const ::std::string& iceP_user, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_browseComment_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_browseComment_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_browseComment_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_targetId);
        ostr->write(iceP_user);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_browseComment_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_browseComment(::Rpc::CommentBrowserPrx& iceP_browser, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseComment_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_browseComment(::Rpc::CommentBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_browseComment_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_browser);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_getComment(const ::std::string& iceP_targetId, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_getComment_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_getComment_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_getComment_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_targetId);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_getComment_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_getComment(::std::string& iceP_comment, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getComment_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_comment);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_getComment(::std::string& iceP_comment, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_getComment_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_comment);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_addComment(const ::std::string& iceP_targetId, const ::std::string& iceP_comment, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_addComment_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_addComment_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_addComment_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_targetId);
        ostr->write(iceP_comment);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_addComment_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_addComment(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_addComment_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_editComment(const ::std::string& iceP_id, const ::std::string& iceP_comment, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_editComment_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_editComment_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_editComment_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        ostr->write(iceP_comment);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_editComment_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_editComment(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_editComment_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_removeComment(const ::std::string& iceP_id, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_removeComment_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_removeComment_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_removeComment_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_id);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_removeComment_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_removeComment(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_removeComment_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_queryDownloadCount(const ::std::string& iceP_targetId, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_queryDownloadCount_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_queryDownloadCount_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_queryDownloadCount_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_targetId);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_queryDownloadCount_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_queryDownloadCount(::Ice::Int& iceP_count, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_queryDownloadCount_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_count);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_queryDownloadCount(::Ice::Int& iceP_count, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_queryDownloadCount_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_count);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_isUserOnline(const ::std::string& iceP_userName, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_isUserOnline_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_isUserOnline_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_isUserOnline_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_userName);
        result->endWriteParams();
        result->invoke(iceC_Rpc_Session_isUserOnline_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_isUserOnline(bool& iceP_result, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_isUserOnline_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_result);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_isUserOnline(bool& iceP_result, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_isUserOnline_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_result);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Rpc::Session::_iceI_begin_onlineUserCount(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_Rpc_Session_onlineUserCount_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_Rpc_Session_onlineUserCount_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_Rpc_Session_onlineUserCount_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_Rpc_Session_onlineUserCount_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Rpc::ErrorCode
IceProxy::Rpc::Session::end_onlineUserCount(::Ice::Int& iceP_count, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_onlineUserCount_name);
    ::Rpc::ErrorCode ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_count);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::Rpc::Session::_iceI_end_onlineUserCount(::Ice::Int& iceP_count, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_Rpc_Session_onlineUserCount_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_count);
    istr->read(ret);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::Rpc::Session::_newInstance() const
{
    return new Session;
}
/// \endcond

const ::std::string&
IceProxy::Rpc::Session::ice_staticId()
{
    return ::Rpc::Session::ice_staticId();
}

Rpc::ContentBrowser::~ContentBrowser()
{
}

/// \cond INTERNAL
::Ice::Object* Rpc::upCast(ContentBrowser* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Rpc_ContentBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ContentBrowser",
    "::Rpc::ManagedObject"
};

}

bool
Rpc::ContentBrowser::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ContentBrowser_ids, iceC_Rpc_ContentBrowser_ids + 3, s);
}

::std::vector< ::std::string>
Rpc::ContentBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Rpc_ContentBrowser_ids[0], &iceC_Rpc_ContentBrowser_ids[3]);
}

const ::std::string&
Rpc::ContentBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ContentBrowser::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Rpc::ContentBrowser";
    return typeId;
#else
    return iceC_Rpc_ContentBrowser_ids[1];
#endif
}

/// \cond INTERNAL
bool
Rpc::ContentBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_n;
    istr->read(iceP_n);
    inS.endReadParams();
    ContentItemSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_items);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Rpc_ContentBrowser_all[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};

}

/// \cond INTERNAL
bool
Rpc::ContentBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ContentBrowser_all, iceC_Rpc_ContentBrowser_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ContentBrowser_all)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Rpc::ContentBrowser::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ContentBrowser, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Rpc::ContentBrowser::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ContentBrowser, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Rpc::_icePatchObjectPtr(ContentBrowserPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ContentBrowserPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ContentBrowser::ice_staticId(), v);
    }
}
/// \endcond

Rpc::EngineVersionBrowser::~EngineVersionBrowser()
{
}

/// \cond INTERNAL
::Ice::Object* Rpc::upCast(EngineVersionBrowser* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Rpc_EngineVersionBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::EngineVersionBrowser",
    "::Rpc::ManagedObject"
};

}

bool
Rpc::EngineVersionBrowser::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_EngineVersionBrowser_ids, iceC_Rpc_EngineVersionBrowser_ids + 3, s);
}

::std::vector< ::std::string>
Rpc::EngineVersionBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Rpc_EngineVersionBrowser_ids[0], &iceC_Rpc_EngineVersionBrowser_ids[3]);
}

const ::std::string&
Rpc::EngineVersionBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::EngineVersionBrowser::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Rpc::EngineVersionBrowser";
    return typeId;
#else
    return iceC_Rpc_EngineVersionBrowser_ids[1];
#endif
}

/// \cond INTERNAL
bool
Rpc::EngineVersionBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_n;
    istr->read(iceP_n);
    inS.endReadParams();
    EngineVersionSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_items);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Rpc_EngineVersionBrowser_all[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};

}

/// \cond INTERNAL
bool
Rpc::EngineVersionBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_EngineVersionBrowser_all, iceC_Rpc_EngineVersionBrowser_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_EngineVersionBrowser_all)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Rpc::EngineVersionBrowser::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< EngineVersionBrowser, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Rpc::EngineVersionBrowser::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< EngineVersionBrowser, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Rpc::_icePatchObjectPtr(EngineVersionBrowserPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = EngineVersionBrowserPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(EngineVersionBrowser::ice_staticId(), v);
    }
}
/// \endcond

Rpc::ExtraBrowser::~ExtraBrowser()
{
}

/// \cond INTERNAL
::Ice::Object* Rpc::upCast(ExtraBrowser* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Rpc_ExtraBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ExtraBrowser",
    "::Rpc::ManagedObject"
};

}

bool
Rpc::ExtraBrowser::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ExtraBrowser_ids, iceC_Rpc_ExtraBrowser_ids + 3, s);
}

::std::vector< ::std::string>
Rpc::ExtraBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Rpc_ExtraBrowser_ids[0], &iceC_Rpc_ExtraBrowser_ids[3]);
}

const ::std::string&
Rpc::ExtraBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ExtraBrowser::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Rpc::ExtraBrowser";
    return typeId;
#else
    return iceC_Rpc_ExtraBrowser_ids[1];
#endif
}

/// \cond INTERNAL
bool
Rpc::ExtraBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_n;
    istr->read(iceP_n);
    inS.endReadParams();
    ExtraInfoSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_items);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Rpc_ExtraBrowser_all[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};

}

/// \cond INTERNAL
bool
Rpc::ExtraBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ExtraBrowser_all, iceC_Rpc_ExtraBrowser_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ExtraBrowser_all)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Rpc::ExtraBrowser::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ExtraBrowser, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Rpc::ExtraBrowser::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ExtraBrowser, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Rpc::_icePatchObjectPtr(ExtraBrowserPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ExtraBrowserPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ExtraBrowser::ice_staticId(), v);
    }
}
/// \endcond

Rpc::UserBrowser::~UserBrowser()
{
}

/// \cond INTERNAL
::Ice::Object* Rpc::upCast(UserBrowser* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Rpc_UserBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ManagedObject",
    "::Rpc::UserBrowser"
};

}

bool
Rpc::UserBrowser::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_UserBrowser_ids, iceC_Rpc_UserBrowser_ids + 3, s);
}

::std::vector< ::std::string>
Rpc::UserBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Rpc_UserBrowser_ids[0], &iceC_Rpc_UserBrowser_ids[3]);
}

const ::std::string&
Rpc::UserBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::UserBrowser::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Rpc::UserBrowser";
    return typeId;
#else
    return iceC_Rpc_UserBrowser_ids[2];
#endif
}

/// \cond INTERNAL
bool
Rpc::UserBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_n;
    istr->read(iceP_n);
    inS.endReadParams();
    UserSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_items);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Rpc_UserBrowser_all[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};

}

/// \cond INTERNAL
bool
Rpc::UserBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_UserBrowser_all, iceC_Rpc_UserBrowser_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_UserBrowser_all)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Rpc::UserBrowser::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< UserBrowser, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Rpc::UserBrowser::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< UserBrowser, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Rpc::_icePatchObjectPtr(UserBrowserPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = UserBrowserPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(UserBrowser::ice_staticId(), v);
    }
}
/// \endcond

Rpc::ContentSubmitter::~ContentSubmitter()
{
}

/// \cond INTERNAL
::Ice::Object* Rpc::upCast(ContentSubmitter* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Rpc_ContentSubmitter_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ContentSubmitter",
    "::Rpc::ManagedObject"
};

}

bool
Rpc::ContentSubmitter::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ContentSubmitter_ids, iceC_Rpc_ContentSubmitter_ids + 3, s);
}

::std::vector< ::std::string>
Rpc::ContentSubmitter::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Rpc_ContentSubmitter_ids[0], &iceC_Rpc_ContentSubmitter_ids[3]);
}

const ::std::string&
Rpc::ContentSubmitter::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ContentSubmitter::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Rpc::ContentSubmitter";
    return typeId;
#else
    return iceC_Rpc_ContentSubmitter_ids[1];
#endif
}

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_getId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string iceP_id;
    ErrorCode ret = this->getId(iceP_id, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_id);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setTitle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_title;
    istr->read(iceP_title);
    inS.endReadParams();
    ErrorCode ret = this->setTitle(iceP_title, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setPage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_page;
    istr->read(iceP_page);
    inS.endReadParams();
    ErrorCode ret = this->setPage(iceP_page, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setCategory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_category;
    istr->read(iceP_category);
    inS.endReadParams();
    ErrorCode ret = this->setCategory(iceP_category, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setEngine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->read(iceP_name);
    istr->read(iceP_version);
    inS.endReadParams();
    ErrorCode ret = this->setEngine(iceP_name, iceP_version, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setStartup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_startup;
    istr->read(iceP_startup);
    inS.endReadParams();
    ErrorCode ret = this->setStartup(iceP_startup, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setParentId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ErrorCode ret = this->setParentId(iceP_id, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setVideo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_video;
    istr->read(iceP_video);
    inS.endReadParams();
    ErrorCode ret = this->setVideo(iceP_video, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_setDescription(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_description;
    istr->read(iceP_description);
    inS.endReadParams();
    ErrorCode ret = this->setDescription(iceP_description, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_uploadImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_index;
    istr->read(iceP_index);
    inS.endReadParams();
    UploaderPrx iceP_uploader;
    ErrorCode ret = this->uploadImage(iceP_index, iceP_uploader, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_uploader);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_uploadContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    UploaderPrx iceP_uploader;
    ErrorCode ret = this->uploadContent(iceP_uploader, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_uploader);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_cancel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->cancel(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceD_finish(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ErrorCode ret = this->finish(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Rpc_ContentSubmitter_all[] =
{
    "cancel",
    "destroy",
    "finish",
    "getId",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setCategory",
    "setDescription",
    "setEngine",
    "setPage",
    "setParentId",
    "setStartup",
    "setTitle",
    "setVideo",
    "uploadContent",
    "uploadImage"
};

}

/// \cond INTERNAL
bool
Rpc::ContentSubmitter::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ContentSubmitter_all, iceC_Rpc_ContentSubmitter_all + 18, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ContentSubmitter_all)
    {
        case 0:
        {
            return _iceD_cancel(in, current);
        }
        case 1:
        {
            return _iceD_destroy(in, current);
        }
        case 2:
        {
            return _iceD_finish(in, current);
        }
        case 3:
        {
            return _iceD_getId(in, current);
        }
        case 4:
        {
            return _iceD_ice_id(in, current);
        }
        case 5:
        {
            return _iceD_ice_ids(in, current);
        }
        case 6:
        {
            return _iceD_ice_isA(in, current);
        }
        case 7:
        {
            return _iceD_ice_ping(in, current);
        }
        case 8:
        {
            return _iceD_setCategory(in, current);
        }
        case 9:
        {
            return _iceD_setDescription(in, current);
        }
        case 10:
        {
            return _iceD_setEngine(in, current);
        }
        case 11:
        {
            return _iceD_setPage(in, current);
        }
        case 12:
        {
            return _iceD_setParentId(in, current);
        }
        case 13:
        {
            return _iceD_setStartup(in, current);
        }
        case 14:
        {
            return _iceD_setTitle(in, current);
        }
        case 15:
        {
            return _iceD_setVideo(in, current);
        }
        case 16:
        {
            return _iceD_uploadContent(in, current);
        }
        case 17:
        {
            return _iceD_uploadImage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Rpc::ContentSubmitter::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ContentSubmitter, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Rpc::ContentSubmitter::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ContentSubmitter, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Rpc::_icePatchObjectPtr(ContentSubmitterPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ContentSubmitterPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ContentSubmitter::ice_staticId(), v);
    }
}
/// \endcond

Rpc::EngineVersionSubmitter::~EngineVersionSubmitter()
{
}

/// \cond INTERNAL
::Ice::Object* Rpc::upCast(EngineVersionSubmitter* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Rpc_EngineVersionSubmitter_ids[3] =
{
    "::Ice::Object",
    "::Rpc::EngineVersionSubmitter",
    "::Rpc::ManagedObject"
};

}

bool
Rpc::EngineVersionSubmitter::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_EngineVersionSubmitter_ids, iceC_Rpc_EngineVersionSubmitter_ids + 3, s);
}

::std::vector< ::std::string>
Rpc::EngineVersionSubmitter::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Rpc_EngineVersionSubmitter_ids[0], &iceC_Rpc_EngineVersionSubmitter_ids[3]);
}

const ::std::string&
Rpc::EngineVersionSubmitter::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::EngineVersionSubmitter::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Rpc::EngineVersionSubmitter";
    return typeId;
#else
    return iceC_Rpc_EngineVersionSubmitter_ids[1];
#endif
}

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_setSetup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_setup;
    istr->read(iceP_setup);
    inS.endReadParams();
    ErrorCode ret = this->setSetup(iceP_setup, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_setUnSetup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_unsetup;
    istr->read(iceP_unsetup);
    inS.endReadParams();
    ErrorCode ret = this->setUnSetup(iceP_unsetup, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_setInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_info;
    istr->read(iceP_info);
    inS.endReadParams();
    ErrorCode ret = this->setInfo(iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_uploadEngine(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    UploaderPrx iceP_uploader;
    ErrorCode ret = this->uploadEngine(iceP_uploader, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_uploader);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_cancel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->cancel(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceD_finish(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ErrorCode ret = this->finish(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Rpc_EngineVersionSubmitter_all[] =
{
    "cancel",
    "destroy",
    "finish",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setInfo",
    "setSetup",
    "setUnSetup",
    "uploadEngine"
};

}

/// \cond INTERNAL
bool
Rpc::EngineVersionSubmitter::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_EngineVersionSubmitter_all, iceC_Rpc_EngineVersionSubmitter_all + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_EngineVersionSubmitter_all)
    {
        case 0:
        {
            return _iceD_cancel(in, current);
        }
        case 1:
        {
            return _iceD_destroy(in, current);
        }
        case 2:
        {
            return _iceD_finish(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_setInfo(in, current);
        }
        case 8:
        {
            return _iceD_setSetup(in, current);
        }
        case 9:
        {
            return _iceD_setUnSetup(in, current);
        }
        case 10:
        {
            return _iceD_uploadEngine(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Rpc::EngineVersionSubmitter::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< EngineVersionSubmitter, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Rpc::EngineVersionSubmitter::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< EngineVersionSubmitter, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Rpc::_icePatchObjectPtr(EngineVersionSubmitterPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = EngineVersionSubmitterPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(EngineVersionSubmitter::ice_staticId(), v);
    }
}
/// \endcond

Rpc::ExtraSubmitter::~ExtraSubmitter()
{
}

/// \cond INTERNAL
::Ice::Object* Rpc::upCast(ExtraSubmitter* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Rpc_ExtraSubmitter_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ExtraSubmitter",
    "::Rpc::ManagedObject"
};

}

bool
Rpc::ExtraSubmitter::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ExtraSubmitter_ids, iceC_Rpc_ExtraSubmitter_ids + 3, s);
}

::std::vector< ::std::string>
Rpc::ExtraSubmitter::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Rpc_ExtraSubmitter_ids[0], &iceC_Rpc_ExtraSubmitter_ids[3]);
}

const ::std::string&
Rpc::ExtraSubmitter::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ExtraSubmitter::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Rpc::ExtraSubmitter";
    return typeId;
#else
    return iceC_Rpc_ExtraSubmitter_ids[1];
#endif
}

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_setParentId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ErrorCode ret = this->setParentId(iceP_id, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_setTitle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_title;
    istr->read(iceP_title);
    inS.endReadParams();
    ErrorCode ret = this->setTitle(iceP_title, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_setSetup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_setup;
    istr->read(iceP_setup);
    inS.endReadParams();
    ErrorCode ret = this->setSetup(iceP_setup, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_setCategory(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_category;
    istr->read(iceP_category);
    inS.endReadParams();
    ErrorCode ret = this->setCategory(iceP_category, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_setInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_info;
    istr->read(iceP_info);
    inS.endReadParams();
    ErrorCode ret = this->setInfo(iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_uploadImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    UploaderPrx iceP_uploader;
    ErrorCode ret = this->uploadImage(iceP_uploader, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_uploader);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_uploadExtra(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    UploaderPrx iceP_uploader;
    ErrorCode ret = this->uploadExtra(iceP_uploader, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_uploader);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_cancel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->cancel(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceD_finish(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ErrorCode ret = this->finish(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Rpc_ExtraSubmitter_all[] =
{
    "cancel",
    "destroy",
    "finish",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setCategory",
    "setInfo",
    "setParentId",
    "setSetup",
    "setTitle",
    "uploadExtra",
    "uploadImage"
};

}

/// \cond INTERNAL
bool
Rpc::ExtraSubmitter::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ExtraSubmitter_all, iceC_Rpc_ExtraSubmitter_all + 14, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ExtraSubmitter_all)
    {
        case 0:
        {
            return _iceD_cancel(in, current);
        }
        case 1:
        {
            return _iceD_destroy(in, current);
        }
        case 2:
        {
            return _iceD_finish(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_setCategory(in, current);
        }
        case 8:
        {
            return _iceD_setInfo(in, current);
        }
        case 9:
        {
            return _iceD_setParentId(in, current);
        }
        case 10:
        {
            return _iceD_setSetup(in, current);
        }
        case 11:
        {
            return _iceD_setTitle(in, current);
        }
        case 12:
        {
            return _iceD_uploadExtra(in, current);
        }
        case 13:
        {
            return _iceD_uploadImage(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Rpc::ExtraSubmitter::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ExtraSubmitter, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Rpc::ExtraSubmitter::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ExtraSubmitter, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Rpc::_icePatchObjectPtr(ExtraSubmitterPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ExtraSubmitterPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ExtraSubmitter::ice_staticId(), v);
    }
}
/// \endcond

Rpc::ClientBrowser::~ClientBrowser()
{
}

/// \cond INTERNAL
::Ice::Object* Rpc::upCast(ClientBrowser* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Rpc_ClientBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ClientBrowser",
    "::Rpc::ManagedObject"
};

}

bool
Rpc::ClientBrowser::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ClientBrowser_ids, iceC_Rpc_ClientBrowser_ids + 3, s);
}

::std::vector< ::std::string>
Rpc::ClientBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Rpc_ClientBrowser_ids[0], &iceC_Rpc_ClientBrowser_ids[3]);
}

const ::std::string&
Rpc::ClientBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ClientBrowser::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Rpc::ClientBrowser";
    return typeId;
#else
    return iceC_Rpc_ClientBrowser_ids[1];
#endif
}

/// \cond INTERNAL
bool
Rpc::ClientBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_n;
    istr->read(iceP_n);
    inS.endReadParams();
    ClientInfoSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_items);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Rpc_ClientBrowser_all[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};

}

/// \cond INTERNAL
bool
Rpc::ClientBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ClientBrowser_all, iceC_Rpc_ClientBrowser_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ClientBrowser_all)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Rpc::ClientBrowser::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ClientBrowser, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Rpc::ClientBrowser::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ClientBrowser, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Rpc::_icePatchObjectPtr(ClientBrowserPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ClientBrowserPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ClientBrowser::ice_staticId(), v);
    }
}
/// \endcond

Rpc::ClientSubmitter::~ClientSubmitter()
{
}

/// \cond INTERNAL
::Ice::Object* Rpc::upCast(ClientSubmitter* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Rpc_ClientSubmitter_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ClientSubmitter",
    "::Rpc::ManagedObject"
};

}

bool
Rpc::ClientSubmitter::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_ClientSubmitter_ids, iceC_Rpc_ClientSubmitter_ids + 3, s);
}

::std::vector< ::std::string>
Rpc::ClientSubmitter::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Rpc_ClientSubmitter_ids[0], &iceC_Rpc_ClientSubmitter_ids[3]);
}

const ::std::string&
Rpc::ClientSubmitter::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::ClientSubmitter::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Rpc::ClientSubmitter";
    return typeId;
#else
    return iceC_Rpc_ClientSubmitter_ids[1];
#endif
}

/// \cond INTERNAL
bool
Rpc::ClientSubmitter::_iceD_setInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_info;
    istr->read(iceP_info);
    inS.endReadParams();
    ErrorCode ret = this->setInfo(iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ClientSubmitter::_iceD_uploadClient(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    UploaderPrx iceP_uploader;
    ErrorCode ret = this->uploadClient(iceP_uploader, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_uploader);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ClientSubmitter::_iceD_cancel(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->cancel(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::ClientSubmitter::_iceD_finish(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ErrorCode ret = this->finish(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Rpc_ClientSubmitter_all[] =
{
    "cancel",
    "destroy",
    "finish",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "setInfo",
    "uploadClient"
};

}

/// \cond INTERNAL
bool
Rpc::ClientSubmitter::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_ClientSubmitter_all, iceC_Rpc_ClientSubmitter_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_ClientSubmitter_all)
    {
        case 0:
        {
            return _iceD_cancel(in, current);
        }
        case 1:
        {
            return _iceD_destroy(in, current);
        }
        case 2:
        {
            return _iceD_finish(in, current);
        }
        case 3:
        {
            return _iceD_ice_id(in, current);
        }
        case 4:
        {
            return _iceD_ice_ids(in, current);
        }
        case 5:
        {
            return _iceD_ice_isA(in, current);
        }
        case 6:
        {
            return _iceD_ice_ping(in, current);
        }
        case 7:
        {
            return _iceD_setInfo(in, current);
        }
        case 8:
        {
            return _iceD_uploadClient(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Rpc::ClientSubmitter::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ClientSubmitter, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Rpc::ClientSubmitter::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ClientSubmitter, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Rpc::_icePatchObjectPtr(ClientSubmitterPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ClientSubmitterPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ClientSubmitter::ice_staticId(), v);
    }
}
/// \endcond

Rpc::CommentBrowser::~CommentBrowser()
{
}

/// \cond INTERNAL
::Ice::Object* Rpc::upCast(CommentBrowser* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Rpc_CommentBrowser_ids[3] =
{
    "::Ice::Object",
    "::Rpc::CommentBrowser",
    "::Rpc::ManagedObject"
};

}

bool
Rpc::CommentBrowser::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_CommentBrowser_ids, iceC_Rpc_CommentBrowser_ids + 3, s);
}

::std::vector< ::std::string>
Rpc::CommentBrowser::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Rpc_CommentBrowser_ids[0], &iceC_Rpc_CommentBrowser_ids[3]);
}

const ::std::string&
Rpc::CommentBrowser::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::CommentBrowser::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Rpc::CommentBrowser";
    return typeId;
#else
    return iceC_Rpc_CommentBrowser_ids[1];
#endif
}

/// \cond INTERNAL
bool
Rpc::CommentBrowser::_iceD_next(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_n;
    istr->read(iceP_n);
    inS.endReadParams();
    CommentSeq iceP_items;
    ErrorCode ret = this->next(iceP_n, iceP_items, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_items);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Rpc_CommentBrowser_all[] =
{
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "next"
};

}

/// \cond INTERNAL
bool
Rpc::CommentBrowser::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_CommentBrowser_all, iceC_Rpc_CommentBrowser_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_CommentBrowser_all)
    {
        case 0:
        {
            return _iceD_destroy(in, current);
        }
        case 1:
        {
            return _iceD_ice_id(in, current);
        }
        case 2:
        {
            return _iceD_ice_ids(in, current);
        }
        case 3:
        {
            return _iceD_ice_isA(in, current);
        }
        case 4:
        {
            return _iceD_ice_ping(in, current);
        }
        case 5:
        {
            return _iceD_next(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Rpc::CommentBrowser::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< CommentBrowser, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Rpc::CommentBrowser::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< CommentBrowser, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Rpc::_icePatchObjectPtr(CommentBrowserPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = CommentBrowserPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(CommentBrowser::ice_staticId(), v);
    }
}
/// \endcond

Rpc::Session::~Session()
{
}

/// \cond INTERNAL
::Ice::Object* Rpc::upCast(Session* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_Rpc_Session_ids[3] =
{
    "::Ice::Object",
    "::Rpc::ManagedObject",
    "::Rpc::Session"
};

}

bool
Rpc::Session::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_Rpc_Session_ids, iceC_Rpc_Session_ids + 3, s);
}

::std::vector< ::std::string>
Rpc::Session::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_Rpc_Session_ids[0], &iceC_Rpc_Session_ids[3]);
}

const ::std::string&
Rpc::Session::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
Rpc::Session::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Rpc::Session";
    return typeId;
#else
    return iceC_Rpc_Session_ids[2];
#endif
}

/// \cond INTERNAL
bool
Rpc::Session::_iceD_refresh(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    this->refresh(current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getCurrentUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string iceP_user;
    ErrorCode ret = this->getCurrentUser(iceP_user, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_user);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getCurrentUserGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string iceP_group;
    ErrorCode ret = this->getCurrentUserGroup(iceP_group, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_group);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_setPages(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringSeq iceP_pages;
    istr->read(iceP_pages);
    inS.endReadParams();
    ErrorCode ret = this->setPages(iceP_pages, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getPages(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StringSeq iceP_pages;
    ErrorCode ret = this->getPages(iceP_pages, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_pages);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_setContentCategories(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringSeq iceP_categories;
    istr->read(iceP_categories);
    inS.endReadParams();
    ErrorCode ret = this->setContentCategories(iceP_categories, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getContentCategories(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StringSeq iceP_categories;
    ErrorCode ret = this->getContentCategories(iceP_categories, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_categories);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_setExtraCategories(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    StringSeq iceP_categories;
    istr->read(iceP_categories);
    inS.endReadParams();
    ErrorCode ret = this->setExtraCategories(iceP_categories, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getExtraCategories(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    StringSeq iceP_categories;
    ErrorCode ret = this->getExtraCategories(iceP_categories, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_categories);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_setUniformInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_key;
    ::std::string iceP_value;
    istr->read(iceP_key);
    istr->read(iceP_value);
    inS.endReadParams();
    ErrorCode ret = this->setUniformInfo(iceP_key, iceP_value, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getUniformInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_key;
    istr->read(iceP_key);
    inS.endReadParams();
    ::std::string iceP_value;
    ErrorCode ret = this->getUniformInfo(iceP_key, iceP_value, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_value);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_page;
    ::std::string iceP_category;
    ::std::string iceP_search;
    istr->read(iceP_page);
    istr->read(iceP_category);
    istr->read(iceP_search);
    inS.endReadParams();
    ContentBrowserPrx iceP_browser;
    ErrorCode ret = this->browseContent(iceP_page, iceP_category, iceP_search, iceP_browser, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_browser);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseContentByParentId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_parentId;
    istr->read(iceP_parentId);
    inS.endReadParams();
    ContentBrowserPrx iceP_browser;
    ErrorCode ret = this->browseContentByParentId(iceP_parentId, iceP_browser, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_browser);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getContentInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ContentInfo iceP_info;
    ErrorCode ret = this->getContentInfo(iceP_id, iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_info);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_downloadContentImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    ::Ice::Int iceP_index;
    istr->read(iceP_id);
    istr->read(iceP_index);
    inS.endReadParams();
    DownloaderPrx iceP_downloader;
    ErrorCode ret = this->downloadContentImage(iceP_id, iceP_index, iceP_downloader, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_downloader);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_downloadContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    DownloaderPrx iceP_downloader;
    ErrorCode ret = this->downloadContent(iceP_id, iceP_downloader, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_downloader);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_submitContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ContentSubmitterPrx iceP_submitter;
    ErrorCode ret = this->submitContent(iceP_submitter, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_submitter);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_copyContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ContentSubmitterPrx iceP_submitter;
    ErrorCode ret = this->copyContent(iceP_id, iceP_submitter, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_submitter);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_editContent(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ContentSubmitterPrx iceP_submitter;
    ErrorCode ret = this->editContent(iceP_id, iceP_submitter, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_submitter);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_changeContentState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::string iceP_state;
    istr->read(iceP_id);
    istr->read(iceP_state);
    inS.endReadParams();
    ErrorCode ret = this->changeContentState(iceP_id, iceP_state, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_changeContentDisplayPriority(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    ::Ice::Int iceP_displayPriority;
    istr->read(iceP_id);
    istr->read(iceP_displayPriority);
    inS.endReadParams();
    ErrorCode ret = this->changeContentDisplayPriority(iceP_id, iceP_displayPriority, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseEngineVersions(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    bool iceP_all;
    istr->read(iceP_all);
    inS.endReadParams();
    EngineVersionBrowserPrx iceP_browser;
    ErrorCode ret = this->browseEngineVersions(iceP_all, iceP_browser, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_browser);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_downloadEngineVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->read(iceP_name);
    istr->read(iceP_version);
    inS.endReadParams();
    DownloaderPrx iceP_downloader;
    ErrorCode ret = this->downloadEngineVersion(iceP_name, iceP_version, iceP_downloader, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_downloader);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_removeEngineVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->read(iceP_name);
    istr->read(iceP_version);
    inS.endReadParams();
    ErrorCode ret = this->removeEngineVersion(iceP_name, iceP_version, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_submitEngineVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->read(iceP_name);
    istr->read(iceP_version);
    inS.endReadParams();
    EngineVersionSubmitterPrx iceP_submitter;
    ErrorCode ret = this->submitEngineVersion(iceP_name, iceP_version, iceP_submitter, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_submitter);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_updateEngineVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->read(iceP_name);
    istr->read(iceP_version);
    inS.endReadParams();
    EngineVersionSubmitterPrx iceP_submitter;
    ErrorCode ret = this->updateEngineVersion(iceP_name, iceP_version, iceP_submitter, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_submitter);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getEngineVersion(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    istr->read(iceP_name);
    istr->read(iceP_version);
    inS.endReadParams();
    EngineVersionInfo iceP_engineVersion;
    ErrorCode ret = this->getEngineVersion(iceP_name, iceP_version, iceP_engineVersion, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_engineVersion);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_changeEngineVersionDisplayPriority(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_version;
    ::Ice::Int iceP_displayPriority;
    istr->read(iceP_name);
    istr->read(iceP_version);
    istr->read(iceP_displayPriority);
    inS.endReadParams();
    ErrorCode ret = this->changeEngineVersionDisplayPriority(iceP_name, iceP_version, iceP_displayPriority, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseExtra(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_category;
    ::std::string iceP_search;
    istr->read(iceP_category);
    istr->read(iceP_search);
    inS.endReadParams();
    ExtraBrowserPrx iceP_browser;
    ErrorCode ret = this->browseExtra(iceP_category, iceP_search, iceP_browser, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_browser);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseExtraByParentId(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_parentId;
    istr->read(iceP_parentId);
    inS.endReadParams();
    ExtraBrowserPrx iceP_browser;
    ErrorCode ret = this->browseExtraByParentId(iceP_parentId, iceP_browser, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_browser);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getExtraInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ExtraInfo iceP_info;
    ErrorCode ret = this->getExtraInfo(iceP_id, iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_info);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_downloadExtraImage(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    DownloaderPrx iceP_downloader;
    ErrorCode ret = this->downloadExtraImage(iceP_id, iceP_downloader, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_downloader);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_downloadExtra(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    DownloaderPrx iceP_downloader;
    ErrorCode ret = this->downloadExtra(iceP_id, iceP_downloader, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_downloader);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_submitExtra(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ExtraSubmitterPrx iceP_submitter;
    ErrorCode ret = this->submitExtra(iceP_submitter, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_submitter);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_updateExtra(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ExtraSubmitterPrx iceP_submitter;
    ErrorCode ret = this->updateExtra(iceP_id, iceP_submitter, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_submitter);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_changeExtraState(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::string iceP_state;
    istr->read(iceP_id);
    istr->read(iceP_state);
    inS.endReadParams();
    ErrorCode ret = this->changeExtraState(iceP_id, iceP_state, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_changeExtraDisplayPriority(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    ::Ice::Int iceP_displayPriority;
    istr->read(iceP_id);
    istr->read(iceP_displayPriority);
    inS.endReadParams();
    ErrorCode ret = this->changeExtraDisplayPriority(iceP_id, iceP_displayPriority, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseClient(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ClientBrowserPrx iceP_browser;
    ErrorCode ret = this->browseClient(iceP_browser, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_browser);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getClientInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_version;
    istr->read(iceP_version);
    inS.endReadParams();
    ClientInfo iceP_info;
    ErrorCode ret = this->getClientInfo(iceP_version, iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_info);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_submitClient(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_version;
    istr->read(iceP_version);
    inS.endReadParams();
    ClientSubmitterPrx iceP_submitter;
    ErrorCode ret = this->submitClient(iceP_version, iceP_submitter, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_submitter);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_updateClient(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_version;
    istr->read(iceP_version);
    inS.endReadParams();
    ClientSubmitterPrx iceP_submitter;
    ErrorCode ret = this->updateClient(iceP_version, iceP_submitter, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_submitter);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_removeClient(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_version;
    istr->read(iceP_version);
    inS.endReadParams();
    ErrorCode ret = this->removeClient(iceP_version, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseUsers(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    UserBrowserPrx iceP_browser;
    ErrorCode ret = this->browseUsers(iceP_browser, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_browser);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_setUserGroup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_username;
    ::std::string iceP_group;
    istr->read(iceP_username);
    istr->read(iceP_group);
    inS.endReadParams();
    ErrorCode ret = this->setUserGroup(iceP_username, iceP_group, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_removeUser(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_username;
    istr->read(iceP_username);
    inS.endReadParams();
    ErrorCode ret = this->removeUser(iceP_username, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_browseComment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_targetId;
    ::std::string iceP_user;
    istr->read(iceP_targetId);
    istr->read(iceP_user);
    inS.endReadParams();
    CommentBrowserPrx iceP_browser;
    ErrorCode ret = this->browseComment(iceP_targetId, iceP_user, iceP_browser, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_browser);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_getComment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_targetId;
    istr->read(iceP_targetId);
    inS.endReadParams();
    ::std::string iceP_comment;
    ErrorCode ret = this->getComment(iceP_targetId, iceP_comment, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_comment);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_addComment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_targetId;
    ::std::string iceP_comment;
    istr->read(iceP_targetId);
    istr->read(iceP_comment);
    inS.endReadParams();
    ErrorCode ret = this->addComment(iceP_targetId, iceP_comment, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_editComment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    ::std::string iceP_comment;
    istr->read(iceP_id);
    istr->read(iceP_comment);
    inS.endReadParams();
    ErrorCode ret = this->editComment(iceP_id, iceP_comment, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_removeComment(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_id;
    istr->read(iceP_id);
    inS.endReadParams();
    ErrorCode ret = this->removeComment(iceP_id, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_queryDownloadCount(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_targetId;
    istr->read(iceP_targetId);
    inS.endReadParams();
    ::Ice::Int iceP_count;
    ErrorCode ret = this->queryDownloadCount(iceP_targetId, iceP_count, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_count);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_isUserOnline(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_userName;
    istr->read(iceP_userName);
    inS.endReadParams();
    bool iceP_result;
    ErrorCode ret = this->isUserOnline(iceP_userName, iceP_result, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_result);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
Rpc::Session::_iceD_onlineUserCount(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Int iceP_count;
    ErrorCode ret = this->onlineUserCount(iceP_count, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_count);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_Rpc_Session_all[] =
{
    "addComment",
    "browseClient",
    "browseComment",
    "browseContent",
    "browseContentByParentId",
    "browseEngineVersions",
    "browseExtra",
    "browseExtraByParentId",
    "browseUsers",
    "changeContentDisplayPriority",
    "changeContentState",
    "changeEngineVersionDisplayPriority",
    "changeExtraDisplayPriority",
    "changeExtraState",
    "copyContent",
    "destroy",
    "downloadContent",
    "downloadContentImage",
    "downloadEngineVersion",
    "downloadExtra",
    "downloadExtraImage",
    "editComment",
    "editContent",
    "getClientInfo",
    "getComment",
    "getContentCategories",
    "getContentInfo",
    "getCurrentUser",
    "getCurrentUserGroup",
    "getEngineVersion",
    "getExtraCategories",
    "getExtraInfo",
    "getPages",
    "getUniformInfo",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "isUserOnline",
    "onlineUserCount",
    "queryDownloadCount",
    "refresh",
    "removeClient",
    "removeComment",
    "removeEngineVersion",
    "removeUser",
    "setContentCategories",
    "setExtraCategories",
    "setPages",
    "setUniformInfo",
    "setUserGroup",
    "submitClient",
    "submitContent",
    "submitEngineVersion",
    "submitExtra",
    "updateClient",
    "updateEngineVersion",
    "updateExtra"
};

}

/// \cond INTERNAL
bool
Rpc::Session::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_Rpc_Session_all, iceC_Rpc_Session_all + 58, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_Rpc_Session_all)
    {
        case 0:
        {
            return _iceD_addComment(in, current);
        }
        case 1:
        {
            return _iceD_browseClient(in, current);
        }
        case 2:
        {
            return _iceD_browseComment(in, current);
        }
        case 3:
        {
            return _iceD_browseContent(in, current);
        }
        case 4:
        {
            return _iceD_browseContentByParentId(in, current);
        }
        case 5:
        {
            return _iceD_browseEngineVersions(in, current);
        }
        case 6:
        {
            return _iceD_browseExtra(in, current);
        }
        case 7:
        {
            return _iceD_browseExtraByParentId(in, current);
        }
        case 8:
        {
            return _iceD_browseUsers(in, current);
        }
        case 9:
        {
            return _iceD_changeContentDisplayPriority(in, current);
        }
        case 10:
        {
            return _iceD_changeContentState(in, current);
        }
        case 11:
        {
            return _iceD_changeEngineVersionDisplayPriority(in, current);
        }
        case 12:
        {
            return _iceD_changeExtraDisplayPriority(in, current);
        }
        case 13:
        {
            return _iceD_changeExtraState(in, current);
        }
        case 14:
        {
            return _iceD_copyContent(in, current);
        }
        case 15:
        {
            return _iceD_destroy(in, current);
        }
        case 16:
        {
            return _iceD_downloadContent(in, current);
        }
        case 17:
        {
            return _iceD_downloadContentImage(in, current);
        }
        case 18:
        {
            return _iceD_downloadEngineVersion(in, current);
        }
        case 19:
        {
            return _iceD_downloadExtra(in, current);
        }
        case 20:
        {
            return _iceD_downloadExtraImage(in, current);
        }
        case 21:
        {
            return _iceD_editComment(in, current);
        }
        case 22:
        {
            return _iceD_editContent(in, current);
        }
        case 23:
        {
            return _iceD_getClientInfo(in, current);
        }
        case 24:
        {
            return _iceD_getComment(in, current);
        }
        case 25:
        {
            return _iceD_getContentCategories(in, current);
        }
        case 26:
        {
            return _iceD_getContentInfo(in, current);
        }
        case 27:
        {
            return _iceD_getCurrentUser(in, current);
        }
        case 28:
        {
            return _iceD_getCurrentUserGroup(in, current);
        }
        case 29:
        {
            return _iceD_getEngineVersion(in, current);
        }
        case 30:
        {
            return _iceD_getExtraCategories(in, current);
        }
        case 31:
        {
            return _iceD_getExtraInfo(in, current);
        }
        case 32:
        {
            return _iceD_getPages(in, current);
        }
        case 33:
        {
            return _iceD_getUniformInfo(in, current);
        }
        case 34:
        {
            return _iceD_ice_id(in, current);
        }
        case 35:
        {
            return _iceD_ice_ids(in, current);
        }
        case 36:
        {
            return _iceD_ice_isA(in, current);
        }
        case 37:
        {
            return _iceD_ice_ping(in, current);
        }
        case 38:
        {
            return _iceD_isUserOnline(in, current);
        }
        case 39:
        {
            return _iceD_onlineUserCount(in, current);
        }
        case 40:
        {
            return _iceD_queryDownloadCount(in, current);
        }
        case 41:
        {
            return _iceD_refresh(in, current);
        }
        case 42:
        {
            return _iceD_removeClient(in, current);
        }
        case 43:
        {
            return _iceD_removeComment(in, current);
        }
        case 44:
        {
            return _iceD_removeEngineVersion(in, current);
        }
        case 45:
        {
            return _iceD_removeUser(in, current);
        }
        case 46:
        {
            return _iceD_setContentCategories(in, current);
        }
        case 47:
        {
            return _iceD_setExtraCategories(in, current);
        }
        case 48:
        {
            return _iceD_setPages(in, current);
        }
        case 49:
        {
            return _iceD_setUniformInfo(in, current);
        }
        case 50:
        {
            return _iceD_setUserGroup(in, current);
        }
        case 51:
        {
            return _iceD_submitClient(in, current);
        }
        case 52:
        {
            return _iceD_submitContent(in, current);
        }
        case 53:
        {
            return _iceD_submitEngineVersion(in, current);
        }
        case 54:
        {
            return _iceD_submitExtra(in, current);
        }
        case 55:
        {
            return _iceD_updateClient(in, current);
        }
        case 56:
        {
            return _iceD_updateEngineVersion(in, current);
        }
        case 57:
        {
            return _iceD_updateExtra(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
Rpc::Session::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< Session, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
Rpc::Session::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< Session, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
Rpc::_icePatchObjectPtr(SessionPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = SessionPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(Session::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
