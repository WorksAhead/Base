//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.2
//
// <auto-generated>
//
// Generated from file `RpcSession.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __RpcSession_h__
#define __RpcSession_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <RpcErrorCode.h>
#include <RpcTypedefs.h>
#include <RpcManagedObject.h>
#include <RpcDownloader.h>
#include <RpcUploader.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 2
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Rpc
{

class ContentBrowser;
class ContentBrowserPrx;
class EngineVersionBrowser;
class EngineVersionBrowserPrx;
class ExtraBrowser;
class ExtraBrowserPrx;
class UserBrowser;
class UserBrowserPrx;
class ContentSubmitter;
class ContentSubmitterPrx;
class EngineVersionSubmitter;
class EngineVersionSubmitterPrx;
class ExtraSubmitter;
class ExtraSubmitterPrx;
class ClientBrowser;
class ClientBrowserPrx;
class ClientSubmitter;
class ClientSubmitterPrx;
class CommentBrowser;
class CommentBrowserPrx;
class Session;
class SessionPrx;

}

namespace Rpc
{

struct ContentItem
{
    long long int rowid;
    ::std::string id;
    ::std::string title;
    ::std::string state;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const long long int&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(rowid, id, title, state);
    }
};

struct ContentInfo
{
    long long int rowid;
    ::std::string id;
    ::std::string parentId;
    ::std::string title;
    ::std::string page;
    ::std::string category;
    ::std::string engineName;
    ::std::string engineVersion;
    ::std::string startup;
    int imageCount;
    ::std::string video;
    ::std::string desc;
    ::std::string user;
    ::std::string upTime;
    int displayPriority;
    ::std::string state;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const long long int&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const int&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(rowid, id, parentId, title, page, category, engineName, engineVersion, startup, imageCount, video, desc, user, upTime, displayPriority, state);
    }
};

using ContentItemSeq = ::std::vector<ContentItem>;

struct EngineVersionInfo
{
    ::std::string name;
    ::std::string version;
    ::std::string setup;
    ::std::string unsetup;
    ::std::string uptime;
    ::std::string info;
    int displayPriority;
    ::std::string state;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(name, version, setup, unsetup, uptime, info, displayPriority, state);
    }
};

using EngineVersionSeq = ::std::vector<EngineVersionInfo>;

struct ExtraInfo
{
    ::std::string id;
    ::std::string parentId;
    ::std::string title;
    ::std::string category;
    ::std::string setup;
    ::std::string user;
    ::std::string uptime;
    ::std::string info;
    int displayPriority;
    ::std::string state;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, parentId, title, category, setup, user, uptime, info, displayPriority, state);
    }
};

using ExtraInfoSeq = ::std::vector<ExtraInfo>;

struct User
{
    ::std::string username;
    ::std::string group;
    ::std::string info;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(username, group, info);
    }
};

using UserSeq = ::std::vector<User>;

struct ClientInfo
{
    ::std::string version;
    ::std::string uptime;
    ::std::string info;
    ::std::string state;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(version, uptime, info, state);
    }
};

using ClientInfoSeq = ::std::vector<ClientInfo>;

struct Comment
{
    ::std::string id;
    ::std::string targetId;
    ::std::string user;
    ::std::string time;
    ::std::string comment;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */

    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(id, targetId, user, time, comment);
    }
};

using CommentSeq = ::std::vector<Comment>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace Rpc
{

class ContentBrowser : public virtual ManagedObject
{
public:

    using ProxyType = ContentBrowserPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to next.
     */
    struct NextResult
    {
        ErrorCode returnValue;
        ContentItemSeq items;
    };

    virtual ErrorCode next(int n, ContentItemSeq& items, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class EngineVersionBrowser : public virtual ManagedObject
{
public:

    using ProxyType = EngineVersionBrowserPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to next.
     */
    struct NextResult
    {
        ErrorCode returnValue;
        EngineVersionSeq items;
    };

    virtual ErrorCode next(int n, EngineVersionSeq& items, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class ExtraBrowser : public virtual ManagedObject
{
public:

    using ProxyType = ExtraBrowserPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to next.
     */
    struct NextResult
    {
        ErrorCode returnValue;
        ExtraInfoSeq items;
    };

    virtual ErrorCode next(int n, ExtraInfoSeq& items, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class UserBrowser : public virtual ManagedObject
{
public:

    using ProxyType = UserBrowserPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to next.
     */
    struct NextResult
    {
        ErrorCode returnValue;
        UserSeq items;
    };

    virtual ErrorCode next(int n, UserSeq& items, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class ContentSubmitter : public virtual ManagedObject
{
public:

    using ProxyType = ContentSubmitterPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to getId.
     */
    struct GetIdResult
    {
        ErrorCode returnValue;
        ::std::string id;
    };

    virtual ErrorCode getId(::std::string& id, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setTitle(::std::string title, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setTitle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setPage(::std::string page, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setPage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setCategory(::std::string category, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setCategory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setEngine(::std::string name, ::std::string version, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setEngine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setStartup(::std::string startup, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setStartup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setParentId(::std::string id, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setParentId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setVideo(::std::string video, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setVideo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setDescription(::std::string description, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setDescription(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to uploadImage.
     */
    struct UploadImageResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<UploaderPrx> uploader;
    };

    virtual ErrorCode uploadImage(int index, ::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to uploadContent.
     */
    struct UploadContentResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<UploaderPrx> uploader;
    };

    virtual ErrorCode uploadContent(::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void cancel(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_cancel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode finish(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_finish(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class EngineVersionSubmitter : public virtual ManagedObject
{
public:

    using ProxyType = EngineVersionSubmitterPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode setSetup(::std::string setup, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setSetup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setUnSetup(::std::string unsetup, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setUnSetup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setInfo(::std::string info, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to uploadEngine.
     */
    struct UploadEngineResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<UploaderPrx> uploader;
    };

    virtual ErrorCode uploadEngine(::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadEngine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void cancel(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_cancel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode finish(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_finish(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class ExtraSubmitter : public virtual ManagedObject
{
public:

    using ProxyType = ExtraSubmitterPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode setParentId(::std::string id, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setParentId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setTitle(::std::string title, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setTitle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setSetup(::std::string setup, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setSetup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setCategory(::std::string category, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setCategory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setInfo(::std::string info, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to uploadImage.
     */
    struct UploadImageResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<UploaderPrx> uploader;
    };

    virtual ErrorCode uploadImage(::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to uploadExtra.
     */
    struct UploadExtraResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<UploaderPrx> uploader;
    };

    virtual ErrorCode uploadExtra(::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadExtra(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void cancel(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_cancel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode finish(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_finish(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class ClientBrowser : public virtual ManagedObject
{
public:

    using ProxyType = ClientBrowserPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to next.
     */
    struct NextResult
    {
        ErrorCode returnValue;
        ClientInfoSeq items;
    };

    virtual ErrorCode next(int n, ClientInfoSeq& items, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class ClientSubmitter : public virtual ManagedObject
{
public:

    using ProxyType = ClientSubmitterPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode setInfo(::std::string info, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to uploadClient.
     */
    struct UploadClientResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<UploaderPrx> uploader;
    };

    virtual ErrorCode uploadClient(::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void cancel(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_cancel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode finish(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_finish(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class CommentBrowser : public virtual ManagedObject
{
public:

    using ProxyType = CommentBrowserPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Encapsulates the results of a call to next.
     */
    struct NextResult
    {
        ErrorCode returnValue;
        CommentSeq items;
    };

    virtual ErrorCode next(int n, CommentSeq& items, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Session : public virtual ManagedObject
{
public:

    using ProxyType = SessionPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void refresh(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_refresh(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getCurrentUser.
     */
    struct GetCurrentUserResult
    {
        ErrorCode returnValue;
        ::std::string user;
    };

    virtual ErrorCode getCurrentUser(::std::string& user, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getCurrentUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getCurrentUserGroup.
     */
    struct GetCurrentUserGroupResult
    {
        ErrorCode returnValue;
        ::std::string group;
    };

    virtual ErrorCode getCurrentUserGroup(::std::string& group, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getCurrentUserGroup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setPages(StringSeq pages, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setPages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getPages.
     */
    struct GetPagesResult
    {
        ErrorCode returnValue;
        StringSeq pages;
    };

    virtual ErrorCode getPages(StringSeq& pages, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getPages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setContentCategories(StringSeq categories, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setContentCategories(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getContentCategories.
     */
    struct GetContentCategoriesResult
    {
        ErrorCode returnValue;
        StringSeq categories;
    };

    virtual ErrorCode getContentCategories(StringSeq& categories, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getContentCategories(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setExtraCategories(StringSeq categories, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setExtraCategories(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getExtraCategories.
     */
    struct GetExtraCategoriesResult
    {
        ErrorCode returnValue;
        StringSeq categories;
    };

    virtual ErrorCode getExtraCategories(StringSeq& categories, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getExtraCategories(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setUniformInfo(::std::string key, ::std::string value, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setUniformInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getUniformInfo.
     */
    struct GetUniformInfoResult
    {
        ErrorCode returnValue;
        ::std::string value;
    };

    virtual ErrorCode getUniformInfo(::std::string key, ::std::string& value, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getUniformInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to browseContent.
     */
    struct BrowseContentResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ContentBrowserPrx> browser;
    };

    virtual ErrorCode browseContent(::std::string page, ::std::string category, ::std::string search, ::std::shared_ptr<ContentBrowserPrx>& browser, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_browseContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to browseContentByParentId.
     */
    struct BrowseContentByParentIdResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ContentBrowserPrx> browser;
    };

    virtual ErrorCode browseContentByParentId(::std::string parentId, ::std::shared_ptr<ContentBrowserPrx>& browser, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_browseContentByParentId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getContentInfo.
     */
    struct GetContentInfoResult
    {
        ErrorCode returnValue;
        ContentInfo info;
    };

    virtual ErrorCode getContentInfo(::std::string id, ContentInfo& info, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getContentInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to downloadContentImage.
     */
    struct DownloadContentImageResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<DownloaderPrx> downloader;
    };

    virtual ErrorCode downloadContentImage(::std::string id, int index, ::std::shared_ptr<DownloaderPrx>& downloader, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_downloadContentImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to downloadContent.
     */
    struct DownloadContentResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<DownloaderPrx> downloader;
    };

    virtual ErrorCode downloadContent(::std::string id, ::std::shared_ptr<DownloaderPrx>& downloader, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_downloadContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to submitContent.
     */
    struct SubmitContentResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ContentSubmitterPrx> submitter;
    };

    virtual ErrorCode submitContent(::std::shared_ptr<ContentSubmitterPrx>& submitter, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_submitContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to copyContent.
     */
    struct CopyContentResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ContentSubmitterPrx> submitter;
    };

    virtual ErrorCode copyContent(::std::string id, ::std::shared_ptr<ContentSubmitterPrx>& submitter, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_copyContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to editContent.
     */
    struct EditContentResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ContentSubmitterPrx> submitter;
    };

    virtual ErrorCode editContent(::std::string id, ::std::shared_ptr<ContentSubmitterPrx>& submitter, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_editContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode changeContentState(::std::string id, ::std::string state, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_changeContentState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode changeContentDisplayPriority(::std::string id, int displayPriority, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_changeContentDisplayPriority(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to browseEngineVersions.
     */
    struct BrowseEngineVersionsResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<EngineVersionBrowserPrx> browser;
    };

    virtual ErrorCode browseEngineVersions(bool all, ::std::shared_ptr<EngineVersionBrowserPrx>& browser, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_browseEngineVersions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to downloadEngineVersion.
     */
    struct DownloadEngineVersionResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<DownloaderPrx> downloader;
    };

    virtual ErrorCode downloadEngineVersion(::std::string name, ::std::string version, ::std::shared_ptr<DownloaderPrx>& downloader, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_downloadEngineVersion(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode removeEngineVersion(::std::string name, ::std::string version, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_removeEngineVersion(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to submitEngineVersion.
     */
    struct SubmitEngineVersionResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<EngineVersionSubmitterPrx> submitter;
    };

    virtual ErrorCode submitEngineVersion(::std::string name, ::std::string version, ::std::shared_ptr<EngineVersionSubmitterPrx>& submitter, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_submitEngineVersion(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to updateEngineVersion.
     */
    struct UpdateEngineVersionResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<EngineVersionSubmitterPrx> submitter;
    };

    virtual ErrorCode updateEngineVersion(::std::string name, ::std::string version, ::std::shared_ptr<EngineVersionSubmitterPrx>& submitter, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_updateEngineVersion(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getEngineVersion.
     */
    struct GetEngineVersionResult
    {
        ErrorCode returnValue;
        EngineVersionInfo engineVersion;
    };

    virtual ErrorCode getEngineVersion(::std::string name, ::std::string version, EngineVersionInfo& engineVersion, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getEngineVersion(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode changeEngineVersionDisplayPriority(::std::string name, ::std::string version, int displayPriority, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_changeEngineVersionDisplayPriority(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to browseExtra.
     */
    struct BrowseExtraResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ExtraBrowserPrx> browser;
    };

    virtual ErrorCode browseExtra(::std::string category, ::std::string search, ::std::shared_ptr<ExtraBrowserPrx>& browser, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_browseExtra(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to browseExtraByParentId.
     */
    struct BrowseExtraByParentIdResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ExtraBrowserPrx> browser;
    };

    virtual ErrorCode browseExtraByParentId(::std::string parentId, ::std::shared_ptr<ExtraBrowserPrx>& browser, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_browseExtraByParentId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getExtraInfo.
     */
    struct GetExtraInfoResult
    {
        ErrorCode returnValue;
        ExtraInfo info;
    };

    virtual ErrorCode getExtraInfo(::std::string id, ExtraInfo& info, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getExtraInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to downloadExtraImage.
     */
    struct DownloadExtraImageResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<DownloaderPrx> downloader;
    };

    virtual ErrorCode downloadExtraImage(::std::string id, ::std::shared_ptr<DownloaderPrx>& downloader, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_downloadExtraImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to downloadExtra.
     */
    struct DownloadExtraResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<DownloaderPrx> downloader;
    };

    virtual ErrorCode downloadExtra(::std::string id, ::std::shared_ptr<DownloaderPrx>& downloader, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_downloadExtra(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to submitExtra.
     */
    struct SubmitExtraResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ExtraSubmitterPrx> submitter;
    };

    virtual ErrorCode submitExtra(::std::shared_ptr<ExtraSubmitterPrx>& submitter, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_submitExtra(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to updateExtra.
     */
    struct UpdateExtraResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ExtraSubmitterPrx> submitter;
    };

    virtual ErrorCode updateExtra(::std::string id, ::std::shared_ptr<ExtraSubmitterPrx>& submitter, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_updateExtra(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode changeExtraState(::std::string id, ::std::string state, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_changeExtraState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode changeExtraDisplayPriority(::std::string id, int displayPriority, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_changeExtraDisplayPriority(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to browseClient.
     */
    struct BrowseClientResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ClientBrowserPrx> browser;
    };

    virtual ErrorCode browseClient(::std::shared_ptr<ClientBrowserPrx>& browser, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_browseClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getClientInfo.
     */
    struct GetClientInfoResult
    {
        ErrorCode returnValue;
        ClientInfo info;
    };

    virtual ErrorCode getClientInfo(::std::string version, ClientInfo& info, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getClientInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to submitClient.
     */
    struct SubmitClientResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ClientSubmitterPrx> submitter;
    };

    virtual ErrorCode submitClient(::std::string version, ::std::shared_ptr<ClientSubmitterPrx>& submitter, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_submitClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to updateClient.
     */
    struct UpdateClientResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<ClientSubmitterPrx> submitter;
    };

    virtual ErrorCode updateClient(::std::string version, ::std::shared_ptr<ClientSubmitterPrx>& submitter, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_updateClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode removeClient(::std::string version, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_removeClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to browseUsers.
     */
    struct BrowseUsersResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<UserBrowserPrx> browser;
    };

    virtual ErrorCode browseUsers(::std::shared_ptr<UserBrowserPrx>& browser, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_browseUsers(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setUserGroup(::std::string username, ::std::string group, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setUserGroup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode removeUser(::std::string username, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_removeUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to browseComment.
     */
    struct BrowseCommentResult
    {
        ErrorCode returnValue;
        ::std::shared_ptr<CommentBrowserPrx> browser;
    };

    virtual ErrorCode browseComment(::std::string targetId, ::std::string user, ::std::shared_ptr<CommentBrowserPrx>& browser, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_browseComment(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getComment.
     */
    struct GetCommentResult
    {
        ErrorCode returnValue;
        ::std::string comment;
    };

    virtual ErrorCode getComment(::std::string targetId, ::std::string& comment, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getComment(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode addComment(::std::string targetId, ::std::string comment, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addComment(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode editComment(::std::string id, ::std::string comment, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_editComment(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode removeComment(::std::string id, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_removeComment(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to queryDownloadCount.
     */
    struct QueryDownloadCountResult
    {
        ErrorCode returnValue;
        int count;
    };

    virtual ErrorCode queryDownloadCount(::std::string targetId, int& count, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_queryDownloadCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to isUserOnline.
     */
    struct IsUserOnlineResult
    {
        ErrorCode returnValue;
        bool result;
    };

    virtual ErrorCode isUserOnline(::std::string userName, bool& result, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_isUserOnline(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to onlineUserCount.
     */
    struct OnlineUserCountResult
    {
        ErrorCode returnValue;
        int count;
    };

    virtual ErrorCode onlineUserCount(int& count, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_onlineUserCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace Rpc
{

class ContentBrowserPrx : public virtual ::Ice::Proxy<ContentBrowserPrx, ManagedObjectPrx>
{
public:

    ErrorCode next(int n, ContentItemSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ContentBrowser::NextResult>(true, this, &ContentBrowserPrx::_iceI_next, n, context).get();
        items = ::std::move(_result.items);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto nextAsync(int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ContentBrowser::NextResult>>().get_future())
    {
        return _makePromiseOutgoing<ContentBrowser::NextResult, P>(false, this, &ContentBrowserPrx::_iceI_next, n, context);
    }

    ::std::function<void()>
    nextAsync(int n,
              ::std::function<void(ErrorCode, ContentItemSeq)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ContentBrowser::NextResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.items));
        };
        return _makeLamdaOutgoing<ContentBrowser::NextResult>(_responseCb, ex, sent, this, &Rpc::ContentBrowserPrx::_iceI_next, n, context);
    }

    /// \cond INTERNAL
    void _iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ContentBrowser::NextResult>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ContentBrowserPrx() = default;
    friend ::std::shared_ptr<ContentBrowserPrx> IceInternal::createProxy<ContentBrowserPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class EngineVersionBrowserPrx : public virtual ::Ice::Proxy<EngineVersionBrowserPrx, ManagedObjectPrx>
{
public:

    ErrorCode next(int n, EngineVersionSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<EngineVersionBrowser::NextResult>(true, this, &EngineVersionBrowserPrx::_iceI_next, n, context).get();
        items = ::std::move(_result.items);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto nextAsync(int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<EngineVersionBrowser::NextResult>>().get_future())
    {
        return _makePromiseOutgoing<EngineVersionBrowser::NextResult, P>(false, this, &EngineVersionBrowserPrx::_iceI_next, n, context);
    }

    ::std::function<void()>
    nextAsync(int n,
              ::std::function<void(ErrorCode, EngineVersionSeq)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](EngineVersionBrowser::NextResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.items));
        };
        return _makeLamdaOutgoing<EngineVersionBrowser::NextResult>(_responseCb, ex, sent, this, &Rpc::EngineVersionBrowserPrx::_iceI_next, n, context);
    }

    /// \cond INTERNAL
    void _iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<EngineVersionBrowser::NextResult>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    EngineVersionBrowserPrx() = default;
    friend ::std::shared_ptr<EngineVersionBrowserPrx> IceInternal::createProxy<EngineVersionBrowserPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class ExtraBrowserPrx : public virtual ::Ice::Proxy<ExtraBrowserPrx, ManagedObjectPrx>
{
public:

    ErrorCode next(int n, ExtraInfoSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ExtraBrowser::NextResult>(true, this, &ExtraBrowserPrx::_iceI_next, n, context).get();
        items = ::std::move(_result.items);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto nextAsync(int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ExtraBrowser::NextResult>>().get_future())
    {
        return _makePromiseOutgoing<ExtraBrowser::NextResult, P>(false, this, &ExtraBrowserPrx::_iceI_next, n, context);
    }

    ::std::function<void()>
    nextAsync(int n,
              ::std::function<void(ErrorCode, ExtraInfoSeq)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ExtraBrowser::NextResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.items));
        };
        return _makeLamdaOutgoing<ExtraBrowser::NextResult>(_responseCb, ex, sent, this, &Rpc::ExtraBrowserPrx::_iceI_next, n, context);
    }

    /// \cond INTERNAL
    void _iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ExtraBrowser::NextResult>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ExtraBrowserPrx() = default;
    friend ::std::shared_ptr<ExtraBrowserPrx> IceInternal::createProxy<ExtraBrowserPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class UserBrowserPrx : public virtual ::Ice::Proxy<UserBrowserPrx, ManagedObjectPrx>
{
public:

    ErrorCode next(int n, UserSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<UserBrowser::NextResult>(true, this, &UserBrowserPrx::_iceI_next, n, context).get();
        items = ::std::move(_result.items);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto nextAsync(int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<UserBrowser::NextResult>>().get_future())
    {
        return _makePromiseOutgoing<UserBrowser::NextResult, P>(false, this, &UserBrowserPrx::_iceI_next, n, context);
    }

    ::std::function<void()>
    nextAsync(int n,
              ::std::function<void(ErrorCode, UserSeq)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](UserBrowser::NextResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.items));
        };
        return _makeLamdaOutgoing<UserBrowser::NextResult>(_responseCb, ex, sent, this, &Rpc::UserBrowserPrx::_iceI_next, n, context);
    }

    /// \cond INTERNAL
    void _iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<UserBrowser::NextResult>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    UserBrowserPrx() = default;
    friend ::std::shared_ptr<UserBrowserPrx> IceInternal::createProxy<UserBrowserPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class ContentSubmitterPrx : public virtual ::Ice::Proxy<ContentSubmitterPrx, ManagedObjectPrx>
{
public:

    ErrorCode getId(::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ContentSubmitter::GetIdResult>(true, this, &ContentSubmitterPrx::_iceI_getId, context).get();
        id = ::std::move(_result.id);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getIdAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ContentSubmitter::GetIdResult>>().get_future())
    {
        return _makePromiseOutgoing<ContentSubmitter::GetIdResult, P>(false, this, &ContentSubmitterPrx::_iceI_getId, context);
    }

    ::std::function<void()>
    getIdAsync(::std::function<void(ErrorCode, ::std::string)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ContentSubmitter::GetIdResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.id));
        };
        return _makeLamdaOutgoing<ContentSubmitter::GetIdResult>(_responseCb, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_getId, context);
    }

    /// \cond INTERNAL
    void _iceI_getId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ContentSubmitter::GetIdResult>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setTitle(const ::std::string& title, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ContentSubmitterPrx::_iceI_setTitle, title, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setTitleAsync(const ::std::string& title, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ContentSubmitterPrx::_iceI_setTitle, title, context);
    }

    ::std::function<void()>
    setTitleAsync(const ::std::string& title,
                  ::std::function<void(ErrorCode)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_setTitle, title, context);
    }

    /// \cond INTERNAL
    void _iceI_setTitle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setPage(const ::std::string& page, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ContentSubmitterPrx::_iceI_setPage, page, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setPageAsync(const ::std::string& page, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ContentSubmitterPrx::_iceI_setPage, page, context);
    }

    ::std::function<void()>
    setPageAsync(const ::std::string& page,
                 ::std::function<void(ErrorCode)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_setPage, page, context);
    }

    /// \cond INTERNAL
    void _iceI_setPage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setCategory(const ::std::string& category, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ContentSubmitterPrx::_iceI_setCategory, category, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setCategoryAsync(const ::std::string& category, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ContentSubmitterPrx::_iceI_setCategory, category, context);
    }

    ::std::function<void()>
    setCategoryAsync(const ::std::string& category,
                     ::std::function<void(ErrorCode)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_setCategory, category, context);
    }

    /// \cond INTERNAL
    void _iceI_setCategory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setEngine(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ContentSubmitterPrx::_iceI_setEngine, name, version, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setEngineAsync(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ContentSubmitterPrx::_iceI_setEngine, name, version, context);
    }

    ::std::function<void()>
    setEngineAsync(const ::std::string& name, const ::std::string& version,
                   ::std::function<void(ErrorCode)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_setEngine, name, version, context);
    }

    /// \cond INTERNAL
    void _iceI_setEngine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setStartup(const ::std::string& startup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ContentSubmitterPrx::_iceI_setStartup, startup, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setStartupAsync(const ::std::string& startup, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ContentSubmitterPrx::_iceI_setStartup, startup, context);
    }

    ::std::function<void()>
    setStartupAsync(const ::std::string& startup,
                    ::std::function<void(ErrorCode)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_setStartup, startup, context);
    }

    /// \cond INTERNAL
    void _iceI_setStartup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setParentId(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ContentSubmitterPrx::_iceI_setParentId, id, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setParentIdAsync(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ContentSubmitterPrx::_iceI_setParentId, id, context);
    }

    ::std::function<void()>
    setParentIdAsync(const ::std::string& id,
                     ::std::function<void(ErrorCode)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_setParentId, id, context);
    }

    /// \cond INTERNAL
    void _iceI_setParentId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setVideo(const ::std::string& video, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ContentSubmitterPrx::_iceI_setVideo, video, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setVideoAsync(const ::std::string& video, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ContentSubmitterPrx::_iceI_setVideo, video, context);
    }

    ::std::function<void()>
    setVideoAsync(const ::std::string& video,
                  ::std::function<void(ErrorCode)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_setVideo, video, context);
    }

    /// \cond INTERNAL
    void _iceI_setVideo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setDescription(const ::std::string& description, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ContentSubmitterPrx::_iceI_setDescription, description, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setDescriptionAsync(const ::std::string& description, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ContentSubmitterPrx::_iceI_setDescription, description, context);
    }

    ::std::function<void()>
    setDescriptionAsync(const ::std::string& description,
                        ::std::function<void(ErrorCode)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_setDescription, description, context);
    }

    /// \cond INTERNAL
    void _iceI_setDescription(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode uploadImage(int index, ::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ContentSubmitter::UploadImageResult>(true, this, &ContentSubmitterPrx::_iceI_uploadImage, index, context).get();
        uploader = ::std::move(_result.uploader);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto uploadImageAsync(int index, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ContentSubmitter::UploadImageResult>>().get_future())
    {
        return _makePromiseOutgoing<ContentSubmitter::UploadImageResult, P>(false, this, &ContentSubmitterPrx::_iceI_uploadImage, index, context);
    }

    ::std::function<void()>
    uploadImageAsync(int index,
                     ::std::function<void(ErrorCode, ::std::shared_ptr<UploaderPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ContentSubmitter::UploadImageResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.uploader));
        };
        return _makeLamdaOutgoing<ContentSubmitter::UploadImageResult>(_responseCb, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_uploadImage, index, context);
    }

    /// \cond INTERNAL
    void _iceI_uploadImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ContentSubmitter::UploadImageResult>>&, int, const ::Ice::Context&);
    /// \endcond

    ErrorCode uploadContent(::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ContentSubmitter::UploadContentResult>(true, this, &ContentSubmitterPrx::_iceI_uploadContent, context).get();
        uploader = ::std::move(_result.uploader);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto uploadContentAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ContentSubmitter::UploadContentResult>>().get_future())
    {
        return _makePromiseOutgoing<ContentSubmitter::UploadContentResult, P>(false, this, &ContentSubmitterPrx::_iceI_uploadContent, context);
    }

    ::std::function<void()>
    uploadContentAsync(::std::function<void(ErrorCode, ::std::shared_ptr<UploaderPrx>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ContentSubmitter::UploadContentResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.uploader));
        };
        return _makeLamdaOutgoing<ContentSubmitter::UploadContentResult>(_responseCb, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_uploadContent, context);
    }

    /// \cond INTERNAL
    void _iceI_uploadContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ContentSubmitter::UploadContentResult>>&, const ::Ice::Context&);
    /// \endcond

    void cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ContentSubmitterPrx::_iceI_cancel, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto cancelAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ContentSubmitterPrx::_iceI_cancel, context);
    }

    ::std::function<void()>
    cancelAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_cancel, context);
    }

    /// \cond INTERNAL
    void _iceI_cancel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ContentSubmitterPrx::_iceI_finish, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto finishAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ContentSubmitterPrx::_iceI_finish, context);
    }

    ::std::function<void()>
    finishAsync(::std::function<void(ErrorCode)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ContentSubmitterPrx::_iceI_finish, context);
    }

    /// \cond INTERNAL
    void _iceI_finish(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ContentSubmitterPrx() = default;
    friend ::std::shared_ptr<ContentSubmitterPrx> IceInternal::createProxy<ContentSubmitterPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class EngineVersionSubmitterPrx : public virtual ::Ice::Proxy<EngineVersionSubmitterPrx, ManagedObjectPrx>
{
public:

    ErrorCode setSetup(const ::std::string& setup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &EngineVersionSubmitterPrx::_iceI_setSetup, setup, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setSetupAsync(const ::std::string& setup, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &EngineVersionSubmitterPrx::_iceI_setSetup, setup, context);
    }

    ::std::function<void()>
    setSetupAsync(const ::std::string& setup,
                  ::std::function<void(ErrorCode)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::EngineVersionSubmitterPrx::_iceI_setSetup, setup, context);
    }

    /// \cond INTERNAL
    void _iceI_setSetup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setUnSetup(const ::std::string& unsetup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &EngineVersionSubmitterPrx::_iceI_setUnSetup, unsetup, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setUnSetupAsync(const ::std::string& unsetup, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &EngineVersionSubmitterPrx::_iceI_setUnSetup, unsetup, context);
    }

    ::std::function<void()>
    setUnSetupAsync(const ::std::string& unsetup,
                    ::std::function<void(ErrorCode)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::EngineVersionSubmitterPrx::_iceI_setUnSetup, unsetup, context);
    }

    /// \cond INTERNAL
    void _iceI_setUnSetup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setInfo(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &EngineVersionSubmitterPrx::_iceI_setInfo, info, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setInfoAsync(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &EngineVersionSubmitterPrx::_iceI_setInfo, info, context);
    }

    ::std::function<void()>
    setInfoAsync(const ::std::string& info,
                 ::std::function<void(ErrorCode)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::EngineVersionSubmitterPrx::_iceI_setInfo, info, context);
    }

    /// \cond INTERNAL
    void _iceI_setInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode uploadEngine(::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<EngineVersionSubmitter::UploadEngineResult>(true, this, &EngineVersionSubmitterPrx::_iceI_uploadEngine, context).get();
        uploader = ::std::move(_result.uploader);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto uploadEngineAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<EngineVersionSubmitter::UploadEngineResult>>().get_future())
    {
        return _makePromiseOutgoing<EngineVersionSubmitter::UploadEngineResult, P>(false, this, &EngineVersionSubmitterPrx::_iceI_uploadEngine, context);
    }

    ::std::function<void()>
    uploadEngineAsync(::std::function<void(ErrorCode, ::std::shared_ptr<UploaderPrx>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](EngineVersionSubmitter::UploadEngineResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.uploader));
        };
        return _makeLamdaOutgoing<EngineVersionSubmitter::UploadEngineResult>(_responseCb, ex, sent, this, &Rpc::EngineVersionSubmitterPrx::_iceI_uploadEngine, context);
    }

    /// \cond INTERNAL
    void _iceI_uploadEngine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<EngineVersionSubmitter::UploadEngineResult>>&, const ::Ice::Context&);
    /// \endcond

    void cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &EngineVersionSubmitterPrx::_iceI_cancel, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto cancelAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &EngineVersionSubmitterPrx::_iceI_cancel, context);
    }

    ::std::function<void()>
    cancelAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Rpc::EngineVersionSubmitterPrx::_iceI_cancel, context);
    }

    /// \cond INTERNAL
    void _iceI_cancel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &EngineVersionSubmitterPrx::_iceI_finish, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto finishAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &EngineVersionSubmitterPrx::_iceI_finish, context);
    }

    ::std::function<void()>
    finishAsync(::std::function<void(ErrorCode)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::EngineVersionSubmitterPrx::_iceI_finish, context);
    }

    /// \cond INTERNAL
    void _iceI_finish(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    EngineVersionSubmitterPrx() = default;
    friend ::std::shared_ptr<EngineVersionSubmitterPrx> IceInternal::createProxy<EngineVersionSubmitterPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class ExtraSubmitterPrx : public virtual ::Ice::Proxy<ExtraSubmitterPrx, ManagedObjectPrx>
{
public:

    ErrorCode setParentId(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ExtraSubmitterPrx::_iceI_setParentId, id, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setParentIdAsync(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ExtraSubmitterPrx::_iceI_setParentId, id, context);
    }

    ::std::function<void()>
    setParentIdAsync(const ::std::string& id,
                     ::std::function<void(ErrorCode)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ExtraSubmitterPrx::_iceI_setParentId, id, context);
    }

    /// \cond INTERNAL
    void _iceI_setParentId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setTitle(const ::std::string& title, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ExtraSubmitterPrx::_iceI_setTitle, title, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setTitleAsync(const ::std::string& title, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ExtraSubmitterPrx::_iceI_setTitle, title, context);
    }

    ::std::function<void()>
    setTitleAsync(const ::std::string& title,
                  ::std::function<void(ErrorCode)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ExtraSubmitterPrx::_iceI_setTitle, title, context);
    }

    /// \cond INTERNAL
    void _iceI_setTitle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setSetup(const ::std::string& setup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ExtraSubmitterPrx::_iceI_setSetup, setup, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setSetupAsync(const ::std::string& setup, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ExtraSubmitterPrx::_iceI_setSetup, setup, context);
    }

    ::std::function<void()>
    setSetupAsync(const ::std::string& setup,
                  ::std::function<void(ErrorCode)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ExtraSubmitterPrx::_iceI_setSetup, setup, context);
    }

    /// \cond INTERNAL
    void _iceI_setSetup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setCategory(const ::std::string& category, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ExtraSubmitterPrx::_iceI_setCategory, category, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setCategoryAsync(const ::std::string& category, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ExtraSubmitterPrx::_iceI_setCategory, category, context);
    }

    ::std::function<void()>
    setCategoryAsync(const ::std::string& category,
                     ::std::function<void(ErrorCode)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ExtraSubmitterPrx::_iceI_setCategory, category, context);
    }

    /// \cond INTERNAL
    void _iceI_setCategory(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setInfo(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ExtraSubmitterPrx::_iceI_setInfo, info, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setInfoAsync(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ExtraSubmitterPrx::_iceI_setInfo, info, context);
    }

    ::std::function<void()>
    setInfoAsync(const ::std::string& info,
                 ::std::function<void(ErrorCode)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ExtraSubmitterPrx::_iceI_setInfo, info, context);
    }

    /// \cond INTERNAL
    void _iceI_setInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode uploadImage(::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ExtraSubmitter::UploadImageResult>(true, this, &ExtraSubmitterPrx::_iceI_uploadImage, context).get();
        uploader = ::std::move(_result.uploader);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto uploadImageAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ExtraSubmitter::UploadImageResult>>().get_future())
    {
        return _makePromiseOutgoing<ExtraSubmitter::UploadImageResult, P>(false, this, &ExtraSubmitterPrx::_iceI_uploadImage, context);
    }

    ::std::function<void()>
    uploadImageAsync(::std::function<void(ErrorCode, ::std::shared_ptr<UploaderPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ExtraSubmitter::UploadImageResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.uploader));
        };
        return _makeLamdaOutgoing<ExtraSubmitter::UploadImageResult>(_responseCb, ex, sent, this, &Rpc::ExtraSubmitterPrx::_iceI_uploadImage, context);
    }

    /// \cond INTERNAL
    void _iceI_uploadImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ExtraSubmitter::UploadImageResult>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode uploadExtra(::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ExtraSubmitter::UploadExtraResult>(true, this, &ExtraSubmitterPrx::_iceI_uploadExtra, context).get();
        uploader = ::std::move(_result.uploader);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto uploadExtraAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ExtraSubmitter::UploadExtraResult>>().get_future())
    {
        return _makePromiseOutgoing<ExtraSubmitter::UploadExtraResult, P>(false, this, &ExtraSubmitterPrx::_iceI_uploadExtra, context);
    }

    ::std::function<void()>
    uploadExtraAsync(::std::function<void(ErrorCode, ::std::shared_ptr<UploaderPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ExtraSubmitter::UploadExtraResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.uploader));
        };
        return _makeLamdaOutgoing<ExtraSubmitter::UploadExtraResult>(_responseCb, ex, sent, this, &Rpc::ExtraSubmitterPrx::_iceI_uploadExtra, context);
    }

    /// \cond INTERNAL
    void _iceI_uploadExtra(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ExtraSubmitter::UploadExtraResult>>&, const ::Ice::Context&);
    /// \endcond

    void cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ExtraSubmitterPrx::_iceI_cancel, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto cancelAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ExtraSubmitterPrx::_iceI_cancel, context);
    }

    ::std::function<void()>
    cancelAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Rpc::ExtraSubmitterPrx::_iceI_cancel, context);
    }

    /// \cond INTERNAL
    void _iceI_cancel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ExtraSubmitterPrx::_iceI_finish, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto finishAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ExtraSubmitterPrx::_iceI_finish, context);
    }

    ::std::function<void()>
    finishAsync(::std::function<void(ErrorCode)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ExtraSubmitterPrx::_iceI_finish, context);
    }

    /// \cond INTERNAL
    void _iceI_finish(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ExtraSubmitterPrx() = default;
    friend ::std::shared_ptr<ExtraSubmitterPrx> IceInternal::createProxy<ExtraSubmitterPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class ClientBrowserPrx : public virtual ::Ice::Proxy<ClientBrowserPrx, ManagedObjectPrx>
{
public:

    ErrorCode next(int n, ClientInfoSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ClientBrowser::NextResult>(true, this, &ClientBrowserPrx::_iceI_next, n, context).get();
        items = ::std::move(_result.items);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto nextAsync(int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ClientBrowser::NextResult>>().get_future())
    {
        return _makePromiseOutgoing<ClientBrowser::NextResult, P>(false, this, &ClientBrowserPrx::_iceI_next, n, context);
    }

    ::std::function<void()>
    nextAsync(int n,
              ::std::function<void(ErrorCode, ClientInfoSeq)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ClientBrowser::NextResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.items));
        };
        return _makeLamdaOutgoing<ClientBrowser::NextResult>(_responseCb, ex, sent, this, &Rpc::ClientBrowserPrx::_iceI_next, n, context);
    }

    /// \cond INTERNAL
    void _iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ClientBrowser::NextResult>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ClientBrowserPrx() = default;
    friend ::std::shared_ptr<ClientBrowserPrx> IceInternal::createProxy<ClientBrowserPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class ClientSubmitterPrx : public virtual ::Ice::Proxy<ClientSubmitterPrx, ManagedObjectPrx>
{
public:

    ErrorCode setInfo(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ClientSubmitterPrx::_iceI_setInfo, info, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setInfoAsync(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ClientSubmitterPrx::_iceI_setInfo, info, context);
    }

    ::std::function<void()>
    setInfoAsync(const ::std::string& info,
                 ::std::function<void(ErrorCode)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ClientSubmitterPrx::_iceI_setInfo, info, context);
    }

    /// \cond INTERNAL
    void _iceI_setInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode uploadClient(::std::shared_ptr<UploaderPrx>& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ClientSubmitter::UploadClientResult>(true, this, &ClientSubmitterPrx::_iceI_uploadClient, context).get();
        uploader = ::std::move(_result.uploader);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto uploadClientAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ClientSubmitter::UploadClientResult>>().get_future())
    {
        return _makePromiseOutgoing<ClientSubmitter::UploadClientResult, P>(false, this, &ClientSubmitterPrx::_iceI_uploadClient, context);
    }

    ::std::function<void()>
    uploadClientAsync(::std::function<void(ErrorCode, ::std::shared_ptr<UploaderPrx>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ClientSubmitter::UploadClientResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.uploader));
        };
        return _makeLamdaOutgoing<ClientSubmitter::UploadClientResult>(_responseCb, ex, sent, this, &Rpc::ClientSubmitterPrx::_iceI_uploadClient, context);
    }

    /// \cond INTERNAL
    void _iceI_uploadClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ClientSubmitter::UploadClientResult>>&, const ::Ice::Context&);
    /// \endcond

    void cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ClientSubmitterPrx::_iceI_cancel, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto cancelAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ClientSubmitterPrx::_iceI_cancel, context);
    }

    ::std::function<void()>
    cancelAsync(::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Rpc::ClientSubmitterPrx::_iceI_cancel, context);
    }

    /// \cond INTERNAL
    void _iceI_cancel(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &ClientSubmitterPrx::_iceI_finish, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto finishAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &ClientSubmitterPrx::_iceI_finish, context);
    }

    ::std::function<void()>
    finishAsync(::std::function<void(ErrorCode)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::ClientSubmitterPrx::_iceI_finish, context);
    }

    /// \cond INTERNAL
    void _iceI_finish(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ClientSubmitterPrx() = default;
    friend ::std::shared_ptr<ClientSubmitterPrx> IceInternal::createProxy<ClientSubmitterPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class CommentBrowserPrx : public virtual ::Ice::Proxy<CommentBrowserPrx, ManagedObjectPrx>
{
public:

    ErrorCode next(int n, CommentSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<CommentBrowser::NextResult>(true, this, &CommentBrowserPrx::_iceI_next, n, context).get();
        items = ::std::move(_result.items);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto nextAsync(int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<CommentBrowser::NextResult>>().get_future())
    {
        return _makePromiseOutgoing<CommentBrowser::NextResult, P>(false, this, &CommentBrowserPrx::_iceI_next, n, context);
    }

    ::std::function<void()>
    nextAsync(int n,
              ::std::function<void(ErrorCode, CommentSeq)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](CommentBrowser::NextResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.items));
        };
        return _makeLamdaOutgoing<CommentBrowser::NextResult>(_responseCb, ex, sent, this, &Rpc::CommentBrowserPrx::_iceI_next, n, context);
    }

    /// \cond INTERNAL
    void _iceI_next(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<CommentBrowser::NextResult>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    CommentBrowserPrx() = default;
    friend ::std::shared_ptr<CommentBrowserPrx> IceInternal::createProxy<CommentBrowserPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class SessionPrx : public virtual ::Ice::Proxy<SessionPrx, ManagedObjectPrx>
{
public:

    void refresh(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SessionPrx::_iceI_refresh, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto refreshAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SessionPrx::_iceI_refresh, context);
    }

    ::std::function<void()>
    refreshAsync(::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_refresh, context);
    }

    /// \cond INTERNAL
    void _iceI_refresh(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode getCurrentUser(::std::string& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::GetCurrentUserResult>(true, this, &SessionPrx::_iceI_getCurrentUser, context).get();
        user = ::std::move(_result.user);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getCurrentUserAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::GetCurrentUserResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::GetCurrentUserResult, P>(false, this, &SessionPrx::_iceI_getCurrentUser, context);
    }

    ::std::function<void()>
    getCurrentUserAsync(::std::function<void(ErrorCode, ::std::string)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::GetCurrentUserResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.user));
        };
        return _makeLamdaOutgoing<Session::GetCurrentUserResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_getCurrentUser, context);
    }

    /// \cond INTERNAL
    void _iceI_getCurrentUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetCurrentUserResult>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode getCurrentUserGroup(::std::string& group, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::GetCurrentUserGroupResult>(true, this, &SessionPrx::_iceI_getCurrentUserGroup, context).get();
        group = ::std::move(_result.group);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getCurrentUserGroupAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::GetCurrentUserGroupResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::GetCurrentUserGroupResult, P>(false, this, &SessionPrx::_iceI_getCurrentUserGroup, context);
    }

    ::std::function<void()>
    getCurrentUserGroupAsync(::std::function<void(ErrorCode, ::std::string)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::GetCurrentUserGroupResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.group));
        };
        return _makeLamdaOutgoing<Session::GetCurrentUserGroupResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_getCurrentUserGroup, context);
    }

    /// \cond INTERNAL
    void _iceI_getCurrentUserGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetCurrentUserGroupResult>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setPages(const StringSeq& pages, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_setPages, pages, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setPagesAsync(const StringSeq& pages, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_setPages, pages, context);
    }

    ::std::function<void()>
    setPagesAsync(const StringSeq& pages,
                  ::std::function<void(ErrorCode)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_setPages, pages, context);
    }

    /// \cond INTERNAL
    void _iceI_setPages(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const StringSeq&, const ::Ice::Context&);
    /// \endcond

    ErrorCode getPages(StringSeq& pages, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::GetPagesResult>(true, this, &SessionPrx::_iceI_getPages, context).get();
        pages = ::std::move(_result.pages);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getPagesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::GetPagesResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::GetPagesResult, P>(false, this, &SessionPrx::_iceI_getPages, context);
    }

    ::std::function<void()>
    getPagesAsync(::std::function<void(ErrorCode, StringSeq)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::GetPagesResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.pages));
        };
        return _makeLamdaOutgoing<Session::GetPagesResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_getPages, context);
    }

    /// \cond INTERNAL
    void _iceI_getPages(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetPagesResult>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setContentCategories(const StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_setContentCategories, categories, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setContentCategoriesAsync(const StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_setContentCategories, categories, context);
    }

    ::std::function<void()>
    setContentCategoriesAsync(const StringSeq& categories,
                              ::std::function<void(ErrorCode)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_setContentCategories, categories, context);
    }

    /// \cond INTERNAL
    void _iceI_setContentCategories(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const StringSeq&, const ::Ice::Context&);
    /// \endcond

    ErrorCode getContentCategories(StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::GetContentCategoriesResult>(true, this, &SessionPrx::_iceI_getContentCategories, context).get();
        categories = ::std::move(_result.categories);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getContentCategoriesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::GetContentCategoriesResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::GetContentCategoriesResult, P>(false, this, &SessionPrx::_iceI_getContentCategories, context);
    }

    ::std::function<void()>
    getContentCategoriesAsync(::std::function<void(ErrorCode, StringSeq)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::GetContentCategoriesResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.categories));
        };
        return _makeLamdaOutgoing<Session::GetContentCategoriesResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_getContentCategories, context);
    }

    /// \cond INTERNAL
    void _iceI_getContentCategories(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetContentCategoriesResult>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setExtraCategories(const StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_setExtraCategories, categories, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setExtraCategoriesAsync(const StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_setExtraCategories, categories, context);
    }

    ::std::function<void()>
    setExtraCategoriesAsync(const StringSeq& categories,
                            ::std::function<void(ErrorCode)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_setExtraCategories, categories, context);
    }

    /// \cond INTERNAL
    void _iceI_setExtraCategories(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const StringSeq&, const ::Ice::Context&);
    /// \endcond

    ErrorCode getExtraCategories(StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::GetExtraCategoriesResult>(true, this, &SessionPrx::_iceI_getExtraCategories, context).get();
        categories = ::std::move(_result.categories);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getExtraCategoriesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::GetExtraCategoriesResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::GetExtraCategoriesResult, P>(false, this, &SessionPrx::_iceI_getExtraCategories, context);
    }

    ::std::function<void()>
    getExtraCategoriesAsync(::std::function<void(ErrorCode, StringSeq)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::GetExtraCategoriesResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.categories));
        };
        return _makeLamdaOutgoing<Session::GetExtraCategoriesResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_getExtraCategories, context);
    }

    /// \cond INTERNAL
    void _iceI_getExtraCategories(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetExtraCategoriesResult>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setUniformInfo(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_setUniformInfo, key, value, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setUniformInfoAsync(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_setUniformInfo, key, value, context);
    }

    ::std::function<void()>
    setUniformInfoAsync(const ::std::string& key, const ::std::string& value,
                        ::std::function<void(ErrorCode)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_setUniformInfo, key, value, context);
    }

    /// \cond INTERNAL
    void _iceI_setUniformInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode getUniformInfo(const ::std::string& key, ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::GetUniformInfoResult>(true, this, &SessionPrx::_iceI_getUniformInfo, key, context).get();
        value = ::std::move(_result.value);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getUniformInfoAsync(const ::std::string& key, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::GetUniformInfoResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::GetUniformInfoResult, P>(false, this, &SessionPrx::_iceI_getUniformInfo, key, context);
    }

    ::std::function<void()>
    getUniformInfoAsync(const ::std::string& key,
                        ::std::function<void(ErrorCode, ::std::string)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::GetUniformInfoResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.value));
        };
        return _makeLamdaOutgoing<Session::GetUniformInfoResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_getUniformInfo, key, context);
    }

    /// \cond INTERNAL
    void _iceI_getUniformInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetUniformInfoResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode browseContent(const ::std::string& page, const ::std::string& category, const ::std::string& search, ::std::shared_ptr<ContentBrowserPrx>& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::BrowseContentResult>(true, this, &SessionPrx::_iceI_browseContent, page, category, search, context).get();
        browser = ::std::move(_result.browser);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto browseContentAsync(const ::std::string& page, const ::std::string& category, const ::std::string& search, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::BrowseContentResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::BrowseContentResult, P>(false, this, &SessionPrx::_iceI_browseContent, page, category, search, context);
    }

    ::std::function<void()>
    browseContentAsync(const ::std::string& page, const ::std::string& category, const ::std::string& search,
                       ::std::function<void(ErrorCode, ::std::shared_ptr<ContentBrowserPrx>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::BrowseContentResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.browser));
        };
        return _makeLamdaOutgoing<Session::BrowseContentResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_browseContent, page, category, search, context);
    }

    /// \cond INTERNAL
    void _iceI_browseContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseContentResult>>&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode browseContentByParentId(const ::std::string& parentId, ::std::shared_ptr<ContentBrowserPrx>& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::BrowseContentByParentIdResult>(true, this, &SessionPrx::_iceI_browseContentByParentId, parentId, context).get();
        browser = ::std::move(_result.browser);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto browseContentByParentIdAsync(const ::std::string& parentId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::BrowseContentByParentIdResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::BrowseContentByParentIdResult, P>(false, this, &SessionPrx::_iceI_browseContentByParentId, parentId, context);
    }

    ::std::function<void()>
    browseContentByParentIdAsync(const ::std::string& parentId,
                                 ::std::function<void(ErrorCode, ::std::shared_ptr<ContentBrowserPrx>)> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::BrowseContentByParentIdResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.browser));
        };
        return _makeLamdaOutgoing<Session::BrowseContentByParentIdResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_browseContentByParentId, parentId, context);
    }

    /// \cond INTERNAL
    void _iceI_browseContentByParentId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseContentByParentIdResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode getContentInfo(const ::std::string& id, ContentInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::GetContentInfoResult>(true, this, &SessionPrx::_iceI_getContentInfo, id, context).get();
        info = ::std::move(_result.info);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getContentInfoAsync(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::GetContentInfoResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::GetContentInfoResult, P>(false, this, &SessionPrx::_iceI_getContentInfo, id, context);
    }

    ::std::function<void()>
    getContentInfoAsync(const ::std::string& id,
                        ::std::function<void(ErrorCode, ContentInfo)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::GetContentInfoResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.info));
        };
        return _makeLamdaOutgoing<Session::GetContentInfoResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_getContentInfo, id, context);
    }

    /// \cond INTERNAL
    void _iceI_getContentInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetContentInfoResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode downloadContentImage(const ::std::string& id, int index, ::std::shared_ptr<DownloaderPrx>& downloader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::DownloadContentImageResult>(true, this, &SessionPrx::_iceI_downloadContentImage, id, index, context).get();
        downloader = ::std::move(_result.downloader);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto downloadContentImageAsync(const ::std::string& id, int index, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::DownloadContentImageResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::DownloadContentImageResult, P>(false, this, &SessionPrx::_iceI_downloadContentImage, id, index, context);
    }

    ::std::function<void()>
    downloadContentImageAsync(const ::std::string& id, int index,
                              ::std::function<void(ErrorCode, ::std::shared_ptr<DownloaderPrx>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::DownloadContentImageResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.downloader));
        };
        return _makeLamdaOutgoing<Session::DownloadContentImageResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_downloadContentImage, id, index, context);
    }

    /// \cond INTERNAL
    void _iceI_downloadContentImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::DownloadContentImageResult>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    ErrorCode downloadContent(const ::std::string& id, ::std::shared_ptr<DownloaderPrx>& downloader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::DownloadContentResult>(true, this, &SessionPrx::_iceI_downloadContent, id, context).get();
        downloader = ::std::move(_result.downloader);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto downloadContentAsync(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::DownloadContentResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::DownloadContentResult, P>(false, this, &SessionPrx::_iceI_downloadContent, id, context);
    }

    ::std::function<void()>
    downloadContentAsync(const ::std::string& id,
                         ::std::function<void(ErrorCode, ::std::shared_ptr<DownloaderPrx>)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::DownloadContentResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.downloader));
        };
        return _makeLamdaOutgoing<Session::DownloadContentResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_downloadContent, id, context);
    }

    /// \cond INTERNAL
    void _iceI_downloadContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::DownloadContentResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode submitContent(::std::shared_ptr<ContentSubmitterPrx>& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::SubmitContentResult>(true, this, &SessionPrx::_iceI_submitContent, context).get();
        submitter = ::std::move(_result.submitter);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto submitContentAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::SubmitContentResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::SubmitContentResult, P>(false, this, &SessionPrx::_iceI_submitContent, context);
    }

    ::std::function<void()>
    submitContentAsync(::std::function<void(ErrorCode, ::std::shared_ptr<ContentSubmitterPrx>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::SubmitContentResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.submitter));
        };
        return _makeLamdaOutgoing<Session::SubmitContentResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_submitContent, context);
    }

    /// \cond INTERNAL
    void _iceI_submitContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::SubmitContentResult>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode copyContent(const ::std::string& id, ::std::shared_ptr<ContentSubmitterPrx>& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::CopyContentResult>(true, this, &SessionPrx::_iceI_copyContent, id, context).get();
        submitter = ::std::move(_result.submitter);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto copyContentAsync(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::CopyContentResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::CopyContentResult, P>(false, this, &SessionPrx::_iceI_copyContent, id, context);
    }

    ::std::function<void()>
    copyContentAsync(const ::std::string& id,
                     ::std::function<void(ErrorCode, ::std::shared_ptr<ContentSubmitterPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::CopyContentResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.submitter));
        };
        return _makeLamdaOutgoing<Session::CopyContentResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_copyContent, id, context);
    }

    /// \cond INTERNAL
    void _iceI_copyContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::CopyContentResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode editContent(const ::std::string& id, ::std::shared_ptr<ContentSubmitterPrx>& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::EditContentResult>(true, this, &SessionPrx::_iceI_editContent, id, context).get();
        submitter = ::std::move(_result.submitter);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto editContentAsync(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::EditContentResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::EditContentResult, P>(false, this, &SessionPrx::_iceI_editContent, id, context);
    }

    ::std::function<void()>
    editContentAsync(const ::std::string& id,
                     ::std::function<void(ErrorCode, ::std::shared_ptr<ContentSubmitterPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::EditContentResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.submitter));
        };
        return _makeLamdaOutgoing<Session::EditContentResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_editContent, id, context);
    }

    /// \cond INTERNAL
    void _iceI_editContent(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::EditContentResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode changeContentState(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_changeContentState, id, state, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto changeContentStateAsync(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_changeContentState, id, state, context);
    }

    ::std::function<void()>
    changeContentStateAsync(const ::std::string& id, const ::std::string& state,
                            ::std::function<void(ErrorCode)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_changeContentState, id, state, context);
    }

    /// \cond INTERNAL
    void _iceI_changeContentState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode changeContentDisplayPriority(const ::std::string& id, int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_changeContentDisplayPriority, id, displayPriority, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto changeContentDisplayPriorityAsync(const ::std::string& id, int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_changeContentDisplayPriority, id, displayPriority, context);
    }

    ::std::function<void()>
    changeContentDisplayPriorityAsync(const ::std::string& id, int displayPriority,
                                      ::std::function<void(ErrorCode)> response,
                                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                      ::std::function<void(bool)> sent = nullptr,
                                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_changeContentDisplayPriority, id, displayPriority, context);
    }

    /// \cond INTERNAL
    void _iceI_changeContentDisplayPriority(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    ErrorCode browseEngineVersions(bool all, ::std::shared_ptr<EngineVersionBrowserPrx>& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::BrowseEngineVersionsResult>(true, this, &SessionPrx::_iceI_browseEngineVersions, all, context).get();
        browser = ::std::move(_result.browser);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto browseEngineVersionsAsync(bool all, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::BrowseEngineVersionsResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::BrowseEngineVersionsResult, P>(false, this, &SessionPrx::_iceI_browseEngineVersions, all, context);
    }

    ::std::function<void()>
    browseEngineVersionsAsync(bool all,
                              ::std::function<void(ErrorCode, ::std::shared_ptr<EngineVersionBrowserPrx>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::BrowseEngineVersionsResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.browser));
        };
        return _makeLamdaOutgoing<Session::BrowseEngineVersionsResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_browseEngineVersions, all, context);
    }

    /// \cond INTERNAL
    void _iceI_browseEngineVersions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseEngineVersionsResult>>&, bool, const ::Ice::Context&);
    /// \endcond

    ErrorCode downloadEngineVersion(const ::std::string& name, const ::std::string& version, ::std::shared_ptr<DownloaderPrx>& downloader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::DownloadEngineVersionResult>(true, this, &SessionPrx::_iceI_downloadEngineVersion, name, version, context).get();
        downloader = ::std::move(_result.downloader);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto downloadEngineVersionAsync(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::DownloadEngineVersionResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::DownloadEngineVersionResult, P>(false, this, &SessionPrx::_iceI_downloadEngineVersion, name, version, context);
    }

    ::std::function<void()>
    downloadEngineVersionAsync(const ::std::string& name, const ::std::string& version,
                               ::std::function<void(ErrorCode, ::std::shared_ptr<DownloaderPrx>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::DownloadEngineVersionResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.downloader));
        };
        return _makeLamdaOutgoing<Session::DownloadEngineVersionResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_downloadEngineVersion, name, version, context);
    }

    /// \cond INTERNAL
    void _iceI_downloadEngineVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::DownloadEngineVersionResult>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode removeEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_removeEngineVersion, name, version, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto removeEngineVersionAsync(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_removeEngineVersion, name, version, context);
    }

    ::std::function<void()>
    removeEngineVersionAsync(const ::std::string& name, const ::std::string& version,
                             ::std::function<void(ErrorCode)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_removeEngineVersion, name, version, context);
    }

    /// \cond INTERNAL
    void _iceI_removeEngineVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode submitEngineVersion(const ::std::string& name, const ::std::string& version, ::std::shared_ptr<EngineVersionSubmitterPrx>& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::SubmitEngineVersionResult>(true, this, &SessionPrx::_iceI_submitEngineVersion, name, version, context).get();
        submitter = ::std::move(_result.submitter);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto submitEngineVersionAsync(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::SubmitEngineVersionResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::SubmitEngineVersionResult, P>(false, this, &SessionPrx::_iceI_submitEngineVersion, name, version, context);
    }

    ::std::function<void()>
    submitEngineVersionAsync(const ::std::string& name, const ::std::string& version,
                             ::std::function<void(ErrorCode, ::std::shared_ptr<EngineVersionSubmitterPrx>)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::SubmitEngineVersionResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.submitter));
        };
        return _makeLamdaOutgoing<Session::SubmitEngineVersionResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_submitEngineVersion, name, version, context);
    }

    /// \cond INTERNAL
    void _iceI_submitEngineVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::SubmitEngineVersionResult>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode updateEngineVersion(const ::std::string& name, const ::std::string& version, ::std::shared_ptr<EngineVersionSubmitterPrx>& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::UpdateEngineVersionResult>(true, this, &SessionPrx::_iceI_updateEngineVersion, name, version, context).get();
        submitter = ::std::move(_result.submitter);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto updateEngineVersionAsync(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::UpdateEngineVersionResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::UpdateEngineVersionResult, P>(false, this, &SessionPrx::_iceI_updateEngineVersion, name, version, context);
    }

    ::std::function<void()>
    updateEngineVersionAsync(const ::std::string& name, const ::std::string& version,
                             ::std::function<void(ErrorCode, ::std::shared_ptr<EngineVersionSubmitterPrx>)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::UpdateEngineVersionResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.submitter));
        };
        return _makeLamdaOutgoing<Session::UpdateEngineVersionResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_updateEngineVersion, name, version, context);
    }

    /// \cond INTERNAL
    void _iceI_updateEngineVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::UpdateEngineVersionResult>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode getEngineVersion(const ::std::string& name, const ::std::string& version, EngineVersionInfo& engineVersion, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::GetEngineVersionResult>(true, this, &SessionPrx::_iceI_getEngineVersion, name, version, context).get();
        engineVersion = ::std::move(_result.engineVersion);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getEngineVersionAsync(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::GetEngineVersionResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::GetEngineVersionResult, P>(false, this, &SessionPrx::_iceI_getEngineVersion, name, version, context);
    }

    ::std::function<void()>
    getEngineVersionAsync(const ::std::string& name, const ::std::string& version,
                          ::std::function<void(ErrorCode, EngineVersionInfo)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::GetEngineVersionResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.engineVersion));
        };
        return _makeLamdaOutgoing<Session::GetEngineVersionResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_getEngineVersion, name, version, context);
    }

    /// \cond INTERNAL
    void _iceI_getEngineVersion(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetEngineVersionResult>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode changeEngineVersionDisplayPriority(const ::std::string& name, const ::std::string& version, int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_changeEngineVersionDisplayPriority, name, version, displayPriority, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto changeEngineVersionDisplayPriorityAsync(const ::std::string& name, const ::std::string& version, int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_changeEngineVersionDisplayPriority, name, version, displayPriority, context);
    }

    ::std::function<void()>
    changeEngineVersionDisplayPriorityAsync(const ::std::string& name, const ::std::string& version, int displayPriority,
                                            ::std::function<void(ErrorCode)> response,
                                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                            ::std::function<void(bool)> sent = nullptr,
                                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_changeEngineVersionDisplayPriority, name, version, displayPriority, context);
    }

    /// \cond INTERNAL
    void _iceI_changeEngineVersionDisplayPriority(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    ErrorCode browseExtra(const ::std::string& category, const ::std::string& search, ::std::shared_ptr<ExtraBrowserPrx>& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::BrowseExtraResult>(true, this, &SessionPrx::_iceI_browseExtra, category, search, context).get();
        browser = ::std::move(_result.browser);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto browseExtraAsync(const ::std::string& category, const ::std::string& search, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::BrowseExtraResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::BrowseExtraResult, P>(false, this, &SessionPrx::_iceI_browseExtra, category, search, context);
    }

    ::std::function<void()>
    browseExtraAsync(const ::std::string& category, const ::std::string& search,
                     ::std::function<void(ErrorCode, ::std::shared_ptr<ExtraBrowserPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::BrowseExtraResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.browser));
        };
        return _makeLamdaOutgoing<Session::BrowseExtraResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_browseExtra, category, search, context);
    }

    /// \cond INTERNAL
    void _iceI_browseExtra(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseExtraResult>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode browseExtraByParentId(const ::std::string& parentId, ::std::shared_ptr<ExtraBrowserPrx>& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::BrowseExtraByParentIdResult>(true, this, &SessionPrx::_iceI_browseExtraByParentId, parentId, context).get();
        browser = ::std::move(_result.browser);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto browseExtraByParentIdAsync(const ::std::string& parentId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::BrowseExtraByParentIdResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::BrowseExtraByParentIdResult, P>(false, this, &SessionPrx::_iceI_browseExtraByParentId, parentId, context);
    }

    ::std::function<void()>
    browseExtraByParentIdAsync(const ::std::string& parentId,
                               ::std::function<void(ErrorCode, ::std::shared_ptr<ExtraBrowserPrx>)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::BrowseExtraByParentIdResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.browser));
        };
        return _makeLamdaOutgoing<Session::BrowseExtraByParentIdResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_browseExtraByParentId, parentId, context);
    }

    /// \cond INTERNAL
    void _iceI_browseExtraByParentId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseExtraByParentIdResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode getExtraInfo(const ::std::string& id, ExtraInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::GetExtraInfoResult>(true, this, &SessionPrx::_iceI_getExtraInfo, id, context).get();
        info = ::std::move(_result.info);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getExtraInfoAsync(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::GetExtraInfoResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::GetExtraInfoResult, P>(false, this, &SessionPrx::_iceI_getExtraInfo, id, context);
    }

    ::std::function<void()>
    getExtraInfoAsync(const ::std::string& id,
                      ::std::function<void(ErrorCode, ExtraInfo)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::GetExtraInfoResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.info));
        };
        return _makeLamdaOutgoing<Session::GetExtraInfoResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_getExtraInfo, id, context);
    }

    /// \cond INTERNAL
    void _iceI_getExtraInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetExtraInfoResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode downloadExtraImage(const ::std::string& id, ::std::shared_ptr<DownloaderPrx>& downloader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::DownloadExtraImageResult>(true, this, &SessionPrx::_iceI_downloadExtraImage, id, context).get();
        downloader = ::std::move(_result.downloader);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto downloadExtraImageAsync(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::DownloadExtraImageResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::DownloadExtraImageResult, P>(false, this, &SessionPrx::_iceI_downloadExtraImage, id, context);
    }

    ::std::function<void()>
    downloadExtraImageAsync(const ::std::string& id,
                            ::std::function<void(ErrorCode, ::std::shared_ptr<DownloaderPrx>)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::DownloadExtraImageResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.downloader));
        };
        return _makeLamdaOutgoing<Session::DownloadExtraImageResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_downloadExtraImage, id, context);
    }

    /// \cond INTERNAL
    void _iceI_downloadExtraImage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::DownloadExtraImageResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode downloadExtra(const ::std::string& id, ::std::shared_ptr<DownloaderPrx>& downloader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::DownloadExtraResult>(true, this, &SessionPrx::_iceI_downloadExtra, id, context).get();
        downloader = ::std::move(_result.downloader);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto downloadExtraAsync(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::DownloadExtraResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::DownloadExtraResult, P>(false, this, &SessionPrx::_iceI_downloadExtra, id, context);
    }

    ::std::function<void()>
    downloadExtraAsync(const ::std::string& id,
                       ::std::function<void(ErrorCode, ::std::shared_ptr<DownloaderPrx>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::DownloadExtraResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.downloader));
        };
        return _makeLamdaOutgoing<Session::DownloadExtraResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_downloadExtra, id, context);
    }

    /// \cond INTERNAL
    void _iceI_downloadExtra(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::DownloadExtraResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode submitExtra(::std::shared_ptr<ExtraSubmitterPrx>& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::SubmitExtraResult>(true, this, &SessionPrx::_iceI_submitExtra, context).get();
        submitter = ::std::move(_result.submitter);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto submitExtraAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::SubmitExtraResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::SubmitExtraResult, P>(false, this, &SessionPrx::_iceI_submitExtra, context);
    }

    ::std::function<void()>
    submitExtraAsync(::std::function<void(ErrorCode, ::std::shared_ptr<ExtraSubmitterPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::SubmitExtraResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.submitter));
        };
        return _makeLamdaOutgoing<Session::SubmitExtraResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_submitExtra, context);
    }

    /// \cond INTERNAL
    void _iceI_submitExtra(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::SubmitExtraResult>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode updateExtra(const ::std::string& id, ::std::shared_ptr<ExtraSubmitterPrx>& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::UpdateExtraResult>(true, this, &SessionPrx::_iceI_updateExtra, id, context).get();
        submitter = ::std::move(_result.submitter);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto updateExtraAsync(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::UpdateExtraResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::UpdateExtraResult, P>(false, this, &SessionPrx::_iceI_updateExtra, id, context);
    }

    ::std::function<void()>
    updateExtraAsync(const ::std::string& id,
                     ::std::function<void(ErrorCode, ::std::shared_ptr<ExtraSubmitterPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::UpdateExtraResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.submitter));
        };
        return _makeLamdaOutgoing<Session::UpdateExtraResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_updateExtra, id, context);
    }

    /// \cond INTERNAL
    void _iceI_updateExtra(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::UpdateExtraResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode changeExtraState(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_changeExtraState, id, state, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto changeExtraStateAsync(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_changeExtraState, id, state, context);
    }

    ::std::function<void()>
    changeExtraStateAsync(const ::std::string& id, const ::std::string& state,
                          ::std::function<void(ErrorCode)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_changeExtraState, id, state, context);
    }

    /// \cond INTERNAL
    void _iceI_changeExtraState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode changeExtraDisplayPriority(const ::std::string& id, int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_changeExtraDisplayPriority, id, displayPriority, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto changeExtraDisplayPriorityAsync(const ::std::string& id, int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_changeExtraDisplayPriority, id, displayPriority, context);
    }

    ::std::function<void()>
    changeExtraDisplayPriorityAsync(const ::std::string& id, int displayPriority,
                                    ::std::function<void(ErrorCode)> response,
                                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                    ::std::function<void(bool)> sent = nullptr,
                                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_changeExtraDisplayPriority, id, displayPriority, context);
    }

    /// \cond INTERNAL
    void _iceI_changeExtraDisplayPriority(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    ErrorCode browseClient(::std::shared_ptr<ClientBrowserPrx>& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::BrowseClientResult>(true, this, &SessionPrx::_iceI_browseClient, context).get();
        browser = ::std::move(_result.browser);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto browseClientAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::BrowseClientResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::BrowseClientResult, P>(false, this, &SessionPrx::_iceI_browseClient, context);
    }

    ::std::function<void()>
    browseClientAsync(::std::function<void(ErrorCode, ::std::shared_ptr<ClientBrowserPrx>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::BrowseClientResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.browser));
        };
        return _makeLamdaOutgoing<Session::BrowseClientResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_browseClient, context);
    }

    /// \cond INTERNAL
    void _iceI_browseClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseClientResult>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode getClientInfo(const ::std::string& version, ClientInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::GetClientInfoResult>(true, this, &SessionPrx::_iceI_getClientInfo, version, context).get();
        info = ::std::move(_result.info);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getClientInfoAsync(const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::GetClientInfoResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::GetClientInfoResult, P>(false, this, &SessionPrx::_iceI_getClientInfo, version, context);
    }

    ::std::function<void()>
    getClientInfoAsync(const ::std::string& version,
                       ::std::function<void(ErrorCode, ClientInfo)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::GetClientInfoResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.info));
        };
        return _makeLamdaOutgoing<Session::GetClientInfoResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_getClientInfo, version, context);
    }

    /// \cond INTERNAL
    void _iceI_getClientInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetClientInfoResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode submitClient(const ::std::string& version, ::std::shared_ptr<ClientSubmitterPrx>& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::SubmitClientResult>(true, this, &SessionPrx::_iceI_submitClient, version, context).get();
        submitter = ::std::move(_result.submitter);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto submitClientAsync(const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::SubmitClientResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::SubmitClientResult, P>(false, this, &SessionPrx::_iceI_submitClient, version, context);
    }

    ::std::function<void()>
    submitClientAsync(const ::std::string& version,
                      ::std::function<void(ErrorCode, ::std::shared_ptr<ClientSubmitterPrx>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::SubmitClientResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.submitter));
        };
        return _makeLamdaOutgoing<Session::SubmitClientResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_submitClient, version, context);
    }

    /// \cond INTERNAL
    void _iceI_submitClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::SubmitClientResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode updateClient(const ::std::string& version, ::std::shared_ptr<ClientSubmitterPrx>& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::UpdateClientResult>(true, this, &SessionPrx::_iceI_updateClient, version, context).get();
        submitter = ::std::move(_result.submitter);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto updateClientAsync(const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::UpdateClientResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::UpdateClientResult, P>(false, this, &SessionPrx::_iceI_updateClient, version, context);
    }

    ::std::function<void()>
    updateClientAsync(const ::std::string& version,
                      ::std::function<void(ErrorCode, ::std::shared_ptr<ClientSubmitterPrx>)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::UpdateClientResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.submitter));
        };
        return _makeLamdaOutgoing<Session::UpdateClientResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_updateClient, version, context);
    }

    /// \cond INTERNAL
    void _iceI_updateClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::UpdateClientResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode removeClient(const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_removeClient, version, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto removeClientAsync(const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_removeClient, version, context);
    }

    ::std::function<void()>
    removeClientAsync(const ::std::string& version,
                      ::std::function<void(ErrorCode)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_removeClient, version, context);
    }

    /// \cond INTERNAL
    void _iceI_removeClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode browseUsers(::std::shared_ptr<UserBrowserPrx>& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::BrowseUsersResult>(true, this, &SessionPrx::_iceI_browseUsers, context).get();
        browser = ::std::move(_result.browser);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto browseUsersAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::BrowseUsersResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::BrowseUsersResult, P>(false, this, &SessionPrx::_iceI_browseUsers, context);
    }

    ::std::function<void()>
    browseUsersAsync(::std::function<void(ErrorCode, ::std::shared_ptr<UserBrowserPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::BrowseUsersResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.browser));
        };
        return _makeLamdaOutgoing<Session::BrowseUsersResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_browseUsers, context);
    }

    /// \cond INTERNAL
    void _iceI_browseUsers(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseUsersResult>>&, const ::Ice::Context&);
    /// \endcond

    ErrorCode setUserGroup(const ::std::string& username, const ::std::string& group, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_setUserGroup, username, group, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setUserGroupAsync(const ::std::string& username, const ::std::string& group, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_setUserGroup, username, group, context);
    }

    ::std::function<void()>
    setUserGroupAsync(const ::std::string& username, const ::std::string& group,
                      ::std::function<void(ErrorCode)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_setUserGroup, username, group, context);
    }

    /// \cond INTERNAL
    void _iceI_setUserGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode removeUser(const ::std::string& username, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_removeUser, username, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto removeUserAsync(const ::std::string& username, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_removeUser, username, context);
    }

    ::std::function<void()>
    removeUserAsync(const ::std::string& username,
                    ::std::function<void(ErrorCode)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_removeUser, username, context);
    }

    /// \cond INTERNAL
    void _iceI_removeUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode browseComment(const ::std::string& targetId, const ::std::string& user, ::std::shared_ptr<CommentBrowserPrx>& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::BrowseCommentResult>(true, this, &SessionPrx::_iceI_browseComment, targetId, user, context).get();
        browser = ::std::move(_result.browser);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto browseCommentAsync(const ::std::string& targetId, const ::std::string& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::BrowseCommentResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::BrowseCommentResult, P>(false, this, &SessionPrx::_iceI_browseComment, targetId, user, context);
    }

    ::std::function<void()>
    browseCommentAsync(const ::std::string& targetId, const ::std::string& user,
                       ::std::function<void(ErrorCode, ::std::shared_ptr<CommentBrowserPrx>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::BrowseCommentResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.browser));
        };
        return _makeLamdaOutgoing<Session::BrowseCommentResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_browseComment, targetId, user, context);
    }

    /// \cond INTERNAL
    void _iceI_browseComment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::BrowseCommentResult>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode getComment(const ::std::string& targetId, ::std::string& comment, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::GetCommentResult>(true, this, &SessionPrx::_iceI_getComment, targetId, context).get();
        comment = ::std::move(_result.comment);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getCommentAsync(const ::std::string& targetId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::GetCommentResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::GetCommentResult, P>(false, this, &SessionPrx::_iceI_getComment, targetId, context);
    }

    ::std::function<void()>
    getCommentAsync(const ::std::string& targetId,
                    ::std::function<void(ErrorCode, ::std::string)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::GetCommentResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.comment));
        };
        return _makeLamdaOutgoing<Session::GetCommentResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_getComment, targetId, context);
    }

    /// \cond INTERNAL
    void _iceI_getComment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::GetCommentResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode addComment(const ::std::string& targetId, const ::std::string& comment, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_addComment, targetId, comment, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addCommentAsync(const ::std::string& targetId, const ::std::string& comment, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_addComment, targetId, comment, context);
    }

    ::std::function<void()>
    addCommentAsync(const ::std::string& targetId, const ::std::string& comment,
                    ::std::function<void(ErrorCode)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_addComment, targetId, comment, context);
    }

    /// \cond INTERNAL
    void _iceI_addComment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode editComment(const ::std::string& id, const ::std::string& comment, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_editComment, id, comment, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto editCommentAsync(const ::std::string& id, const ::std::string& comment, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_editComment, id, comment, context);
    }

    ::std::function<void()>
    editCommentAsync(const ::std::string& id, const ::std::string& comment,
                     ::std::function<void(ErrorCode)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_editComment, id, comment, context);
    }

    /// \cond INTERNAL
    void _iceI_editComment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode removeComment(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<ErrorCode>(true, this, &SessionPrx::_iceI_removeComment, id, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto removeCommentAsync(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ErrorCode>>().get_future())
    {
        return _makePromiseOutgoing<ErrorCode, P>(false, this, &SessionPrx::_iceI_removeComment, id, context);
    }

    ::std::function<void()>
    removeCommentAsync(const ::std::string& id,
                       ::std::function<void(ErrorCode)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<ErrorCode>(response, ex, sent, this, &Rpc::SessionPrx::_iceI_removeComment, id, context);
    }

    /// \cond INTERNAL
    void _iceI_removeComment(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ErrorCode>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode queryDownloadCount(const ::std::string& targetId, int& count, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::QueryDownloadCountResult>(true, this, &SessionPrx::_iceI_queryDownloadCount, targetId, context).get();
        count = _result.count;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto queryDownloadCountAsync(const ::std::string& targetId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::QueryDownloadCountResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::QueryDownloadCountResult, P>(false, this, &SessionPrx::_iceI_queryDownloadCount, targetId, context);
    }

    ::std::function<void()>
    queryDownloadCountAsync(const ::std::string& targetId,
                            ::std::function<void(ErrorCode, int)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::QueryDownloadCountResult&& _result)
        {
            response(_result.returnValue, _result.count);
        };
        return _makeLamdaOutgoing<Session::QueryDownloadCountResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_queryDownloadCount, targetId, context);
    }

    /// \cond INTERNAL
    void _iceI_queryDownloadCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::QueryDownloadCountResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode isUserOnline(const ::std::string& userName, bool& result, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::IsUserOnlineResult>(true, this, &SessionPrx::_iceI_isUserOnline, userName, context).get();
        result = _result.result;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto isUserOnlineAsync(const ::std::string& userName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::IsUserOnlineResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::IsUserOnlineResult, P>(false, this, &SessionPrx::_iceI_isUserOnline, userName, context);
    }

    ::std::function<void()>
    isUserOnlineAsync(const ::std::string& userName,
                      ::std::function<void(ErrorCode, bool)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::IsUserOnlineResult&& _result)
        {
            response(_result.returnValue, _result.result);
        };
        return _makeLamdaOutgoing<Session::IsUserOnlineResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_isUserOnline, userName, context);
    }

    /// \cond INTERNAL
    void _iceI_isUserOnline(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::IsUserOnlineResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ErrorCode onlineUserCount(int& count, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<Session::OnlineUserCountResult>(true, this, &SessionPrx::_iceI_onlineUserCount, context).get();
        count = _result.count;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto onlineUserCountAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<Session::OnlineUserCountResult>>().get_future())
    {
        return _makePromiseOutgoing<Session::OnlineUserCountResult, P>(false, this, &SessionPrx::_iceI_onlineUserCount, context);
    }

    ::std::function<void()>
    onlineUserCountAsync(::std::function<void(ErrorCode, int)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](Session::OnlineUserCountResult&& _result)
        {
            response(_result.returnValue, _result.count);
        };
        return _makeLamdaOutgoing<Session::OnlineUserCountResult>(_responseCb, ex, sent, this, &Rpc::SessionPrx::_iceI_onlineUserCount, context);
    }

    /// \cond INTERNAL
    void _iceI_onlineUserCount(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<Session::OnlineUserCountResult>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    SessionPrx() = default;
    friend ::std::shared_ptr<SessionPrx> IceInternal::createProxy<SessionPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::Rpc::ContentItem>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Rpc::ContentItem, S>
{
    static void read(S* istr, ::Rpc::ContentItem& v)
    {
        istr->readAll(v.rowid, v.id, v.title, v.state);
    }
};

template<>
struct StreamableTraits<::Rpc::ContentInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 29;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Rpc::ContentInfo, S>
{
    static void read(S* istr, ::Rpc::ContentInfo& v)
    {
        istr->readAll(v.rowid, v.id, v.parentId, v.title, v.page, v.category, v.engineName, v.engineVersion, v.startup, v.imageCount, v.video, v.desc, v.user, v.upTime, v.displayPriority, v.state);
    }
};

template<>
struct StreamableTraits<::Rpc::EngineVersionInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Rpc::EngineVersionInfo, S>
{
    static void read(S* istr, ::Rpc::EngineVersionInfo& v)
    {
        istr->readAll(v.name, v.version, v.setup, v.unsetup, v.uptime, v.info, v.displayPriority, v.state);
    }
};

template<>
struct StreamableTraits<::Rpc::ExtraInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Rpc::ExtraInfo, S>
{
    static void read(S* istr, ::Rpc::ExtraInfo& v)
    {
        istr->readAll(v.id, v.parentId, v.title, v.category, v.setup, v.user, v.uptime, v.info, v.displayPriority, v.state);
    }
};

template<>
struct StreamableTraits<::Rpc::User>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Rpc::User, S>
{
    static void read(S* istr, ::Rpc::User& v)
    {
        istr->readAll(v.username, v.group, v.info);
    }
};

template<>
struct StreamableTraits<::Rpc::ClientInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Rpc::ClientInfo, S>
{
    static void read(S* istr, ::Rpc::ClientInfo& v)
    {
        istr->readAll(v.version, v.uptime, v.info, v.state);
    }
};

template<>
struct StreamableTraits<::Rpc::Comment>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::Rpc::Comment, S>
{
    static void read(S* istr, ::Rpc::Comment& v)
    {
        istr->readAll(v.id, v.targetId, v.user, v.time, v.comment);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace Rpc
{

using ContentBrowserPtr = ::std::shared_ptr<ContentBrowser>;
using ContentBrowserPrxPtr = ::std::shared_ptr<ContentBrowserPrx>;

using EngineVersionBrowserPtr = ::std::shared_ptr<EngineVersionBrowser>;
using EngineVersionBrowserPrxPtr = ::std::shared_ptr<EngineVersionBrowserPrx>;

using ExtraBrowserPtr = ::std::shared_ptr<ExtraBrowser>;
using ExtraBrowserPrxPtr = ::std::shared_ptr<ExtraBrowserPrx>;

using UserBrowserPtr = ::std::shared_ptr<UserBrowser>;
using UserBrowserPrxPtr = ::std::shared_ptr<UserBrowserPrx>;

using ContentSubmitterPtr = ::std::shared_ptr<ContentSubmitter>;
using ContentSubmitterPrxPtr = ::std::shared_ptr<ContentSubmitterPrx>;

using EngineVersionSubmitterPtr = ::std::shared_ptr<EngineVersionSubmitter>;
using EngineVersionSubmitterPrxPtr = ::std::shared_ptr<EngineVersionSubmitterPrx>;

using ExtraSubmitterPtr = ::std::shared_ptr<ExtraSubmitter>;
using ExtraSubmitterPrxPtr = ::std::shared_ptr<ExtraSubmitterPrx>;

using ClientBrowserPtr = ::std::shared_ptr<ClientBrowser>;
using ClientBrowserPrxPtr = ::std::shared_ptr<ClientBrowserPrx>;

using ClientSubmitterPtr = ::std::shared_ptr<ClientSubmitter>;
using ClientSubmitterPrxPtr = ::std::shared_ptr<ClientSubmitterPrx>;

using CommentBrowserPtr = ::std::shared_ptr<CommentBrowser>;
using CommentBrowserPrxPtr = ::std::shared_ptr<CommentBrowserPrx>;

using SessionPtr = ::std::shared_ptr<Session>;
using SessionPrxPtr = ::std::shared_ptr<SessionPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace Rpc
{

class ContentBrowser;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ContentBrowser>&);
::IceProxy::Ice::Object* upCast(ContentBrowser*);
/// \endcond

class EngineVersionBrowser;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< EngineVersionBrowser>&);
::IceProxy::Ice::Object* upCast(EngineVersionBrowser*);
/// \endcond

class ExtraBrowser;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ExtraBrowser>&);
::IceProxy::Ice::Object* upCast(ExtraBrowser*);
/// \endcond

class UserBrowser;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< UserBrowser>&);
::IceProxy::Ice::Object* upCast(UserBrowser*);
/// \endcond

class ContentSubmitter;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ContentSubmitter>&);
::IceProxy::Ice::Object* upCast(ContentSubmitter*);
/// \endcond

class EngineVersionSubmitter;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< EngineVersionSubmitter>&);
::IceProxy::Ice::Object* upCast(EngineVersionSubmitter*);
/// \endcond

class ExtraSubmitter;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ExtraSubmitter>&);
::IceProxy::Ice::Object* upCast(ExtraSubmitter*);
/// \endcond

class ClientBrowser;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ClientBrowser>&);
::IceProxy::Ice::Object* upCast(ClientBrowser*);
/// \endcond

class ClientSubmitter;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ClientSubmitter>&);
::IceProxy::Ice::Object* upCast(ClientSubmitter*);
/// \endcond

class CommentBrowser;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< CommentBrowser>&);
::IceProxy::Ice::Object* upCast(CommentBrowser*);
/// \endcond

class Session;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Session>&);
::IceProxy::Ice::Object* upCast(Session*);
/// \endcond

}

}

namespace Rpc
{

class ContentBrowser;
/// \cond INTERNAL
::Ice::Object* upCast(ContentBrowser*);
/// \endcond
typedef ::IceInternal::Handle< ContentBrowser> ContentBrowserPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Rpc::ContentBrowser> ContentBrowserPrx;
typedef ContentBrowserPrx ContentBrowserPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ContentBrowserPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class EngineVersionBrowser;
/// \cond INTERNAL
::Ice::Object* upCast(EngineVersionBrowser*);
/// \endcond
typedef ::IceInternal::Handle< EngineVersionBrowser> EngineVersionBrowserPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Rpc::EngineVersionBrowser> EngineVersionBrowserPrx;
typedef EngineVersionBrowserPrx EngineVersionBrowserPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EngineVersionBrowserPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class ExtraBrowser;
/// \cond INTERNAL
::Ice::Object* upCast(ExtraBrowser*);
/// \endcond
typedef ::IceInternal::Handle< ExtraBrowser> ExtraBrowserPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Rpc::ExtraBrowser> ExtraBrowserPrx;
typedef ExtraBrowserPrx ExtraBrowserPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ExtraBrowserPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class UserBrowser;
/// \cond INTERNAL
::Ice::Object* upCast(UserBrowser*);
/// \endcond
typedef ::IceInternal::Handle< UserBrowser> UserBrowserPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Rpc::UserBrowser> UserBrowserPrx;
typedef UserBrowserPrx UserBrowserPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(UserBrowserPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class ContentSubmitter;
/// \cond INTERNAL
::Ice::Object* upCast(ContentSubmitter*);
/// \endcond
typedef ::IceInternal::Handle< ContentSubmitter> ContentSubmitterPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Rpc::ContentSubmitter> ContentSubmitterPrx;
typedef ContentSubmitterPrx ContentSubmitterPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ContentSubmitterPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class EngineVersionSubmitter;
/// \cond INTERNAL
::Ice::Object* upCast(EngineVersionSubmitter*);
/// \endcond
typedef ::IceInternal::Handle< EngineVersionSubmitter> EngineVersionSubmitterPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Rpc::EngineVersionSubmitter> EngineVersionSubmitterPrx;
typedef EngineVersionSubmitterPrx EngineVersionSubmitterPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(EngineVersionSubmitterPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class ExtraSubmitter;
/// \cond INTERNAL
::Ice::Object* upCast(ExtraSubmitter*);
/// \endcond
typedef ::IceInternal::Handle< ExtraSubmitter> ExtraSubmitterPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Rpc::ExtraSubmitter> ExtraSubmitterPrx;
typedef ExtraSubmitterPrx ExtraSubmitterPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ExtraSubmitterPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class ClientBrowser;
/// \cond INTERNAL
::Ice::Object* upCast(ClientBrowser*);
/// \endcond
typedef ::IceInternal::Handle< ClientBrowser> ClientBrowserPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Rpc::ClientBrowser> ClientBrowserPrx;
typedef ClientBrowserPrx ClientBrowserPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ClientBrowserPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class ClientSubmitter;
/// \cond INTERNAL
::Ice::Object* upCast(ClientSubmitter*);
/// \endcond
typedef ::IceInternal::Handle< ClientSubmitter> ClientSubmitterPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Rpc::ClientSubmitter> ClientSubmitterPrx;
typedef ClientSubmitterPrx ClientSubmitterPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ClientSubmitterPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class CommentBrowser;
/// \cond INTERNAL
::Ice::Object* upCast(CommentBrowser*);
/// \endcond
typedef ::IceInternal::Handle< CommentBrowser> CommentBrowserPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Rpc::CommentBrowser> CommentBrowserPrx;
typedef CommentBrowserPrx CommentBrowserPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(CommentBrowserPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Session;
/// \cond INTERNAL
::Ice::Object* upCast(Session*);
/// \endcond
typedef ::IceInternal::Handle< Session> SessionPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Rpc::Session> SessionPrx;
typedef SessionPrx SessionPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SessionPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace Rpc
{

struct ContentItem
{
    ::Ice::Long rowid;
    ::std::string id;
    ::std::string title;
    ::std::string state;

    bool operator==(const ContentItem& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(rowid != rhs_.rowid)
        {
            return false;
        }
        if(id != rhs_.id)
        {
            return false;
        }
        if(title != rhs_.title)
        {
            return false;
        }
        if(state != rhs_.state)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ContentItem& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(rowid < rhs_.rowid)
        {
            return true;
        }
        else if(rhs_.rowid < rowid)
        {
            return false;
        }
        if(id < rhs_.id)
        {
            return true;
        }
        else if(rhs_.id < id)
        {
            return false;
        }
        if(title < rhs_.title)
        {
            return true;
        }
        else if(rhs_.title < title)
        {
            return false;
        }
        if(state < rhs_.state)
        {
            return true;
        }
        else if(rhs_.state < state)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ContentItem& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ContentItem& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ContentItem& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ContentItem& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct ContentInfo
{
    ::Ice::Long rowid;
    ::std::string id;
    ::std::string parentId;
    ::std::string title;
    ::std::string page;
    ::std::string category;
    ::std::string engineName;
    ::std::string engineVersion;
    ::std::string startup;
    ::Ice::Int imageCount;
    ::std::string video;
    ::std::string desc;
    ::std::string user;
    ::std::string upTime;
    ::Ice::Int displayPriority;
    ::std::string state;

    bool operator==(const ContentInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(rowid != rhs_.rowid)
        {
            return false;
        }
        if(id != rhs_.id)
        {
            return false;
        }
        if(parentId != rhs_.parentId)
        {
            return false;
        }
        if(title != rhs_.title)
        {
            return false;
        }
        if(page != rhs_.page)
        {
            return false;
        }
        if(category != rhs_.category)
        {
            return false;
        }
        if(engineName != rhs_.engineName)
        {
            return false;
        }
        if(engineVersion != rhs_.engineVersion)
        {
            return false;
        }
        if(startup != rhs_.startup)
        {
            return false;
        }
        if(imageCount != rhs_.imageCount)
        {
            return false;
        }
        if(video != rhs_.video)
        {
            return false;
        }
        if(desc != rhs_.desc)
        {
            return false;
        }
        if(user != rhs_.user)
        {
            return false;
        }
        if(upTime != rhs_.upTime)
        {
            return false;
        }
        if(displayPriority != rhs_.displayPriority)
        {
            return false;
        }
        if(state != rhs_.state)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ContentInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(rowid < rhs_.rowid)
        {
            return true;
        }
        else if(rhs_.rowid < rowid)
        {
            return false;
        }
        if(id < rhs_.id)
        {
            return true;
        }
        else if(rhs_.id < id)
        {
            return false;
        }
        if(parentId < rhs_.parentId)
        {
            return true;
        }
        else if(rhs_.parentId < parentId)
        {
            return false;
        }
        if(title < rhs_.title)
        {
            return true;
        }
        else if(rhs_.title < title)
        {
            return false;
        }
        if(page < rhs_.page)
        {
            return true;
        }
        else if(rhs_.page < page)
        {
            return false;
        }
        if(category < rhs_.category)
        {
            return true;
        }
        else if(rhs_.category < category)
        {
            return false;
        }
        if(engineName < rhs_.engineName)
        {
            return true;
        }
        else if(rhs_.engineName < engineName)
        {
            return false;
        }
        if(engineVersion < rhs_.engineVersion)
        {
            return true;
        }
        else if(rhs_.engineVersion < engineVersion)
        {
            return false;
        }
        if(startup < rhs_.startup)
        {
            return true;
        }
        else if(rhs_.startup < startup)
        {
            return false;
        }
        if(imageCount < rhs_.imageCount)
        {
            return true;
        }
        else if(rhs_.imageCount < imageCount)
        {
            return false;
        }
        if(video < rhs_.video)
        {
            return true;
        }
        else if(rhs_.video < video)
        {
            return false;
        }
        if(desc < rhs_.desc)
        {
            return true;
        }
        else if(rhs_.desc < desc)
        {
            return false;
        }
        if(user < rhs_.user)
        {
            return true;
        }
        else if(rhs_.user < user)
        {
            return false;
        }
        if(upTime < rhs_.upTime)
        {
            return true;
        }
        else if(rhs_.upTime < upTime)
        {
            return false;
        }
        if(displayPriority < rhs_.displayPriority)
        {
            return true;
        }
        else if(rhs_.displayPriority < displayPriority)
        {
            return false;
        }
        if(state < rhs_.state)
        {
            return true;
        }
        else if(rhs_.state < state)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ContentInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ContentInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ContentInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ContentInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<ContentItem> ContentItemSeq;

struct EngineVersionInfo
{
    ::std::string name;
    ::std::string version;
    ::std::string setup;
    ::std::string unsetup;
    ::std::string uptime;
    ::std::string info;
    ::Ice::Int displayPriority;
    ::std::string state;

    bool operator==(const EngineVersionInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(name != rhs_.name)
        {
            return false;
        }
        if(version != rhs_.version)
        {
            return false;
        }
        if(setup != rhs_.setup)
        {
            return false;
        }
        if(unsetup != rhs_.unsetup)
        {
            return false;
        }
        if(uptime != rhs_.uptime)
        {
            return false;
        }
        if(info != rhs_.info)
        {
            return false;
        }
        if(displayPriority != rhs_.displayPriority)
        {
            return false;
        }
        if(state != rhs_.state)
        {
            return false;
        }
        return true;
    }

    bool operator<(const EngineVersionInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(name < rhs_.name)
        {
            return true;
        }
        else if(rhs_.name < name)
        {
            return false;
        }
        if(version < rhs_.version)
        {
            return true;
        }
        else if(rhs_.version < version)
        {
            return false;
        }
        if(setup < rhs_.setup)
        {
            return true;
        }
        else if(rhs_.setup < setup)
        {
            return false;
        }
        if(unsetup < rhs_.unsetup)
        {
            return true;
        }
        else if(rhs_.unsetup < unsetup)
        {
            return false;
        }
        if(uptime < rhs_.uptime)
        {
            return true;
        }
        else if(rhs_.uptime < uptime)
        {
            return false;
        }
        if(info < rhs_.info)
        {
            return true;
        }
        else if(rhs_.info < info)
        {
            return false;
        }
        if(displayPriority < rhs_.displayPriority)
        {
            return true;
        }
        else if(rhs_.displayPriority < displayPriority)
        {
            return false;
        }
        if(state < rhs_.state)
        {
            return true;
        }
        else if(rhs_.state < state)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const EngineVersionInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const EngineVersionInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const EngineVersionInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const EngineVersionInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<EngineVersionInfo> EngineVersionSeq;

struct ExtraInfo
{
    ::std::string id;
    ::std::string parentId;
    ::std::string title;
    ::std::string category;
    ::std::string setup;
    ::std::string user;
    ::std::string uptime;
    ::std::string info;
    ::Ice::Int displayPriority;
    ::std::string state;

    bool operator==(const ExtraInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(id != rhs_.id)
        {
            return false;
        }
        if(parentId != rhs_.parentId)
        {
            return false;
        }
        if(title != rhs_.title)
        {
            return false;
        }
        if(category != rhs_.category)
        {
            return false;
        }
        if(setup != rhs_.setup)
        {
            return false;
        }
        if(user != rhs_.user)
        {
            return false;
        }
        if(uptime != rhs_.uptime)
        {
            return false;
        }
        if(info != rhs_.info)
        {
            return false;
        }
        if(displayPriority != rhs_.displayPriority)
        {
            return false;
        }
        if(state != rhs_.state)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ExtraInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(id < rhs_.id)
        {
            return true;
        }
        else if(rhs_.id < id)
        {
            return false;
        }
        if(parentId < rhs_.parentId)
        {
            return true;
        }
        else if(rhs_.parentId < parentId)
        {
            return false;
        }
        if(title < rhs_.title)
        {
            return true;
        }
        else if(rhs_.title < title)
        {
            return false;
        }
        if(category < rhs_.category)
        {
            return true;
        }
        else if(rhs_.category < category)
        {
            return false;
        }
        if(setup < rhs_.setup)
        {
            return true;
        }
        else if(rhs_.setup < setup)
        {
            return false;
        }
        if(user < rhs_.user)
        {
            return true;
        }
        else if(rhs_.user < user)
        {
            return false;
        }
        if(uptime < rhs_.uptime)
        {
            return true;
        }
        else if(rhs_.uptime < uptime)
        {
            return false;
        }
        if(info < rhs_.info)
        {
            return true;
        }
        else if(rhs_.info < info)
        {
            return false;
        }
        if(displayPriority < rhs_.displayPriority)
        {
            return true;
        }
        else if(rhs_.displayPriority < displayPriority)
        {
            return false;
        }
        if(state < rhs_.state)
        {
            return true;
        }
        else if(rhs_.state < state)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ExtraInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ExtraInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ExtraInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ExtraInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<ExtraInfo> ExtraInfoSeq;

struct User
{
    ::std::string username;
    ::std::string group;
    ::std::string info;

    bool operator==(const User& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(username != rhs_.username)
        {
            return false;
        }
        if(group != rhs_.group)
        {
            return false;
        }
        if(info != rhs_.info)
        {
            return false;
        }
        return true;
    }

    bool operator<(const User& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(username < rhs_.username)
        {
            return true;
        }
        else if(rhs_.username < username)
        {
            return false;
        }
        if(group < rhs_.group)
        {
            return true;
        }
        else if(rhs_.group < group)
        {
            return false;
        }
        if(info < rhs_.info)
        {
            return true;
        }
        else if(rhs_.info < info)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const User& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const User& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const User& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const User& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<User> UserSeq;

struct ClientInfo
{
    ::std::string version;
    ::std::string uptime;
    ::std::string info;
    ::std::string state;

    bool operator==(const ClientInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(version != rhs_.version)
        {
            return false;
        }
        if(uptime != rhs_.uptime)
        {
            return false;
        }
        if(info != rhs_.info)
        {
            return false;
        }
        if(state != rhs_.state)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ClientInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(version < rhs_.version)
        {
            return true;
        }
        else if(rhs_.version < version)
        {
            return false;
        }
        if(uptime < rhs_.uptime)
        {
            return true;
        }
        else if(rhs_.uptime < uptime)
        {
            return false;
        }
        if(info < rhs_.info)
        {
            return true;
        }
        else if(rhs_.info < info)
        {
            return false;
        }
        if(state < rhs_.state)
        {
            return true;
        }
        else if(rhs_.state < state)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ClientInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ClientInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ClientInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ClientInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<ClientInfo> ClientInfoSeq;

struct Comment
{
    ::std::string id;
    ::std::string targetId;
    ::std::string user;
    ::std::string time;
    ::std::string comment;

    bool operator==(const Comment& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(id != rhs_.id)
        {
            return false;
        }
        if(targetId != rhs_.targetId)
        {
            return false;
        }
        if(user != rhs_.user)
        {
            return false;
        }
        if(time != rhs_.time)
        {
            return false;
        }
        if(comment != rhs_.comment)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Comment& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(id < rhs_.id)
        {
            return true;
        }
        else if(rhs_.id < id)
        {
            return false;
        }
        if(targetId < rhs_.targetId)
        {
            return true;
        }
        else if(rhs_.targetId < targetId)
        {
            return false;
        }
        if(user < rhs_.user)
        {
            return true;
        }
        else if(rhs_.user < user)
        {
            return false;
        }
        if(time < rhs_.time)
        {
            return true;
        }
        else if(rhs_.time < time)
        {
            return false;
        }
        if(comment < rhs_.comment)
        {
            return true;
        }
        else if(rhs_.comment < comment)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Comment& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const Comment& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const Comment& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const Comment& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<Comment> CommentSeq;

}

namespace Rpc
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentBrowser_next.
 */
class Callback_ContentBrowser_next_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentBrowser_next_Base> Callback_ContentBrowser_nextPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::EngineVersionBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionBrowser_next.
 */
class Callback_EngineVersionBrowser_next_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EngineVersionBrowser_next_Base> Callback_EngineVersionBrowser_nextPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ExtraBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraBrowser_next.
 */
class Callback_ExtraBrowser_next_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ExtraBrowser_next_Base> Callback_ExtraBrowser_nextPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::UserBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_UserBrowser_next.
 */
class Callback_UserBrowser_next_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_UserBrowser_next_Base> Callback_UserBrowser_nextPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_getId.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_getId.
 */
class Callback_ContentSubmitter_getId_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_getId_Base> Callback_ContentSubmitter_getIdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setTitle.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setTitle.
 */
class Callback_ContentSubmitter_setTitle_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_setTitle_Base> Callback_ContentSubmitter_setTitlePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setPage.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setPage.
 */
class Callback_ContentSubmitter_setPage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_setPage_Base> Callback_ContentSubmitter_setPagePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setCategory.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setCategory.
 */
class Callback_ContentSubmitter_setCategory_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_setCategory_Base> Callback_ContentSubmitter_setCategoryPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setEngine.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setEngine.
 */
class Callback_ContentSubmitter_setEngine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_setEngine_Base> Callback_ContentSubmitter_setEnginePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setStartup.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setStartup.
 */
class Callback_ContentSubmitter_setStartup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_setStartup_Base> Callback_ContentSubmitter_setStartupPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setParentId.
 */
class Callback_ContentSubmitter_setParentId_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_setParentId_Base> Callback_ContentSubmitter_setParentIdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setVideo.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setVideo.
 */
class Callback_ContentSubmitter_setVideo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_setVideo_Base> Callback_ContentSubmitter_setVideoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setDescription.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setDescription.
 */
class Callback_ContentSubmitter_setDescription_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_setDescription_Base> Callback_ContentSubmitter_setDescriptionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_uploadImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_uploadImage.
 */
class Callback_ContentSubmitter_uploadImage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_uploadImage_Base> Callback_ContentSubmitter_uploadImagePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_uploadContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_uploadContent.
 */
class Callback_ContentSubmitter_uploadContent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_uploadContent_Base> Callback_ContentSubmitter_uploadContentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_cancel.
 */
class Callback_ContentSubmitter_cancel_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_cancel_Base> Callback_ContentSubmitter_cancelPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_finish.
 */
class Callback_ContentSubmitter_finish_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ContentSubmitter_finish_Base> Callback_ContentSubmitter_finishPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_setSetup.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_setSetup.
 */
class Callback_EngineVersionSubmitter_setSetup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EngineVersionSubmitter_setSetup_Base> Callback_EngineVersionSubmitter_setSetupPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_setUnSetup.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_setUnSetup.
 */
class Callback_EngineVersionSubmitter_setUnSetup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EngineVersionSubmitter_setUnSetup_Base> Callback_EngineVersionSubmitter_setUnSetupPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_setInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_setInfo.
 */
class Callback_EngineVersionSubmitter_setInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EngineVersionSubmitter_setInfo_Base> Callback_EngineVersionSubmitter_setInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_uploadEngine.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_uploadEngine.
 */
class Callback_EngineVersionSubmitter_uploadEngine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EngineVersionSubmitter_uploadEngine_Base> Callback_EngineVersionSubmitter_uploadEnginePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_cancel.
 */
class Callback_EngineVersionSubmitter_cancel_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EngineVersionSubmitter_cancel_Base> Callback_EngineVersionSubmitter_cancelPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_finish.
 */
class Callback_EngineVersionSubmitter_finish_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_EngineVersionSubmitter_finish_Base> Callback_EngineVersionSubmitter_finishPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setParentId.
 */
class Callback_ExtraSubmitter_setParentId_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ExtraSubmitter_setParentId_Base> Callback_ExtraSubmitter_setParentIdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setTitle.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setTitle.
 */
class Callback_ExtraSubmitter_setTitle_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ExtraSubmitter_setTitle_Base> Callback_ExtraSubmitter_setTitlePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setSetup.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setSetup.
 */
class Callback_ExtraSubmitter_setSetup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ExtraSubmitter_setSetup_Base> Callback_ExtraSubmitter_setSetupPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setCategory.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setCategory.
 */
class Callback_ExtraSubmitter_setCategory_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ExtraSubmitter_setCategory_Base> Callback_ExtraSubmitter_setCategoryPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setInfo.
 */
class Callback_ExtraSubmitter_setInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ExtraSubmitter_setInfo_Base> Callback_ExtraSubmitter_setInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_uploadImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_uploadImage.
 */
class Callback_ExtraSubmitter_uploadImage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ExtraSubmitter_uploadImage_Base> Callback_ExtraSubmitter_uploadImagePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_uploadExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_uploadExtra.
 */
class Callback_ExtraSubmitter_uploadExtra_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ExtraSubmitter_uploadExtra_Base> Callback_ExtraSubmitter_uploadExtraPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_cancel.
 */
class Callback_ExtraSubmitter_cancel_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ExtraSubmitter_cancel_Base> Callback_ExtraSubmitter_cancelPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_finish.
 */
class Callback_ExtraSubmitter_finish_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ExtraSubmitter_finish_Base> Callback_ExtraSubmitter_finishPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ClientBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientBrowser_next.
 */
class Callback_ClientBrowser_next_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ClientBrowser_next_Base> Callback_ClientBrowser_nextPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_setInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_setInfo.
 */
class Callback_ClientSubmitter_setInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ClientSubmitter_setInfo_Base> Callback_ClientSubmitter_setInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_uploadClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_uploadClient.
 */
class Callback_ClientSubmitter_uploadClient_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ClientSubmitter_uploadClient_Base> Callback_ClientSubmitter_uploadClientPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_cancel.
 */
class Callback_ClientSubmitter_cancel_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ClientSubmitter_cancel_Base> Callback_ClientSubmitter_cancelPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_finish.
 */
class Callback_ClientSubmitter_finish_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ClientSubmitter_finish_Base> Callback_ClientSubmitter_finishPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::CommentBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_CommentBrowser_next.
 */
class Callback_CommentBrowser_next_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_CommentBrowser_next_Base> Callback_CommentBrowser_nextPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_refresh.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_refresh.
 */
class Callback_Session_refresh_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_refresh_Base> Callback_Session_refreshPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_getCurrentUser.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getCurrentUser.
 */
class Callback_Session_getCurrentUser_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_getCurrentUser_Base> Callback_Session_getCurrentUserPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_getCurrentUserGroup.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getCurrentUserGroup.
 */
class Callback_Session_getCurrentUserGroup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_getCurrentUserGroup_Base> Callback_Session_getCurrentUserGroupPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_setPages.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setPages.
 */
class Callback_Session_setPages_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_setPages_Base> Callback_Session_setPagesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_getPages.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getPages.
 */
class Callback_Session_getPages_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_getPages_Base> Callback_Session_getPagesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_setContentCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setContentCategories.
 */
class Callback_Session_setContentCategories_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_setContentCategories_Base> Callback_Session_setContentCategoriesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_getContentCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getContentCategories.
 */
class Callback_Session_getContentCategories_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_getContentCategories_Base> Callback_Session_getContentCategoriesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_setExtraCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setExtraCategories.
 */
class Callback_Session_setExtraCategories_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_setExtraCategories_Base> Callback_Session_setExtraCategoriesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_getExtraCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getExtraCategories.
 */
class Callback_Session_getExtraCategories_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_getExtraCategories_Base> Callback_Session_getExtraCategoriesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_setUniformInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setUniformInfo.
 */
class Callback_Session_setUniformInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_setUniformInfo_Base> Callback_Session_setUniformInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_getUniformInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getUniformInfo.
 */
class Callback_Session_getUniformInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_getUniformInfo_Base> Callback_Session_getUniformInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_browseContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseContent.
 */
class Callback_Session_browseContent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_browseContent_Base> Callback_Session_browseContentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_browseContentByParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseContentByParentId.
 */
class Callback_Session_browseContentByParentId_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_browseContentByParentId_Base> Callback_Session_browseContentByParentIdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_getContentInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getContentInfo.
 */
class Callback_Session_getContentInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_getContentInfo_Base> Callback_Session_getContentInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_downloadContentImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadContentImage.
 */
class Callback_Session_downloadContentImage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_downloadContentImage_Base> Callback_Session_downloadContentImagePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_downloadContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadContent.
 */
class Callback_Session_downloadContent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_downloadContent_Base> Callback_Session_downloadContentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_submitContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitContent.
 */
class Callback_Session_submitContent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_submitContent_Base> Callback_Session_submitContentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_copyContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_copyContent.
 */
class Callback_Session_copyContent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_copyContent_Base> Callback_Session_copyContentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_editContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_editContent.
 */
class Callback_Session_editContent_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_editContent_Base> Callback_Session_editContentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_changeContentState.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeContentState.
 */
class Callback_Session_changeContentState_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_changeContentState_Base> Callback_Session_changeContentStatePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_changeContentDisplayPriority.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeContentDisplayPriority.
 */
class Callback_Session_changeContentDisplayPriority_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_changeContentDisplayPriority_Base> Callback_Session_changeContentDisplayPriorityPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_browseEngineVersions.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseEngineVersions.
 */
class Callback_Session_browseEngineVersions_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_browseEngineVersions_Base> Callback_Session_browseEngineVersionsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_downloadEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadEngineVersion.
 */
class Callback_Session_downloadEngineVersion_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_downloadEngineVersion_Base> Callback_Session_downloadEngineVersionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_removeEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeEngineVersion.
 */
class Callback_Session_removeEngineVersion_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_removeEngineVersion_Base> Callback_Session_removeEngineVersionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_submitEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitEngineVersion.
 */
class Callback_Session_submitEngineVersion_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_submitEngineVersion_Base> Callback_Session_submitEngineVersionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_updateEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_updateEngineVersion.
 */
class Callback_Session_updateEngineVersion_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_updateEngineVersion_Base> Callback_Session_updateEngineVersionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_getEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getEngineVersion.
 */
class Callback_Session_getEngineVersion_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_getEngineVersion_Base> Callback_Session_getEngineVersionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_changeEngineVersionDisplayPriority.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeEngineVersionDisplayPriority.
 */
class Callback_Session_changeEngineVersionDisplayPriority_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_changeEngineVersionDisplayPriority_Base> Callback_Session_changeEngineVersionDisplayPriorityPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_browseExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseExtra.
 */
class Callback_Session_browseExtra_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_browseExtra_Base> Callback_Session_browseExtraPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_browseExtraByParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseExtraByParentId.
 */
class Callback_Session_browseExtraByParentId_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_browseExtraByParentId_Base> Callback_Session_browseExtraByParentIdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_getExtraInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getExtraInfo.
 */
class Callback_Session_getExtraInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_getExtraInfo_Base> Callback_Session_getExtraInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_downloadExtraImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadExtraImage.
 */
class Callback_Session_downloadExtraImage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_downloadExtraImage_Base> Callback_Session_downloadExtraImagePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_downloadExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadExtra.
 */
class Callback_Session_downloadExtra_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_downloadExtra_Base> Callback_Session_downloadExtraPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_submitExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitExtra.
 */
class Callback_Session_submitExtra_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_submitExtra_Base> Callback_Session_submitExtraPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_updateExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_updateExtra.
 */
class Callback_Session_updateExtra_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_updateExtra_Base> Callback_Session_updateExtraPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_changeExtraState.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeExtraState.
 */
class Callback_Session_changeExtraState_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_changeExtraState_Base> Callback_Session_changeExtraStatePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_changeExtraDisplayPriority.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeExtraDisplayPriority.
 */
class Callback_Session_changeExtraDisplayPriority_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_changeExtraDisplayPriority_Base> Callback_Session_changeExtraDisplayPriorityPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_browseClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseClient.
 */
class Callback_Session_browseClient_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_browseClient_Base> Callback_Session_browseClientPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_getClientInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getClientInfo.
 */
class Callback_Session_getClientInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_getClientInfo_Base> Callback_Session_getClientInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_submitClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitClient.
 */
class Callback_Session_submitClient_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_submitClient_Base> Callback_Session_submitClientPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_updateClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_updateClient.
 */
class Callback_Session_updateClient_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_updateClient_Base> Callback_Session_updateClientPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_removeClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeClient.
 */
class Callback_Session_removeClient_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_removeClient_Base> Callback_Session_removeClientPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_browseUsers.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseUsers.
 */
class Callback_Session_browseUsers_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_browseUsers_Base> Callback_Session_browseUsersPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_setUserGroup.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setUserGroup.
 */
class Callback_Session_setUserGroup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_setUserGroup_Base> Callback_Session_setUserGroupPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_removeUser.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeUser.
 */
class Callback_Session_removeUser_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_removeUser_Base> Callback_Session_removeUserPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_browseComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseComment.
 */
class Callback_Session_browseComment_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_browseComment_Base> Callback_Session_browseCommentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_getComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getComment.
 */
class Callback_Session_getComment_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_getComment_Base> Callback_Session_getCommentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_addComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_addComment.
 */
class Callback_Session_addComment_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_addComment_Base> Callback_Session_addCommentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_editComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_editComment.
 */
class Callback_Session_editComment_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_editComment_Base> Callback_Session_editCommentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_removeComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeComment.
 */
class Callback_Session_removeComment_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_removeComment_Base> Callback_Session_removeCommentPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_queryDownloadCount.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_queryDownloadCount.
 */
class Callback_Session_queryDownloadCount_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_queryDownloadCount_Base> Callback_Session_queryDownloadCountPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_isUserOnline.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_isUserOnline.
 */
class Callback_Session_isUserOnline_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_isUserOnline_Base> Callback_Session_isUserOnlinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::Rpc::Session::begin_onlineUserCount.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_onlineUserCount.
 */
class Callback_Session_onlineUserCount_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Session_onlineUserCount_Base> Callback_Session_onlineUserCountPtr;

}

namespace IceProxy
{

namespace Rpc
{

class ContentBrowser : public virtual ::Ice::Proxy<ContentBrowser, ::IceProxy::Rpc::ManagedObject>
{
public:

    ::Rpc::ErrorCode next(::Ice::Int n, ::Rpc::ContentItemSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_next(items, _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Rpc::Callback_ContentBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Rpc::Callback_ContentBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_next(::Rpc::ContentItemSeq& items, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_next(::Rpc::ContentItemSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_next(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class EngineVersionBrowser : public virtual ::Ice::Proxy<EngineVersionBrowser, ::IceProxy::Rpc::ManagedObject>
{
public:

    ::Rpc::ErrorCode next(::Ice::Int n, ::Rpc::EngineVersionSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_next(items, _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Rpc::Callback_EngineVersionBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Rpc::Callback_EngineVersionBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_next(::Rpc::EngineVersionSeq& items, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_next(::Rpc::EngineVersionSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_next(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class ExtraBrowser : public virtual ::Ice::Proxy<ExtraBrowser, ::IceProxy::Rpc::ManagedObject>
{
public:

    ::Rpc::ErrorCode next(::Ice::Int n, ::Rpc::ExtraInfoSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_next(items, _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Rpc::Callback_ExtraBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Rpc::Callback_ExtraBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_next(::Rpc::ExtraInfoSeq& items, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_next(::Rpc::ExtraInfoSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_next(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class UserBrowser : public virtual ::Ice::Proxy<UserBrowser, ::IceProxy::Rpc::ManagedObject>
{
public:

    ::Rpc::ErrorCode next(::Ice::Int n, ::Rpc::UserSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_next(items, _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Rpc::Callback_UserBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Rpc::Callback_UserBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_next(::Rpc::UserSeq& items, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_next(::Rpc::UserSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_next(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class ContentSubmitter : public virtual ::Ice::Proxy<ContentSubmitter, ::IceProxy::Rpc::ManagedObject>
{
public:

    ::Rpc::ErrorCode getId(::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getId(id, _iceI_begin_getId(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getId(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getId(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getId(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getId(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getId(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getId(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getId(const ::Rpc::Callback_ContentSubmitter_getIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getId(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getId(const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_getIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getId(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getId(::std::string& id, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getId(::std::string& iceP_id, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getId(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setTitle(const ::std::string& title, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setTitle(_iceI_begin_setTitle(title, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setTitle(const ::std::string& title, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setTitle(title, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTitle(const ::std::string& title, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTitle(title, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTitle(const ::std::string& title, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTitle(title, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTitle(const ::std::string& title, const ::Rpc::Callback_ContentSubmitter_setTitlePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTitle(title, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTitle(const ::std::string& title, const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_setTitlePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTitle(title, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setTitle(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setTitle(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setPage(const ::std::string& page, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setPage(_iceI_begin_setPage(page, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setPage(const ::std::string& page, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setPage(page, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPage(const ::std::string& page, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPage(page, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPage(const ::std::string& page, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPage(page, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPage(const ::std::string& page, const ::Rpc::Callback_ContentSubmitter_setPagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPage(page, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPage(const ::std::string& page, const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_setPagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPage(page, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setPage(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setPage(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setCategory(const ::std::string& category, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setCategory(_iceI_begin_setCategory(category, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setCategory(const ::std::string& category, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setCategory(category, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCategory(const ::std::string& category, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCategory(category, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setCategory(const ::std::string& category, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCategory(category, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setCategory(const ::std::string& category, const ::Rpc::Callback_ContentSubmitter_setCategoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCategory(category, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setCategory(const ::std::string& category, const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_setCategoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCategory(category, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setCategory(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setCategory(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setEngine(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setEngine(_iceI_begin_setEngine(name, version, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setEngine(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setEngine(name, version, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setEngine(const ::std::string& name, const ::std::string& version, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setEngine(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setEngine(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setEngine(name, version, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setEngine(const ::std::string& name, const ::std::string& version, const ::Rpc::Callback_ContentSubmitter_setEnginePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setEngine(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setEngine(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_setEnginePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setEngine(name, version, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setEngine(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setEngine(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setStartup(const ::std::string& startup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setStartup(_iceI_begin_setStartup(startup, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setStartup(const ::std::string& startup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setStartup(startup, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setStartup(const ::std::string& startup, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setStartup(startup, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setStartup(const ::std::string& startup, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setStartup(startup, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setStartup(const ::std::string& startup, const ::Rpc::Callback_ContentSubmitter_setStartupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setStartup(startup, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setStartup(const ::std::string& startup, const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_setStartupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setStartup(startup, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setStartup(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setStartup(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setParentId(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setParentId(_iceI_begin_setParentId(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setParentId(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setParentId(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setParentId(const ::std::string& id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setParentId(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setParentId(const ::std::string& id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setParentId(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setParentId(const ::std::string& id, const ::Rpc::Callback_ContentSubmitter_setParentIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setParentId(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setParentId(const ::std::string& id, const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_setParentIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setParentId(id, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setParentId(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setParentId(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setVideo(const ::std::string& video, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setVideo(_iceI_begin_setVideo(video, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setVideo(const ::std::string& video, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setVideo(video, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setVideo(const ::std::string& video, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setVideo(video, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setVideo(const ::std::string& video, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setVideo(video, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setVideo(const ::std::string& video, const ::Rpc::Callback_ContentSubmitter_setVideoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setVideo(video, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setVideo(const ::std::string& video, const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_setVideoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setVideo(video, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setVideo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setVideo(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setDescription(const ::std::string& description, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setDescription(_iceI_begin_setDescription(description, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setDescription(const ::std::string& description, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setDescription(description, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setDescription(const ::std::string& description, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setDescription(description, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setDescription(const ::std::string& description, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setDescription(description, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setDescription(const ::std::string& description, const ::Rpc::Callback_ContentSubmitter_setDescriptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setDescription(description, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setDescription(const ::std::string& description, const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_setDescriptionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setDescription(description, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setDescription(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setDescription(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode uploadImage(::Ice::Int index, ::Rpc::UploaderPrx& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_uploadImage(uploader, _iceI_begin_uploadImage(index, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_uploadImage(::Ice::Int index, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_uploadImage(index, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_uploadImage(::Ice::Int index, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadImage(index, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadImage(::Ice::Int index, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadImage(index, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadImage(::Ice::Int index, const ::Rpc::Callback_ContentSubmitter_uploadImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadImage(index, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadImage(::Ice::Int index, const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_uploadImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadImage(index, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_uploadImage(::Rpc::UploaderPrx& uploader, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_uploadImage(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_uploadImage(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode uploadContent(::Rpc::UploaderPrx& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_uploadContent(uploader, _iceI_begin_uploadContent(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_uploadContent(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_uploadContent(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_uploadContent(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadContent(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadContent(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadContent(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadContent(const ::Rpc::Callback_ContentSubmitter_uploadContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadContent(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadContent(const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_uploadContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadContent(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_uploadContent(::Rpc::UploaderPrx& uploader, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_uploadContent(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_uploadContent(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_cancel(_iceI_begin_cancel(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_cancel(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Rpc::Callback_ContentSubmitter_cancelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_cancelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(context, cb, cookie);
    }

    void end_cancel(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_cancel(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_finish(_iceI_begin_finish(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_finish(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Rpc::Callback_ContentSubmitter_finishPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context, const ::Rpc::Callback_ContentSubmitter_finishPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_finish(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_finish(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class EngineVersionSubmitter : public virtual ::Ice::Proxy<EngineVersionSubmitter, ::IceProxy::Rpc::ManagedObject>
{
public:

    ::Rpc::ErrorCode setSetup(const ::std::string& setup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setSetup(_iceI_begin_setSetup(setup, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setSetup(const ::std::string& setup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setSetup(setup, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSetup(const ::std::string& setup, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSetup(setup, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setSetup(const ::std::string& setup, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSetup(setup, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setSetup(const ::std::string& setup, const ::Rpc::Callback_EngineVersionSubmitter_setSetupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSetup(setup, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setSetup(const ::std::string& setup, const ::Ice::Context& context, const ::Rpc::Callback_EngineVersionSubmitter_setSetupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSetup(setup, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setSetup(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setSetup(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setUnSetup(const ::std::string& unsetup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setUnSetup(_iceI_begin_setUnSetup(unsetup, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setUnSetup(const ::std::string& unsetup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setUnSetup(unsetup, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setUnSetup(const ::std::string& unsetup, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUnSetup(unsetup, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setUnSetup(const ::std::string& unsetup, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUnSetup(unsetup, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setUnSetup(const ::std::string& unsetup, const ::Rpc::Callback_EngineVersionSubmitter_setUnSetupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUnSetup(unsetup, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setUnSetup(const ::std::string& unsetup, const ::Ice::Context& context, const ::Rpc::Callback_EngineVersionSubmitter_setUnSetupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUnSetup(unsetup, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setUnSetup(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setUnSetup(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setInfo(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setInfo(_iceI_begin_setInfo(info, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setInfo(info, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Rpc::Callback_EngineVersionSubmitter_setInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::Context& context, const ::Rpc::Callback_EngineVersionSubmitter_setInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setInfo(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode uploadEngine(::Rpc::UploaderPrx& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_uploadEngine(uploader, _iceI_begin_uploadEngine(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_uploadEngine(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_uploadEngine(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_uploadEngine(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadEngine(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadEngine(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadEngine(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadEngine(const ::Rpc::Callback_EngineVersionSubmitter_uploadEnginePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadEngine(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadEngine(const ::Ice::Context& context, const ::Rpc::Callback_EngineVersionSubmitter_uploadEnginePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadEngine(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_uploadEngine(::Rpc::UploaderPrx& uploader, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_uploadEngine(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_uploadEngine(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_cancel(_iceI_begin_cancel(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_cancel(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Rpc::Callback_EngineVersionSubmitter_cancelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context, const ::Rpc::Callback_EngineVersionSubmitter_cancelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(context, cb, cookie);
    }

    void end_cancel(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_cancel(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_finish(_iceI_begin_finish(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_finish(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Rpc::Callback_EngineVersionSubmitter_finishPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context, const ::Rpc::Callback_EngineVersionSubmitter_finishPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_finish(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_finish(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class ExtraSubmitter : public virtual ::Ice::Proxy<ExtraSubmitter, ::IceProxy::Rpc::ManagedObject>
{
public:

    ::Rpc::ErrorCode setParentId(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setParentId(_iceI_begin_setParentId(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setParentId(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setParentId(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setParentId(const ::std::string& id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setParentId(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setParentId(const ::std::string& id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setParentId(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setParentId(const ::std::string& id, const ::Rpc::Callback_ExtraSubmitter_setParentIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setParentId(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setParentId(const ::std::string& id, const ::Ice::Context& context, const ::Rpc::Callback_ExtraSubmitter_setParentIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setParentId(id, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setParentId(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setParentId(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setTitle(const ::std::string& title, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setTitle(_iceI_begin_setTitle(title, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setTitle(const ::std::string& title, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setTitle(title, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTitle(const ::std::string& title, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTitle(title, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTitle(const ::std::string& title, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTitle(title, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTitle(const ::std::string& title, const ::Rpc::Callback_ExtraSubmitter_setTitlePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTitle(title, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTitle(const ::std::string& title, const ::Ice::Context& context, const ::Rpc::Callback_ExtraSubmitter_setTitlePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTitle(title, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setTitle(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setTitle(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setSetup(const ::std::string& setup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setSetup(_iceI_begin_setSetup(setup, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setSetup(const ::std::string& setup, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setSetup(setup, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setSetup(const ::std::string& setup, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSetup(setup, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setSetup(const ::std::string& setup, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSetup(setup, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setSetup(const ::std::string& setup, const ::Rpc::Callback_ExtraSubmitter_setSetupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSetup(setup, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setSetup(const ::std::string& setup, const ::Ice::Context& context, const ::Rpc::Callback_ExtraSubmitter_setSetupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setSetup(setup, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setSetup(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setSetup(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setCategory(const ::std::string& category, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setCategory(_iceI_begin_setCategory(category, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setCategory(const ::std::string& category, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setCategory(category, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setCategory(const ::std::string& category, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCategory(category, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setCategory(const ::std::string& category, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCategory(category, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setCategory(const ::std::string& category, const ::Rpc::Callback_ExtraSubmitter_setCategoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCategory(category, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setCategory(const ::std::string& category, const ::Ice::Context& context, const ::Rpc::Callback_ExtraSubmitter_setCategoryPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setCategory(category, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setCategory(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setCategory(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setInfo(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setInfo(_iceI_begin_setInfo(info, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setInfo(info, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Rpc::Callback_ExtraSubmitter_setInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::Context& context, const ::Rpc::Callback_ExtraSubmitter_setInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setInfo(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode uploadImage(::Rpc::UploaderPrx& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_uploadImage(uploader, _iceI_begin_uploadImage(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_uploadImage(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_uploadImage(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_uploadImage(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadImage(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadImage(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadImage(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadImage(const ::Rpc::Callback_ExtraSubmitter_uploadImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadImage(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadImage(const ::Ice::Context& context, const ::Rpc::Callback_ExtraSubmitter_uploadImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadImage(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_uploadImage(::Rpc::UploaderPrx& uploader, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_uploadImage(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_uploadImage(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode uploadExtra(::Rpc::UploaderPrx& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_uploadExtra(uploader, _iceI_begin_uploadExtra(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_uploadExtra(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_uploadExtra(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_uploadExtra(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadExtra(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadExtra(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadExtra(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadExtra(const ::Rpc::Callback_ExtraSubmitter_uploadExtraPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadExtra(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadExtra(const ::Ice::Context& context, const ::Rpc::Callback_ExtraSubmitter_uploadExtraPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadExtra(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_uploadExtra(::Rpc::UploaderPrx& uploader, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_uploadExtra(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_uploadExtra(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_cancel(_iceI_begin_cancel(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_cancel(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Rpc::Callback_ExtraSubmitter_cancelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context, const ::Rpc::Callback_ExtraSubmitter_cancelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(context, cb, cookie);
    }

    void end_cancel(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_cancel(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_finish(_iceI_begin_finish(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_finish(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Rpc::Callback_ExtraSubmitter_finishPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context, const ::Rpc::Callback_ExtraSubmitter_finishPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_finish(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_finish(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class ClientBrowser : public virtual ::Ice::Proxy<ClientBrowser, ::IceProxy::Rpc::ManagedObject>
{
public:

    ::Rpc::ErrorCode next(::Ice::Int n, ::Rpc::ClientInfoSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_next(items, _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Rpc::Callback_ClientBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Rpc::Callback_ClientBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_next(::Rpc::ClientInfoSeq& items, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_next(::Rpc::ClientInfoSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_next(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class ClientSubmitter : public virtual ::Ice::Proxy<ClientSubmitter, ::IceProxy::Rpc::ManagedObject>
{
public:

    ::Rpc::ErrorCode setInfo(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setInfo(_iceI_begin_setInfo(info, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setInfo(info, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Rpc::Callback_ClientSubmitter_setInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setInfo(const ::std::string& info, const ::Ice::Context& context, const ::Rpc::Callback_ClientSubmitter_setInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setInfo(info, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setInfo(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode uploadClient(::Rpc::UploaderPrx& uploader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_uploadClient(uploader, _iceI_begin_uploadClient(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_uploadClient(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_uploadClient(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_uploadClient(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadClient(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadClient(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadClient(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadClient(const ::Rpc::Callback_ClientSubmitter_uploadClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadClient(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_uploadClient(const ::Ice::Context& context, const ::Rpc::Callback_ClientSubmitter_uploadClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_uploadClient(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_uploadClient(::Rpc::UploaderPrx& uploader, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_uploadClient(::Rpc::UploaderPrx& iceP_uploader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_uploadClient(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_cancel(_iceI_begin_cancel(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_cancel(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Rpc::Callback_ClientSubmitter_cancelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancel(const ::Ice::Context& context, const ::Rpc::Callback_ClientSubmitter_cancelPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancel(context, cb, cookie);
    }

    void end_cancel(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_cancel(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_finish(_iceI_begin_finish(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_finish(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Rpc::Callback_ClientSubmitter_finishPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_finish(const ::Ice::Context& context, const ::Rpc::Callback_ClientSubmitter_finishPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_finish(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_finish(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_finish(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class CommentBrowser : public virtual ::Ice::Proxy<CommentBrowser, ::IceProxy::Rpc::ManagedObject>
{
public:

    ::Rpc::ErrorCode next(::Ice::Int n, ::Rpc::CommentSeq& items, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_next(items, _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_next(n, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Rpc::Callback_CommentBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_next(::Ice::Int n, const ::Ice::Context& context, const ::Rpc::Callback_CommentBrowser_nextPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_next(n, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_next(::Rpc::CommentSeq& items, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_next(::Rpc::CommentSeq& iceP_items, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_next(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Session : public virtual ::Ice::Proxy<Session, ::IceProxy::Rpc::ManagedObject>
{
public:

    void refresh(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_refresh(_iceI_begin_refresh(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_refresh(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_refresh(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_refresh(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_refresh(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_refresh(const ::Rpc::Callback_Session_refreshPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_refresh(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_refresh(const ::Ice::Context& context, const ::Rpc::Callback_Session_refreshPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_refresh(context, cb, cookie);
    }

    void end_refresh(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_refresh(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode getCurrentUser(::std::string& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getCurrentUser(user, _iceI_begin_getCurrentUser(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getCurrentUser(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getCurrentUser(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCurrentUser(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCurrentUser(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getCurrentUser(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCurrentUser(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getCurrentUser(const ::Rpc::Callback_Session_getCurrentUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCurrentUser(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getCurrentUser(const ::Ice::Context& context, const ::Rpc::Callback_Session_getCurrentUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCurrentUser(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getCurrentUser(::std::string& user, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getCurrentUser(::std::string& iceP_user, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getCurrentUser(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode getCurrentUserGroup(::std::string& group, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getCurrentUserGroup(group, _iceI_begin_getCurrentUserGroup(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getCurrentUserGroup(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getCurrentUserGroup(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCurrentUserGroup(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCurrentUserGroup(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getCurrentUserGroup(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCurrentUserGroup(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getCurrentUserGroup(const ::Rpc::Callback_Session_getCurrentUserGroupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCurrentUserGroup(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getCurrentUserGroup(const ::Ice::Context& context, const ::Rpc::Callback_Session_getCurrentUserGroupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getCurrentUserGroup(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getCurrentUserGroup(::std::string& group, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getCurrentUserGroup(::std::string& iceP_group, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getCurrentUserGroup(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setPages(const ::Rpc::StringSeq& pages, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setPages(_iceI_begin_setPages(pages, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setPages(const ::Rpc::StringSeq& pages, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setPages(pages, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPages(const ::Rpc::StringSeq& pages, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPages(pages, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPages(const ::Rpc::StringSeq& pages, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPages(pages, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPages(const ::Rpc::StringSeq& pages, const ::Rpc::Callback_Session_setPagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPages(pages, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setPages(const ::Rpc::StringSeq& pages, const ::Ice::Context& context, const ::Rpc::Callback_Session_setPagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setPages(pages, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setPages(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setPages(const ::Rpc::StringSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode getPages(::Rpc::StringSeq& pages, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getPages(pages, _iceI_begin_getPages(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getPages(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getPages(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPages(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPages(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPages(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPages(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPages(const ::Rpc::Callback_Session_getPagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPages(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPages(const ::Ice::Context& context, const ::Rpc::Callback_Session_getPagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPages(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getPages(::Rpc::StringSeq& pages, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getPages(::Rpc::StringSeq& iceP_pages, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getPages(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setContentCategories(const ::Rpc::StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setContentCategories(_iceI_begin_setContentCategories(categories, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setContentCategories(const ::Rpc::StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setContentCategories(categories, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setContentCategories(const ::Rpc::StringSeq& categories, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setContentCategories(categories, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setContentCategories(const ::Rpc::StringSeq& categories, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setContentCategories(categories, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setContentCategories(const ::Rpc::StringSeq& categories, const ::Rpc::Callback_Session_setContentCategoriesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setContentCategories(categories, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setContentCategories(const ::Rpc::StringSeq& categories, const ::Ice::Context& context, const ::Rpc::Callback_Session_setContentCategoriesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setContentCategories(categories, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setContentCategories(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setContentCategories(const ::Rpc::StringSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode getContentCategories(::Rpc::StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getContentCategories(categories, _iceI_begin_getContentCategories(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getContentCategories(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getContentCategories(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getContentCategories(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getContentCategories(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getContentCategories(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getContentCategories(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getContentCategories(const ::Rpc::Callback_Session_getContentCategoriesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getContentCategories(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getContentCategories(const ::Ice::Context& context, const ::Rpc::Callback_Session_getContentCategoriesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getContentCategories(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getContentCategories(::Rpc::StringSeq& categories, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getContentCategories(::Rpc::StringSeq& iceP_categories, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getContentCategories(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setExtraCategories(const ::Rpc::StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setExtraCategories(_iceI_begin_setExtraCategories(categories, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setExtraCategories(const ::Rpc::StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setExtraCategories(categories, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setExtraCategories(const ::Rpc::StringSeq& categories, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setExtraCategories(categories, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setExtraCategories(const ::Rpc::StringSeq& categories, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setExtraCategories(categories, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setExtraCategories(const ::Rpc::StringSeq& categories, const ::Rpc::Callback_Session_setExtraCategoriesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setExtraCategories(categories, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setExtraCategories(const ::Rpc::StringSeq& categories, const ::Ice::Context& context, const ::Rpc::Callback_Session_setExtraCategoriesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setExtraCategories(categories, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setExtraCategories(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setExtraCategories(const ::Rpc::StringSeq&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode getExtraCategories(::Rpc::StringSeq& categories, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getExtraCategories(categories, _iceI_begin_getExtraCategories(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getExtraCategories(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getExtraCategories(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getExtraCategories(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getExtraCategories(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getExtraCategories(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getExtraCategories(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getExtraCategories(const ::Rpc::Callback_Session_getExtraCategoriesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getExtraCategories(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getExtraCategories(const ::Ice::Context& context, const ::Rpc::Callback_Session_getExtraCategoriesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getExtraCategories(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getExtraCategories(::Rpc::StringSeq& categories, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getExtraCategories(::Rpc::StringSeq& iceP_categories, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getExtraCategories(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setUniformInfo(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setUniformInfo(_iceI_begin_setUniformInfo(key, value, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setUniformInfo(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setUniformInfo(key, value, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setUniformInfo(const ::std::string& key, const ::std::string& value, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUniformInfo(key, value, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setUniformInfo(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUniformInfo(key, value, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setUniformInfo(const ::std::string& key, const ::std::string& value, const ::Rpc::Callback_Session_setUniformInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUniformInfo(key, value, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setUniformInfo(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context, const ::Rpc::Callback_Session_setUniformInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUniformInfo(key, value, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setUniformInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setUniformInfo(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode getUniformInfo(const ::std::string& key, ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getUniformInfo(value, _iceI_begin_getUniformInfo(key, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getUniformInfo(const ::std::string& key, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getUniformInfo(key, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUniformInfo(const ::std::string& key, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getUniformInfo(key, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getUniformInfo(const ::std::string& key, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getUniformInfo(key, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getUniformInfo(const ::std::string& key, const ::Rpc::Callback_Session_getUniformInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getUniformInfo(key, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getUniformInfo(const ::std::string& key, const ::Ice::Context& context, const ::Rpc::Callback_Session_getUniformInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getUniformInfo(key, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getUniformInfo(::std::string& value, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getUniformInfo(::std::string& iceP_value, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getUniformInfo(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode browseContent(const ::std::string& page, const ::std::string& category, const ::std::string& search, ::Rpc::ContentBrowserPrx& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_browseContent(browser, _iceI_begin_browseContent(page, category, search, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_browseContent(const ::std::string& page, const ::std::string& category, const ::std::string& search, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_browseContent(page, category, search, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_browseContent(const ::std::string& page, const ::std::string& category, const ::std::string& search, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseContent(page, category, search, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseContent(const ::std::string& page, const ::std::string& category, const ::std::string& search, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseContent(page, category, search, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseContent(const ::std::string& page, const ::std::string& category, const ::std::string& search, const ::Rpc::Callback_Session_browseContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseContent(page, category, search, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseContent(const ::std::string& page, const ::std::string& category, const ::std::string& search, const ::Ice::Context& context, const ::Rpc::Callback_Session_browseContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseContent(page, category, search, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_browseContent(::Rpc::ContentBrowserPrx& browser, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_browseContent(::Rpc::ContentBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_browseContent(const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode browseContentByParentId(const ::std::string& parentId, ::Rpc::ContentBrowserPrx& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_browseContentByParentId(browser, _iceI_begin_browseContentByParentId(parentId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_browseContentByParentId(const ::std::string& parentId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_browseContentByParentId(parentId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_browseContentByParentId(const ::std::string& parentId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseContentByParentId(parentId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseContentByParentId(const ::std::string& parentId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseContentByParentId(parentId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseContentByParentId(const ::std::string& parentId, const ::Rpc::Callback_Session_browseContentByParentIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseContentByParentId(parentId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseContentByParentId(const ::std::string& parentId, const ::Ice::Context& context, const ::Rpc::Callback_Session_browseContentByParentIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseContentByParentId(parentId, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_browseContentByParentId(::Rpc::ContentBrowserPrx& browser, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_browseContentByParentId(::Rpc::ContentBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_browseContentByParentId(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode getContentInfo(const ::std::string& id, ::Rpc::ContentInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getContentInfo(info, _iceI_begin_getContentInfo(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getContentInfo(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getContentInfo(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getContentInfo(const ::std::string& id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getContentInfo(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getContentInfo(const ::std::string& id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getContentInfo(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getContentInfo(const ::std::string& id, const ::Rpc::Callback_Session_getContentInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getContentInfo(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getContentInfo(const ::std::string& id, const ::Ice::Context& context, const ::Rpc::Callback_Session_getContentInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getContentInfo(id, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getContentInfo(::Rpc::ContentInfo& info, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getContentInfo(::Rpc::ContentInfo& iceP_info, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getContentInfo(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode downloadContentImage(const ::std::string& id, ::Ice::Int index, ::Rpc::DownloaderPrx& downloader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_downloadContentImage(downloader, _iceI_begin_downloadContentImage(id, index, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_downloadContentImage(const ::std::string& id, ::Ice::Int index, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_downloadContentImage(id, index, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_downloadContentImage(const ::std::string& id, ::Ice::Int index, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadContentImage(id, index, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadContentImage(const ::std::string& id, ::Ice::Int index, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadContentImage(id, index, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadContentImage(const ::std::string& id, ::Ice::Int index, const ::Rpc::Callback_Session_downloadContentImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadContentImage(id, index, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadContentImage(const ::std::string& id, ::Ice::Int index, const ::Ice::Context& context, const ::Rpc::Callback_Session_downloadContentImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadContentImage(id, index, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_downloadContentImage(::Rpc::DownloaderPrx& downloader, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_downloadContentImage(::Rpc::DownloaderPrx& iceP_downloader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_downloadContentImage(const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode downloadContent(const ::std::string& id, ::Rpc::DownloaderPrx& downloader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_downloadContent(downloader, _iceI_begin_downloadContent(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_downloadContent(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_downloadContent(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_downloadContent(const ::std::string& id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadContent(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadContent(const ::std::string& id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadContent(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadContent(const ::std::string& id, const ::Rpc::Callback_Session_downloadContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadContent(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadContent(const ::std::string& id, const ::Ice::Context& context, const ::Rpc::Callback_Session_downloadContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadContent(id, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_downloadContent(::Rpc::DownloaderPrx& downloader, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_downloadContent(::Rpc::DownloaderPrx& iceP_downloader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_downloadContent(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode submitContent(::Rpc::ContentSubmitterPrx& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_submitContent(submitter, _iceI_begin_submitContent(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_submitContent(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_submitContent(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_submitContent(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitContent(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitContent(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitContent(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitContent(const ::Rpc::Callback_Session_submitContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitContent(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitContent(const ::Ice::Context& context, const ::Rpc::Callback_Session_submitContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitContent(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_submitContent(::Rpc::ContentSubmitterPrx& submitter, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_submitContent(::Rpc::ContentSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_submitContent(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode copyContent(const ::std::string& id, ::Rpc::ContentSubmitterPrx& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_copyContent(submitter, _iceI_begin_copyContent(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_copyContent(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_copyContent(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copyContent(const ::std::string& id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copyContent(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_copyContent(const ::std::string& id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copyContent(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_copyContent(const ::std::string& id, const ::Rpc::Callback_Session_copyContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copyContent(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_copyContent(const ::std::string& id, const ::Ice::Context& context, const ::Rpc::Callback_Session_copyContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_copyContent(id, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_copyContent(::Rpc::ContentSubmitterPrx& submitter, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_copyContent(::Rpc::ContentSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_copyContent(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode editContent(const ::std::string& id, ::Rpc::ContentSubmitterPrx& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_editContent(submitter, _iceI_begin_editContent(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_editContent(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_editContent(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_editContent(const ::std::string& id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_editContent(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_editContent(const ::std::string& id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_editContent(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_editContent(const ::std::string& id, const ::Rpc::Callback_Session_editContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_editContent(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_editContent(const ::std::string& id, const ::Ice::Context& context, const ::Rpc::Callback_Session_editContentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_editContent(id, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_editContent(::Rpc::ContentSubmitterPrx& submitter, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_editContent(::Rpc::ContentSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_editContent(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode changeContentState(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_changeContentState(_iceI_begin_changeContentState(id, state, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_changeContentState(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_changeContentState(id, state, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_changeContentState(const ::std::string& id, const ::std::string& state, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeContentState(id, state, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeContentState(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeContentState(id, state, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeContentState(const ::std::string& id, const ::std::string& state, const ::Rpc::Callback_Session_changeContentStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeContentState(id, state, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeContentState(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context, const ::Rpc::Callback_Session_changeContentStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeContentState(id, state, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_changeContentState(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_changeContentState(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode changeContentDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_changeContentDisplayPriority(_iceI_begin_changeContentDisplayPriority(id, displayPriority, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_changeContentDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_changeContentDisplayPriority(id, displayPriority, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_changeContentDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeContentDisplayPriority(id, displayPriority, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeContentDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeContentDisplayPriority(id, displayPriority, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeContentDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Rpc::Callback_Session_changeContentDisplayPriorityPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeContentDisplayPriority(id, displayPriority, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeContentDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::Context& context, const ::Rpc::Callback_Session_changeContentDisplayPriorityPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeContentDisplayPriority(id, displayPriority, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_changeContentDisplayPriority(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_changeContentDisplayPriority(const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode browseEngineVersions(bool all, ::Rpc::EngineVersionBrowserPrx& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_browseEngineVersions(browser, _iceI_begin_browseEngineVersions(all, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_browseEngineVersions(bool all, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_browseEngineVersions(all, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_browseEngineVersions(bool all, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseEngineVersions(all, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseEngineVersions(bool all, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseEngineVersions(all, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseEngineVersions(bool all, const ::Rpc::Callback_Session_browseEngineVersionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseEngineVersions(all, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseEngineVersions(bool all, const ::Ice::Context& context, const ::Rpc::Callback_Session_browseEngineVersionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseEngineVersions(all, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_browseEngineVersions(::Rpc::EngineVersionBrowserPrx& browser, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_browseEngineVersions(::Rpc::EngineVersionBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_browseEngineVersions(bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode downloadEngineVersion(const ::std::string& name, const ::std::string& version, ::Rpc::DownloaderPrx& downloader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_downloadEngineVersion(downloader, _iceI_begin_downloadEngineVersion(name, version, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_downloadEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_downloadEngineVersion(name, version, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_downloadEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadEngineVersion(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadEngineVersion(name, version, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadEngineVersion(const ::std::string& name, const ::std::string& version, const ::Rpc::Callback_Session_downloadEngineVersionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadEngineVersion(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Rpc::Callback_Session_downloadEngineVersionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadEngineVersion(name, version, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_downloadEngineVersion(::Rpc::DownloaderPrx& downloader, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_downloadEngineVersion(::Rpc::DownloaderPrx& iceP_downloader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_downloadEngineVersion(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode removeEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_removeEngineVersion(_iceI_begin_removeEngineVersion(name, version, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_removeEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_removeEngineVersion(name, version, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeEngineVersion(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeEngineVersion(name, version, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeEngineVersion(const ::std::string& name, const ::std::string& version, const ::Rpc::Callback_Session_removeEngineVersionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeEngineVersion(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Rpc::Callback_Session_removeEngineVersionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeEngineVersion(name, version, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_removeEngineVersion(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_removeEngineVersion(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode submitEngineVersion(const ::std::string& name, const ::std::string& version, ::Rpc::EngineVersionSubmitterPrx& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_submitEngineVersion(submitter, _iceI_begin_submitEngineVersion(name, version, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_submitEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_submitEngineVersion(name, version, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_submitEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitEngineVersion(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitEngineVersion(name, version, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitEngineVersion(const ::std::string& name, const ::std::string& version, const ::Rpc::Callback_Session_submitEngineVersionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitEngineVersion(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Rpc::Callback_Session_submitEngineVersionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitEngineVersion(name, version, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_submitEngineVersion(::Rpc::EngineVersionSubmitterPrx& submitter, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_submitEngineVersion(::Rpc::EngineVersionSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_submitEngineVersion(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode updateEngineVersion(const ::std::string& name, const ::std::string& version, ::Rpc::EngineVersionSubmitterPrx& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_updateEngineVersion(submitter, _iceI_begin_updateEngineVersion(name, version, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_updateEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_updateEngineVersion(name, version, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateEngineVersion(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateEngineVersion(name, version, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateEngineVersion(const ::std::string& name, const ::std::string& version, const ::Rpc::Callback_Session_updateEngineVersionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateEngineVersion(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Rpc::Callback_Session_updateEngineVersionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateEngineVersion(name, version, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_updateEngineVersion(::Rpc::EngineVersionSubmitterPrx& submitter, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_updateEngineVersion(::Rpc::EngineVersionSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_updateEngineVersion(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode getEngineVersion(const ::std::string& name, const ::std::string& version, ::Rpc::EngineVersionInfo& engineVersion, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getEngineVersion(engineVersion, _iceI_begin_getEngineVersion(name, version, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getEngineVersion(name, version, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEngineVersion(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEngineVersion(name, version, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEngineVersion(const ::std::string& name, const ::std::string& version, const ::Rpc::Callback_Session_getEngineVersionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEngineVersion(name, version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Context& context, const ::Rpc::Callback_Session_getEngineVersionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEngineVersion(name, version, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getEngineVersion(::Rpc::EngineVersionInfo& engineVersion, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getEngineVersion(::Rpc::EngineVersionInfo& iceP_engineVersion, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getEngineVersion(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode changeEngineVersionDisplayPriority(const ::std::string& name, const ::std::string& version, ::Ice::Int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_changeEngineVersionDisplayPriority(_iceI_begin_changeEngineVersionDisplayPriority(name, version, displayPriority, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_changeEngineVersionDisplayPriority(const ::std::string& name, const ::std::string& version, ::Ice::Int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_changeEngineVersionDisplayPriority(name, version, displayPriority, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_changeEngineVersionDisplayPriority(const ::std::string& name, const ::std::string& version, ::Ice::Int displayPriority, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeEngineVersionDisplayPriority(name, version, displayPriority, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeEngineVersionDisplayPriority(const ::std::string& name, const ::std::string& version, ::Ice::Int displayPriority, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeEngineVersionDisplayPriority(name, version, displayPriority, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeEngineVersionDisplayPriority(const ::std::string& name, const ::std::string& version, ::Ice::Int displayPriority, const ::Rpc::Callback_Session_changeEngineVersionDisplayPriorityPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeEngineVersionDisplayPriority(name, version, displayPriority, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeEngineVersionDisplayPriority(const ::std::string& name, const ::std::string& version, ::Ice::Int displayPriority, const ::Ice::Context& context, const ::Rpc::Callback_Session_changeEngineVersionDisplayPriorityPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeEngineVersionDisplayPriority(name, version, displayPriority, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_changeEngineVersionDisplayPriority(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_changeEngineVersionDisplayPriority(const ::std::string&, const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode browseExtra(const ::std::string& category, const ::std::string& search, ::Rpc::ExtraBrowserPrx& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_browseExtra(browser, _iceI_begin_browseExtra(category, search, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_browseExtra(const ::std::string& category, const ::std::string& search, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_browseExtra(category, search, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_browseExtra(const ::std::string& category, const ::std::string& search, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseExtra(category, search, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseExtra(const ::std::string& category, const ::std::string& search, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseExtra(category, search, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseExtra(const ::std::string& category, const ::std::string& search, const ::Rpc::Callback_Session_browseExtraPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseExtra(category, search, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseExtra(const ::std::string& category, const ::std::string& search, const ::Ice::Context& context, const ::Rpc::Callback_Session_browseExtraPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseExtra(category, search, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_browseExtra(::Rpc::ExtraBrowserPrx& browser, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_browseExtra(::Rpc::ExtraBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_browseExtra(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode browseExtraByParentId(const ::std::string& parentId, ::Rpc::ExtraBrowserPrx& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_browseExtraByParentId(browser, _iceI_begin_browseExtraByParentId(parentId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_browseExtraByParentId(const ::std::string& parentId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_browseExtraByParentId(parentId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_browseExtraByParentId(const ::std::string& parentId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseExtraByParentId(parentId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseExtraByParentId(const ::std::string& parentId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseExtraByParentId(parentId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseExtraByParentId(const ::std::string& parentId, const ::Rpc::Callback_Session_browseExtraByParentIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseExtraByParentId(parentId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseExtraByParentId(const ::std::string& parentId, const ::Ice::Context& context, const ::Rpc::Callback_Session_browseExtraByParentIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseExtraByParentId(parentId, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_browseExtraByParentId(::Rpc::ExtraBrowserPrx& browser, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_browseExtraByParentId(::Rpc::ExtraBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_browseExtraByParentId(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode getExtraInfo(const ::std::string& id, ::Rpc::ExtraInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getExtraInfo(info, _iceI_begin_getExtraInfo(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getExtraInfo(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getExtraInfo(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getExtraInfo(const ::std::string& id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getExtraInfo(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getExtraInfo(const ::std::string& id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getExtraInfo(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getExtraInfo(const ::std::string& id, const ::Rpc::Callback_Session_getExtraInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getExtraInfo(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getExtraInfo(const ::std::string& id, const ::Ice::Context& context, const ::Rpc::Callback_Session_getExtraInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getExtraInfo(id, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getExtraInfo(::Rpc::ExtraInfo& info, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getExtraInfo(::Rpc::ExtraInfo& iceP_info, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getExtraInfo(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode downloadExtraImage(const ::std::string& id, ::Rpc::DownloaderPrx& downloader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_downloadExtraImage(downloader, _iceI_begin_downloadExtraImage(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_downloadExtraImage(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_downloadExtraImage(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_downloadExtraImage(const ::std::string& id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadExtraImage(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadExtraImage(const ::std::string& id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadExtraImage(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadExtraImage(const ::std::string& id, const ::Rpc::Callback_Session_downloadExtraImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadExtraImage(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadExtraImage(const ::std::string& id, const ::Ice::Context& context, const ::Rpc::Callback_Session_downloadExtraImagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadExtraImage(id, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_downloadExtraImage(::Rpc::DownloaderPrx& downloader, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_downloadExtraImage(::Rpc::DownloaderPrx& iceP_downloader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_downloadExtraImage(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode downloadExtra(const ::std::string& id, ::Rpc::DownloaderPrx& downloader, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_downloadExtra(downloader, _iceI_begin_downloadExtra(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_downloadExtra(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_downloadExtra(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_downloadExtra(const ::std::string& id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadExtra(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadExtra(const ::std::string& id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadExtra(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadExtra(const ::std::string& id, const ::Rpc::Callback_Session_downloadExtraPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadExtra(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_downloadExtra(const ::std::string& id, const ::Ice::Context& context, const ::Rpc::Callback_Session_downloadExtraPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_downloadExtra(id, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_downloadExtra(::Rpc::DownloaderPrx& downloader, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_downloadExtra(::Rpc::DownloaderPrx& iceP_downloader, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_downloadExtra(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode submitExtra(::Rpc::ExtraSubmitterPrx& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_submitExtra(submitter, _iceI_begin_submitExtra(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_submitExtra(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_submitExtra(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_submitExtra(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitExtra(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitExtra(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitExtra(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitExtra(const ::Rpc::Callback_Session_submitExtraPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitExtra(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitExtra(const ::Ice::Context& context, const ::Rpc::Callback_Session_submitExtraPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitExtra(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_submitExtra(::Rpc::ExtraSubmitterPrx& submitter, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_submitExtra(::Rpc::ExtraSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_submitExtra(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode updateExtra(const ::std::string& id, ::Rpc::ExtraSubmitterPrx& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_updateExtra(submitter, _iceI_begin_updateExtra(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_updateExtra(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_updateExtra(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateExtra(const ::std::string& id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateExtra(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateExtra(const ::std::string& id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateExtra(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateExtra(const ::std::string& id, const ::Rpc::Callback_Session_updateExtraPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateExtra(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateExtra(const ::std::string& id, const ::Ice::Context& context, const ::Rpc::Callback_Session_updateExtraPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateExtra(id, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_updateExtra(::Rpc::ExtraSubmitterPrx& submitter, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_updateExtra(::Rpc::ExtraSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_updateExtra(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode changeExtraState(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_changeExtraState(_iceI_begin_changeExtraState(id, state, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_changeExtraState(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_changeExtraState(id, state, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_changeExtraState(const ::std::string& id, const ::std::string& state, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeExtraState(id, state, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeExtraState(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeExtraState(id, state, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeExtraState(const ::std::string& id, const ::std::string& state, const ::Rpc::Callback_Session_changeExtraStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeExtraState(id, state, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeExtraState(const ::std::string& id, const ::std::string& state, const ::Ice::Context& context, const ::Rpc::Callback_Session_changeExtraStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeExtraState(id, state, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_changeExtraState(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_changeExtraState(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode changeExtraDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_changeExtraDisplayPriority(_iceI_begin_changeExtraDisplayPriority(id, displayPriority, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_changeExtraDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_changeExtraDisplayPriority(id, displayPriority, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_changeExtraDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeExtraDisplayPriority(id, displayPriority, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeExtraDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeExtraDisplayPriority(id, displayPriority, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeExtraDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Rpc::Callback_Session_changeExtraDisplayPriorityPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeExtraDisplayPriority(id, displayPriority, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_changeExtraDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::Context& context, const ::Rpc::Callback_Session_changeExtraDisplayPriorityPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_changeExtraDisplayPriority(id, displayPriority, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_changeExtraDisplayPriority(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_changeExtraDisplayPriority(const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode browseClient(::Rpc::ClientBrowserPrx& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_browseClient(browser, _iceI_begin_browseClient(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_browseClient(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_browseClient(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_browseClient(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseClient(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseClient(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseClient(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseClient(const ::Rpc::Callback_Session_browseClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseClient(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseClient(const ::Ice::Context& context, const ::Rpc::Callback_Session_browseClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseClient(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_browseClient(::Rpc::ClientBrowserPrx& browser, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_browseClient(::Rpc::ClientBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_browseClient(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode getClientInfo(const ::std::string& version, ::Rpc::ClientInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getClientInfo(info, _iceI_begin_getClientInfo(version, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getClientInfo(const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getClientInfo(version, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getClientInfo(const ::std::string& version, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientInfo(version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientInfo(const ::std::string& version, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientInfo(version, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientInfo(const ::std::string& version, const ::Rpc::Callback_Session_getClientInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientInfo(version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClientInfo(const ::std::string& version, const ::Ice::Context& context, const ::Rpc::Callback_Session_getClientInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClientInfo(version, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getClientInfo(::Rpc::ClientInfo& info, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getClientInfo(::Rpc::ClientInfo& iceP_info, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getClientInfo(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode submitClient(const ::std::string& version, ::Rpc::ClientSubmitterPrx& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_submitClient(submitter, _iceI_begin_submitClient(version, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_submitClient(const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_submitClient(version, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_submitClient(const ::std::string& version, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitClient(version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitClient(const ::std::string& version, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitClient(version, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitClient(const ::std::string& version, const ::Rpc::Callback_Session_submitClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitClient(version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_submitClient(const ::std::string& version, const ::Ice::Context& context, const ::Rpc::Callback_Session_submitClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_submitClient(version, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_submitClient(::Rpc::ClientSubmitterPrx& submitter, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_submitClient(::Rpc::ClientSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_submitClient(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode updateClient(const ::std::string& version, ::Rpc::ClientSubmitterPrx& submitter, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_updateClient(submitter, _iceI_begin_updateClient(version, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_updateClient(const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_updateClient(version, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateClient(const ::std::string& version, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateClient(version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateClient(const ::std::string& version, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateClient(version, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateClient(const ::std::string& version, const ::Rpc::Callback_Session_updateClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateClient(version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateClient(const ::std::string& version, const ::Ice::Context& context, const ::Rpc::Callback_Session_updateClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateClient(version, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_updateClient(::Rpc::ClientSubmitterPrx& submitter, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_updateClient(::Rpc::ClientSubmitterPrx& iceP_submitter, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_updateClient(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode removeClient(const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_removeClient(_iceI_begin_removeClient(version, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_removeClient(const ::std::string& version, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_removeClient(version, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeClient(const ::std::string& version, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeClient(version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeClient(const ::std::string& version, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeClient(version, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeClient(const ::std::string& version, const ::Rpc::Callback_Session_removeClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeClient(version, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeClient(const ::std::string& version, const ::Ice::Context& context, const ::Rpc::Callback_Session_removeClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeClient(version, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_removeClient(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_removeClient(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode browseUsers(::Rpc::UserBrowserPrx& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_browseUsers(browser, _iceI_begin_browseUsers(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_browseUsers(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_browseUsers(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_browseUsers(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseUsers(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseUsers(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseUsers(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseUsers(const ::Rpc::Callback_Session_browseUsersPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseUsers(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseUsers(const ::Ice::Context& context, const ::Rpc::Callback_Session_browseUsersPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseUsers(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_browseUsers(::Rpc::UserBrowserPrx& browser, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_browseUsers(::Rpc::UserBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_browseUsers(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode setUserGroup(const ::std::string& username, const ::std::string& group, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setUserGroup(_iceI_begin_setUserGroup(username, group, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setUserGroup(const ::std::string& username, const ::std::string& group, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setUserGroup(username, group, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setUserGroup(const ::std::string& username, const ::std::string& group, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUserGroup(username, group, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setUserGroup(const ::std::string& username, const ::std::string& group, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUserGroup(username, group, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setUserGroup(const ::std::string& username, const ::std::string& group, const ::Rpc::Callback_Session_setUserGroupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUserGroup(username, group, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setUserGroup(const ::std::string& username, const ::std::string& group, const ::Ice::Context& context, const ::Rpc::Callback_Session_setUserGroupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setUserGroup(username, group, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_setUserGroup(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setUserGroup(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode removeUser(const ::std::string& username, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_removeUser(_iceI_begin_removeUser(username, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_removeUser(const ::std::string& username, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_removeUser(username, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeUser(const ::std::string& username, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeUser(username, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeUser(const ::std::string& username, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeUser(username, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeUser(const ::std::string& username, const ::Rpc::Callback_Session_removeUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeUser(username, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeUser(const ::std::string& username, const ::Ice::Context& context, const ::Rpc::Callback_Session_removeUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeUser(username, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_removeUser(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_removeUser(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode browseComment(const ::std::string& targetId, const ::std::string& user, ::Rpc::CommentBrowserPrx& browser, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_browseComment(browser, _iceI_begin_browseComment(targetId, user, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_browseComment(const ::std::string& targetId, const ::std::string& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_browseComment(targetId, user, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_browseComment(const ::std::string& targetId, const ::std::string& user, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseComment(targetId, user, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseComment(const ::std::string& targetId, const ::std::string& user, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseComment(targetId, user, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseComment(const ::std::string& targetId, const ::std::string& user, const ::Rpc::Callback_Session_browseCommentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseComment(targetId, user, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_browseComment(const ::std::string& targetId, const ::std::string& user, const ::Ice::Context& context, const ::Rpc::Callback_Session_browseCommentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_browseComment(targetId, user, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_browseComment(::Rpc::CommentBrowserPrx& browser, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_browseComment(::Rpc::CommentBrowserPrx& iceP_browser, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_browseComment(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode getComment(const ::std::string& targetId, ::std::string& comment, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getComment(comment, _iceI_begin_getComment(targetId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getComment(const ::std::string& targetId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getComment(targetId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getComment(const ::std::string& targetId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getComment(targetId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getComment(const ::std::string& targetId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getComment(targetId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getComment(const ::std::string& targetId, const ::Rpc::Callback_Session_getCommentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getComment(targetId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getComment(const ::std::string& targetId, const ::Ice::Context& context, const ::Rpc::Callback_Session_getCommentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getComment(targetId, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_getComment(::std::string& comment, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getComment(::std::string& iceP_comment, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getComment(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode addComment(const ::std::string& targetId, const ::std::string& comment, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_addComment(_iceI_begin_addComment(targetId, comment, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addComment(const ::std::string& targetId, const ::std::string& comment, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addComment(targetId, comment, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addComment(const ::std::string& targetId, const ::std::string& comment, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addComment(targetId, comment, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addComment(const ::std::string& targetId, const ::std::string& comment, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addComment(targetId, comment, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addComment(const ::std::string& targetId, const ::std::string& comment, const ::Rpc::Callback_Session_addCommentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addComment(targetId, comment, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addComment(const ::std::string& targetId, const ::std::string& comment, const ::Ice::Context& context, const ::Rpc::Callback_Session_addCommentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addComment(targetId, comment, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_addComment(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addComment(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode editComment(const ::std::string& id, const ::std::string& comment, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_editComment(_iceI_begin_editComment(id, comment, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_editComment(const ::std::string& id, const ::std::string& comment, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_editComment(id, comment, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_editComment(const ::std::string& id, const ::std::string& comment, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_editComment(id, comment, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_editComment(const ::std::string& id, const ::std::string& comment, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_editComment(id, comment, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_editComment(const ::std::string& id, const ::std::string& comment, const ::Rpc::Callback_Session_editCommentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_editComment(id, comment, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_editComment(const ::std::string& id, const ::std::string& comment, const ::Ice::Context& context, const ::Rpc::Callback_Session_editCommentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_editComment(id, comment, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_editComment(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_editComment(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode removeComment(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_removeComment(_iceI_begin_removeComment(id, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_removeComment(const ::std::string& id, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_removeComment(id, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeComment(const ::std::string& id, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeComment(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeComment(const ::std::string& id, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeComment(id, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeComment(const ::std::string& id, const ::Rpc::Callback_Session_removeCommentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeComment(id, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeComment(const ::std::string& id, const ::Ice::Context& context, const ::Rpc::Callback_Session_removeCommentPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeComment(id, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_removeComment(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_removeComment(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode queryDownloadCount(const ::std::string& targetId, ::Ice::Int& count, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_queryDownloadCount(count, _iceI_begin_queryDownloadCount(targetId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_queryDownloadCount(const ::std::string& targetId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_queryDownloadCount(targetId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryDownloadCount(const ::std::string& targetId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_queryDownloadCount(targetId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_queryDownloadCount(const ::std::string& targetId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_queryDownloadCount(targetId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_queryDownloadCount(const ::std::string& targetId, const ::Rpc::Callback_Session_queryDownloadCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_queryDownloadCount(targetId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_queryDownloadCount(const ::std::string& targetId, const ::Ice::Context& context, const ::Rpc::Callback_Session_queryDownloadCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_queryDownloadCount(targetId, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_queryDownloadCount(::Ice::Int& count, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_queryDownloadCount(::Ice::Int& iceP_count, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_queryDownloadCount(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode isUserOnline(const ::std::string& userName, bool& result, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_isUserOnline(result, _iceI_begin_isUserOnline(userName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_isUserOnline(const ::std::string& userName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_isUserOnline(userName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isUserOnline(const ::std::string& userName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isUserOnline(userName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isUserOnline(const ::std::string& userName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isUserOnline(userName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isUserOnline(const ::std::string& userName, const ::Rpc::Callback_Session_isUserOnlinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isUserOnline(userName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_isUserOnline(const ::std::string& userName, const ::Ice::Context& context, const ::Rpc::Callback_Session_isUserOnlinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_isUserOnline(userName, context, cb, cookie);
    }

    ::Rpc::ErrorCode end_isUserOnline(bool& result, const ::Ice::AsyncResultPtr& result_);
    /// \cond INTERNAL

    void _iceI_end_isUserOnline(bool& iceP_result, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_isUserOnline(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Rpc::ErrorCode onlineUserCount(::Ice::Int& count, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_onlineUserCount(count, _iceI_begin_onlineUserCount(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_onlineUserCount(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_onlineUserCount(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_onlineUserCount(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onlineUserCount(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onlineUserCount(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onlineUserCount(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onlineUserCount(const ::Rpc::Callback_Session_onlineUserCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onlineUserCount(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_onlineUserCount(const ::Ice::Context& context, const ::Rpc::Callback_Session_onlineUserCountPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_onlineUserCount(context, cb, cookie);
    }

    ::Rpc::ErrorCode end_onlineUserCount(::Ice::Int& count, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_onlineUserCount(::Ice::Int& iceP_count, ::Rpc::ErrorCode& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_onlineUserCount(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace Rpc
{

class ContentBrowser : virtual public ManagedObject
{
public:

    typedef ContentBrowserPrx ProxyType;
    typedef ContentBrowserPtr PointerType;

    virtual ~ContentBrowser();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode next(::Ice::Int n, ContentItemSeq& items, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const ContentBrowser& lhs, const ContentBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ContentBrowser& lhs, const ContentBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class EngineVersionBrowser : virtual public ManagedObject
{
public:

    typedef EngineVersionBrowserPrx ProxyType;
    typedef EngineVersionBrowserPtr PointerType;

    virtual ~EngineVersionBrowser();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode next(::Ice::Int n, EngineVersionSeq& items, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const EngineVersionBrowser& lhs, const EngineVersionBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const EngineVersionBrowser& lhs, const EngineVersionBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class ExtraBrowser : virtual public ManagedObject
{
public:

    typedef ExtraBrowserPrx ProxyType;
    typedef ExtraBrowserPtr PointerType;

    virtual ~ExtraBrowser();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode next(::Ice::Int n, ExtraInfoSeq& items, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const ExtraBrowser& lhs, const ExtraBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ExtraBrowser& lhs, const ExtraBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class UserBrowser : virtual public ManagedObject
{
public:

    typedef UserBrowserPrx ProxyType;
    typedef UserBrowserPtr PointerType;

    virtual ~UserBrowser();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode next(::Ice::Int n, UserSeq& items, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const UserBrowser& lhs, const UserBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const UserBrowser& lhs, const UserBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class ContentSubmitter : virtual public ManagedObject
{
public:

    typedef ContentSubmitterPrx ProxyType;
    typedef ContentSubmitterPtr PointerType;

    virtual ~ContentSubmitter();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode getId(::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setTitle(const ::std::string& title, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setTitle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setPage(const ::std::string& page, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setPage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setCategory(const ::std::string& category, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setCategory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setEngine(const ::std::string& name, const ::std::string& version, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setEngine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setStartup(const ::std::string& startup, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setStartup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setParentId(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setParentId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setVideo(const ::std::string& video, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setVideo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setDescription(const ::std::string& description, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setDescription(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode uploadImage(::Ice::Int index, UploaderPrx& uploader, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode uploadContent(UploaderPrx& uploader, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void cancel(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_cancel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode finish(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_finish(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const ContentSubmitter& lhs, const ContentSubmitter& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ContentSubmitter& lhs, const ContentSubmitter& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class EngineVersionSubmitter : virtual public ManagedObject
{
public:

    typedef EngineVersionSubmitterPrx ProxyType;
    typedef EngineVersionSubmitterPtr PointerType;

    virtual ~EngineVersionSubmitter();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode setSetup(const ::std::string& setup, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setSetup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setUnSetup(const ::std::string& unsetup, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setUnSetup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setInfo(const ::std::string& info, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode uploadEngine(UploaderPrx& uploader, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadEngine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void cancel(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_cancel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode finish(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_finish(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const EngineVersionSubmitter& lhs, const EngineVersionSubmitter& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const EngineVersionSubmitter& lhs, const EngineVersionSubmitter& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class ExtraSubmitter : virtual public ManagedObject
{
public:

    typedef ExtraSubmitterPrx ProxyType;
    typedef ExtraSubmitterPtr PointerType;

    virtual ~ExtraSubmitter();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode setParentId(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setParentId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setTitle(const ::std::string& title, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setTitle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setSetup(const ::std::string& setup, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setSetup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setCategory(const ::std::string& category, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setCategory(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setInfo(const ::std::string& info, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode uploadImage(UploaderPrx& uploader, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode uploadExtra(UploaderPrx& uploader, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadExtra(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void cancel(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_cancel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode finish(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_finish(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const ExtraSubmitter& lhs, const ExtraSubmitter& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ExtraSubmitter& lhs, const ExtraSubmitter& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class ClientBrowser : virtual public ManagedObject
{
public:

    typedef ClientBrowserPrx ProxyType;
    typedef ClientBrowserPtr PointerType;

    virtual ~ClientBrowser();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode next(::Ice::Int n, ClientInfoSeq& items, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const ClientBrowser& lhs, const ClientBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ClientBrowser& lhs, const ClientBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class ClientSubmitter : virtual public ManagedObject
{
public:

    typedef ClientSubmitterPrx ProxyType;
    typedef ClientSubmitterPtr PointerType;

    virtual ~ClientSubmitter();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode setInfo(const ::std::string& info, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode uploadClient(UploaderPrx& uploader, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_uploadClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void cancel(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_cancel(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode finish(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_finish(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const ClientSubmitter& lhs, const ClientSubmitter& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ClientSubmitter& lhs, const ClientSubmitter& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class CommentBrowser : virtual public ManagedObject
{
public:

    typedef CommentBrowserPrx ProxyType;
    typedef CommentBrowserPtr PointerType;

    virtual ~CommentBrowser();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ErrorCode next(::Ice::Int n, CommentSeq& items, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_next(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const CommentBrowser& lhs, const CommentBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const CommentBrowser& lhs, const CommentBrowser& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Session : virtual public ManagedObject
{
public:

    typedef SessionPrx ProxyType;
    typedef SessionPtr PointerType;

    virtual ~Session();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void refresh(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_refresh(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode getCurrentUser(::std::string& user, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getCurrentUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode getCurrentUserGroup(::std::string& group, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getCurrentUserGroup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setPages(const StringSeq& pages, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setPages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode getPages(StringSeq& pages, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getPages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setContentCategories(const StringSeq& categories, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setContentCategories(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode getContentCategories(StringSeq& categories, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getContentCategories(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setExtraCategories(const StringSeq& categories, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setExtraCategories(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode getExtraCategories(StringSeq& categories, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getExtraCategories(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setUniformInfo(const ::std::string& key, const ::std::string& value, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setUniformInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode getUniformInfo(const ::std::string& key, ::std::string& value, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getUniformInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode browseContent(const ::std::string& page, const ::std::string& category, const ::std::string& search, ContentBrowserPrx& browser, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_browseContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode browseContentByParentId(const ::std::string& parentId, ContentBrowserPrx& browser, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_browseContentByParentId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode getContentInfo(const ::std::string& id, ContentInfo& info, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getContentInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode downloadContentImage(const ::std::string& id, ::Ice::Int index, DownloaderPrx& downloader, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_downloadContentImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode downloadContent(const ::std::string& id, DownloaderPrx& downloader, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_downloadContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode submitContent(ContentSubmitterPrx& submitter, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_submitContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode copyContent(const ::std::string& id, ContentSubmitterPrx& submitter, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_copyContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode editContent(const ::std::string& id, ContentSubmitterPrx& submitter, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_editContent(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode changeContentState(const ::std::string& id, const ::std::string& state, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_changeContentState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode changeContentDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_changeContentDisplayPriority(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode browseEngineVersions(bool all, EngineVersionBrowserPrx& browser, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_browseEngineVersions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode downloadEngineVersion(const ::std::string& name, const ::std::string& version, DownloaderPrx& downloader, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_downloadEngineVersion(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode removeEngineVersion(const ::std::string& name, const ::std::string& version, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_removeEngineVersion(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode submitEngineVersion(const ::std::string& name, const ::std::string& version, EngineVersionSubmitterPrx& submitter, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_submitEngineVersion(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode updateEngineVersion(const ::std::string& name, const ::std::string& version, EngineVersionSubmitterPrx& submitter, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_updateEngineVersion(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode getEngineVersion(const ::std::string& name, const ::std::string& version, EngineVersionInfo& engineVersion, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getEngineVersion(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode changeEngineVersionDisplayPriority(const ::std::string& name, const ::std::string& version, ::Ice::Int displayPriority, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_changeEngineVersionDisplayPriority(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode browseExtra(const ::std::string& category, const ::std::string& search, ExtraBrowserPrx& browser, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_browseExtra(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode browseExtraByParentId(const ::std::string& parentId, ExtraBrowserPrx& browser, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_browseExtraByParentId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode getExtraInfo(const ::std::string& id, ExtraInfo& info, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getExtraInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode downloadExtraImage(const ::std::string& id, DownloaderPrx& downloader, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_downloadExtraImage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode downloadExtra(const ::std::string& id, DownloaderPrx& downloader, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_downloadExtra(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode submitExtra(ExtraSubmitterPrx& submitter, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_submitExtra(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode updateExtra(const ::std::string& id, ExtraSubmitterPrx& submitter, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_updateExtra(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode changeExtraState(const ::std::string& id, const ::std::string& state, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_changeExtraState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode changeExtraDisplayPriority(const ::std::string& id, ::Ice::Int displayPriority, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_changeExtraDisplayPriority(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode browseClient(ClientBrowserPrx& browser, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_browseClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode getClientInfo(const ::std::string& version, ClientInfo& info, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getClientInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode submitClient(const ::std::string& version, ClientSubmitterPrx& submitter, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_submitClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode updateClient(const ::std::string& version, ClientSubmitterPrx& submitter, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_updateClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode removeClient(const ::std::string& version, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_removeClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode browseUsers(UserBrowserPrx& browser, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_browseUsers(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode setUserGroup(const ::std::string& username, const ::std::string& group, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setUserGroup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode removeUser(const ::std::string& username, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_removeUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode browseComment(const ::std::string& targetId, const ::std::string& user, CommentBrowserPrx& browser, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_browseComment(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode getComment(const ::std::string& targetId, ::std::string& comment, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getComment(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode addComment(const ::std::string& targetId, const ::std::string& comment, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addComment(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode editComment(const ::std::string& id, const ::std::string& comment, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_editComment(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode removeComment(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_removeComment(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode queryDownloadCount(const ::std::string& targetId, ::Ice::Int& count, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_queryDownloadCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode isUserOnline(const ::std::string& userName, bool& result, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_isUserOnline(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ErrorCode onlineUserCount(::Ice::Int& count, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_onlineUserCount(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Session& lhs, const Session& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Session& lhs, const Session& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::Rpc::ContentItem>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Rpc::ContentItem, S>
{
    static void write(S* ostr, const ::Rpc::ContentItem& v)
    {
        ostr->write(v.rowid);
        ostr->write(v.id);
        ostr->write(v.title);
        ostr->write(v.state);
    }
};

template<typename S>
struct StreamReader< ::Rpc::ContentItem, S>
{
    static void read(S* istr, ::Rpc::ContentItem& v)
    {
        istr->read(v.rowid);
        istr->read(v.id);
        istr->read(v.title);
        istr->read(v.state);
    }
};

template<>
struct StreamableTraits< ::Rpc::ContentInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 29;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Rpc::ContentInfo, S>
{
    static void write(S* ostr, const ::Rpc::ContentInfo& v)
    {
        ostr->write(v.rowid);
        ostr->write(v.id);
        ostr->write(v.parentId);
        ostr->write(v.title);
        ostr->write(v.page);
        ostr->write(v.category);
        ostr->write(v.engineName);
        ostr->write(v.engineVersion);
        ostr->write(v.startup);
        ostr->write(v.imageCount);
        ostr->write(v.video);
        ostr->write(v.desc);
        ostr->write(v.user);
        ostr->write(v.upTime);
        ostr->write(v.displayPriority);
        ostr->write(v.state);
    }
};

template<typename S>
struct StreamReader< ::Rpc::ContentInfo, S>
{
    static void read(S* istr, ::Rpc::ContentInfo& v)
    {
        istr->read(v.rowid);
        istr->read(v.id);
        istr->read(v.parentId);
        istr->read(v.title);
        istr->read(v.page);
        istr->read(v.category);
        istr->read(v.engineName);
        istr->read(v.engineVersion);
        istr->read(v.startup);
        istr->read(v.imageCount);
        istr->read(v.video);
        istr->read(v.desc);
        istr->read(v.user);
        istr->read(v.upTime);
        istr->read(v.displayPriority);
        istr->read(v.state);
    }
};

template<>
struct StreamableTraits< ::Rpc::EngineVersionInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Rpc::EngineVersionInfo, S>
{
    static void write(S* ostr, const ::Rpc::EngineVersionInfo& v)
    {
        ostr->write(v.name);
        ostr->write(v.version);
        ostr->write(v.setup);
        ostr->write(v.unsetup);
        ostr->write(v.uptime);
        ostr->write(v.info);
        ostr->write(v.displayPriority);
        ostr->write(v.state);
    }
};

template<typename S>
struct StreamReader< ::Rpc::EngineVersionInfo, S>
{
    static void read(S* istr, ::Rpc::EngineVersionInfo& v)
    {
        istr->read(v.name);
        istr->read(v.version);
        istr->read(v.setup);
        istr->read(v.unsetup);
        istr->read(v.uptime);
        istr->read(v.info);
        istr->read(v.displayPriority);
        istr->read(v.state);
    }
};

template<>
struct StreamableTraits< ::Rpc::ExtraInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Rpc::ExtraInfo, S>
{
    static void write(S* ostr, const ::Rpc::ExtraInfo& v)
    {
        ostr->write(v.id);
        ostr->write(v.parentId);
        ostr->write(v.title);
        ostr->write(v.category);
        ostr->write(v.setup);
        ostr->write(v.user);
        ostr->write(v.uptime);
        ostr->write(v.info);
        ostr->write(v.displayPriority);
        ostr->write(v.state);
    }
};

template<typename S>
struct StreamReader< ::Rpc::ExtraInfo, S>
{
    static void read(S* istr, ::Rpc::ExtraInfo& v)
    {
        istr->read(v.id);
        istr->read(v.parentId);
        istr->read(v.title);
        istr->read(v.category);
        istr->read(v.setup);
        istr->read(v.user);
        istr->read(v.uptime);
        istr->read(v.info);
        istr->read(v.displayPriority);
        istr->read(v.state);
    }
};

template<>
struct StreamableTraits< ::Rpc::User>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Rpc::User, S>
{
    static void write(S* ostr, const ::Rpc::User& v)
    {
        ostr->write(v.username);
        ostr->write(v.group);
        ostr->write(v.info);
    }
};

template<typename S>
struct StreamReader< ::Rpc::User, S>
{
    static void read(S* istr, ::Rpc::User& v)
    {
        istr->read(v.username);
        istr->read(v.group);
        istr->read(v.info);
    }
};

template<>
struct StreamableTraits< ::Rpc::ClientInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Rpc::ClientInfo, S>
{
    static void write(S* ostr, const ::Rpc::ClientInfo& v)
    {
        ostr->write(v.version);
        ostr->write(v.uptime);
        ostr->write(v.info);
        ostr->write(v.state);
    }
};

template<typename S>
struct StreamReader< ::Rpc::ClientInfo, S>
{
    static void read(S* istr, ::Rpc::ClientInfo& v)
    {
        istr->read(v.version);
        istr->read(v.uptime);
        istr->read(v.info);
        istr->read(v.state);
    }
};

template<>
struct StreamableTraits< ::Rpc::Comment>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::Rpc::Comment, S>
{
    static void write(S* ostr, const ::Rpc::Comment& v)
    {
        ostr->write(v.id);
        ostr->write(v.targetId);
        ostr->write(v.user);
        ostr->write(v.time);
        ostr->write(v.comment);
    }
};

template<typename S>
struct StreamReader< ::Rpc::Comment, S>
{
    static void read(S* istr, ::Rpc::Comment& v)
    {
        istr->read(v.id);
        istr->read(v.targetId);
        istr->read(v.user);
        istr->read(v.time);
        istr->read(v.comment);
    }
};

}
/// \endcond

namespace Rpc
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentBrowser_next.
 */
template<class T>
class CallbackNC_ContentBrowser_next : public Callback_ContentBrowser_next_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ContentItemSeq&);

    CallbackNC_ContentBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentBrowserPrx proxy = ContentBrowserPrx::uncheckedCast(result->getProxy());
        ContentItemSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_items);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentBrowser::begin_next.
 */
template<class T> Callback_ContentBrowser_nextPtr
newCallback_ContentBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentItemSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentBrowser::begin_next.
 */
template<class T> Callback_ContentBrowser_nextPtr
newCallback_ContentBrowser_next(T* instance, void (T::*cb)(ErrorCode, const ContentItemSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentBrowser_next.
 */
template<class T, typename CT>
class Callback_ContentBrowser_next : public Callback_ContentBrowser_next_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ContentItemSeq&, const CT&);

    Callback_ContentBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentBrowserPrx proxy = ContentBrowserPrx::uncheckedCast(result->getProxy());
        ContentItemSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_items, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentBrowser::begin_next.
 */
template<class T, typename CT> Callback_ContentBrowser_nextPtr
newCallback_ContentBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentItemSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentBrowser::begin_next.
 */
template<class T, typename CT> Callback_ContentBrowser_nextPtr
newCallback_ContentBrowser_next(T* instance, void (T::*cb)(ErrorCode, const ContentItemSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::EngineVersionBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionBrowser_next.
 */
template<class T>
class CallbackNC_EngineVersionBrowser_next : public Callback_EngineVersionBrowser_next_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const EngineVersionSeq&);

    CallbackNC_EngineVersionBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionBrowserPrx proxy = EngineVersionBrowserPrx::uncheckedCast(result->getProxy());
        EngineVersionSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_items);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionBrowser::begin_next.
 */
template<class T> Callback_EngineVersionBrowser_nextPtr
newCallback_EngineVersionBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const EngineVersionSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionBrowser::begin_next.
 */
template<class T> Callback_EngineVersionBrowser_nextPtr
newCallback_EngineVersionBrowser_next(T* instance, void (T::*cb)(ErrorCode, const EngineVersionSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::EngineVersionBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionBrowser_next.
 */
template<class T, typename CT>
class Callback_EngineVersionBrowser_next : public Callback_EngineVersionBrowser_next_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const EngineVersionSeq&, const CT&);

    Callback_EngineVersionBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionBrowserPrx proxy = EngineVersionBrowserPrx::uncheckedCast(result->getProxy());
        EngineVersionSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_items, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionBrowser::begin_next.
 */
template<class T, typename CT> Callback_EngineVersionBrowser_nextPtr
newCallback_EngineVersionBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const EngineVersionSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionBrowser::begin_next.
 */
template<class T, typename CT> Callback_EngineVersionBrowser_nextPtr
newCallback_EngineVersionBrowser_next(T* instance, void (T::*cb)(ErrorCode, const EngineVersionSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ExtraBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraBrowser_next.
 */
template<class T>
class CallbackNC_ExtraBrowser_next : public Callback_ExtraBrowser_next_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ExtraInfoSeq&);

    CallbackNC_ExtraBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraBrowserPrx proxy = ExtraBrowserPrx::uncheckedCast(result->getProxy());
        ExtraInfoSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_items);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraBrowser::begin_next.
 */
template<class T> Callback_ExtraBrowser_nextPtr
newCallback_ExtraBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraInfoSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraBrowser::begin_next.
 */
template<class T> Callback_ExtraBrowser_nextPtr
newCallback_ExtraBrowser_next(T* instance, void (T::*cb)(ErrorCode, const ExtraInfoSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ExtraBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraBrowser_next.
 */
template<class T, typename CT>
class Callback_ExtraBrowser_next : public Callback_ExtraBrowser_next_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ExtraInfoSeq&, const CT&);

    Callback_ExtraBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraBrowserPrx proxy = ExtraBrowserPrx::uncheckedCast(result->getProxy());
        ExtraInfoSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_items, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraBrowser::begin_next.
 */
template<class T, typename CT> Callback_ExtraBrowser_nextPtr
newCallback_ExtraBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraInfoSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraBrowser::begin_next.
 */
template<class T, typename CT> Callback_ExtraBrowser_nextPtr
newCallback_ExtraBrowser_next(T* instance, void (T::*cb)(ErrorCode, const ExtraInfoSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::UserBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_UserBrowser_next.
 */
template<class T>
class CallbackNC_UserBrowser_next : public Callback_UserBrowser_next_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const UserSeq&);

    CallbackNC_UserBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        UserBrowserPrx proxy = UserBrowserPrx::uncheckedCast(result->getProxy());
        UserSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_items);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::UserBrowser::begin_next.
 */
template<class T> Callback_UserBrowser_nextPtr
newCallback_UserBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UserSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_UserBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::UserBrowser::begin_next.
 */
template<class T> Callback_UserBrowser_nextPtr
newCallback_UserBrowser_next(T* instance, void (T::*cb)(ErrorCode, const UserSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_UserBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::UserBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_UserBrowser_next.
 */
template<class T, typename CT>
class Callback_UserBrowser_next : public Callback_UserBrowser_next_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const UserSeq&, const CT&);

    Callback_UserBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        UserBrowserPrx proxy = UserBrowserPrx::uncheckedCast(result->getProxy());
        UserSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_items, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::UserBrowser::begin_next.
 */
template<class T, typename CT> Callback_UserBrowser_nextPtr
newCallback_UserBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UserSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_UserBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::UserBrowser::begin_next.
 */
template<class T, typename CT> Callback_UserBrowser_nextPtr
newCallback_UserBrowser_next(T* instance, void (T::*cb)(ErrorCode, const UserSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_UserBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_getId.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_getId.
 */
template<class T>
class CallbackNC_ContentSubmitter_getId : public Callback_ContentSubmitter_getId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ::std::string&);

    CallbackNC_ContentSubmitter_getId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_id;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getId(iceP_id, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_id);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_getId.
 */
template<class T> Callback_ContentSubmitter_getIdPtr
newCallback_ContentSubmitter_getId(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_getId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_getId.
 */
template<class T> Callback_ContentSubmitter_getIdPtr
newCallback_ContentSubmitter_getId(T* instance, void (T::*cb)(ErrorCode, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_getId<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_getId.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_getId.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_getId : public Callback_ContentSubmitter_getId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ::std::string&, const CT&);

    Callback_ContentSubmitter_getId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_id;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getId(iceP_id, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_id, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_getId.
 */
template<class T, typename CT> Callback_ContentSubmitter_getIdPtr
newCallback_ContentSubmitter_getId(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_getId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_getId.
 */
template<class T, typename CT> Callback_ContentSubmitter_getIdPtr
newCallback_ContentSubmitter_getId(T* instance, void (T::*cb)(ErrorCode, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_getId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setTitle.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setTitle.
 */
template<class T>
class CallbackNC_ContentSubmitter_setTitle : public Callback_ContentSubmitter_setTitle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ContentSubmitter_setTitle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setTitle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setTitle.
 */
template<class T> Callback_ContentSubmitter_setTitlePtr
newCallback_ContentSubmitter_setTitle(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setTitle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setTitle.
 */
template<class T> Callback_ContentSubmitter_setTitlePtr
newCallback_ContentSubmitter_setTitle(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setTitle<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setTitle.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setTitle.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_setTitle : public Callback_ContentSubmitter_setTitle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ContentSubmitter_setTitle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setTitle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setTitle.
 */
template<class T, typename CT> Callback_ContentSubmitter_setTitlePtr
newCallback_ContentSubmitter_setTitle(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setTitle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setTitle.
 */
template<class T, typename CT> Callback_ContentSubmitter_setTitlePtr
newCallback_ContentSubmitter_setTitle(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setTitle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setPage.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setPage.
 */
template<class T>
class CallbackNC_ContentSubmitter_setPage : public Callback_ContentSubmitter_setPage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ContentSubmitter_setPage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setPage(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setPage.
 */
template<class T> Callback_ContentSubmitter_setPagePtr
newCallback_ContentSubmitter_setPage(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setPage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setPage.
 */
template<class T> Callback_ContentSubmitter_setPagePtr
newCallback_ContentSubmitter_setPage(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setPage<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setPage.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setPage.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_setPage : public Callback_ContentSubmitter_setPage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ContentSubmitter_setPage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setPage(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setPage.
 */
template<class T, typename CT> Callback_ContentSubmitter_setPagePtr
newCallback_ContentSubmitter_setPage(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setPage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setPage.
 */
template<class T, typename CT> Callback_ContentSubmitter_setPagePtr
newCallback_ContentSubmitter_setPage(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setPage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setCategory.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setCategory.
 */
template<class T>
class CallbackNC_ContentSubmitter_setCategory : public Callback_ContentSubmitter_setCategory_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ContentSubmitter_setCategory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setCategory(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setCategory.
 */
template<class T> Callback_ContentSubmitter_setCategoryPtr
newCallback_ContentSubmitter_setCategory(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setCategory<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setCategory.
 */
template<class T> Callback_ContentSubmitter_setCategoryPtr
newCallback_ContentSubmitter_setCategory(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setCategory<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setCategory.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setCategory.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_setCategory : public Callback_ContentSubmitter_setCategory_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ContentSubmitter_setCategory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setCategory(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setCategory.
 */
template<class T, typename CT> Callback_ContentSubmitter_setCategoryPtr
newCallback_ContentSubmitter_setCategory(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setCategory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setCategory.
 */
template<class T, typename CT> Callback_ContentSubmitter_setCategoryPtr
newCallback_ContentSubmitter_setCategory(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setCategory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setEngine.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setEngine.
 */
template<class T>
class CallbackNC_ContentSubmitter_setEngine : public Callback_ContentSubmitter_setEngine_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ContentSubmitter_setEngine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setEngine(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setEngine.
 */
template<class T> Callback_ContentSubmitter_setEnginePtr
newCallback_ContentSubmitter_setEngine(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setEngine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setEngine.
 */
template<class T> Callback_ContentSubmitter_setEnginePtr
newCallback_ContentSubmitter_setEngine(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setEngine<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setEngine.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setEngine.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_setEngine : public Callback_ContentSubmitter_setEngine_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ContentSubmitter_setEngine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setEngine(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setEngine.
 */
template<class T, typename CT> Callback_ContentSubmitter_setEnginePtr
newCallback_ContentSubmitter_setEngine(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setEngine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setEngine.
 */
template<class T, typename CT> Callback_ContentSubmitter_setEnginePtr
newCallback_ContentSubmitter_setEngine(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setEngine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setStartup.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setStartup.
 */
template<class T>
class CallbackNC_ContentSubmitter_setStartup : public Callback_ContentSubmitter_setStartup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ContentSubmitter_setStartup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setStartup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setStartup.
 */
template<class T> Callback_ContentSubmitter_setStartupPtr
newCallback_ContentSubmitter_setStartup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setStartup<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setStartup.
 */
template<class T> Callback_ContentSubmitter_setStartupPtr
newCallback_ContentSubmitter_setStartup(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setStartup<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setStartup.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setStartup.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_setStartup : public Callback_ContentSubmitter_setStartup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ContentSubmitter_setStartup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setStartup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setStartup.
 */
template<class T, typename CT> Callback_ContentSubmitter_setStartupPtr
newCallback_ContentSubmitter_setStartup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setStartup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setStartup.
 */
template<class T, typename CT> Callback_ContentSubmitter_setStartupPtr
newCallback_ContentSubmitter_setStartup(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setStartup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setParentId.
 */
template<class T>
class CallbackNC_ContentSubmitter_setParentId : public Callback_ContentSubmitter_setParentId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ContentSubmitter_setParentId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setParentId(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setParentId.
 */
template<class T> Callback_ContentSubmitter_setParentIdPtr
newCallback_ContentSubmitter_setParentId(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setParentId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setParentId.
 */
template<class T> Callback_ContentSubmitter_setParentIdPtr
newCallback_ContentSubmitter_setParentId(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setParentId<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setParentId.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_setParentId : public Callback_ContentSubmitter_setParentId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ContentSubmitter_setParentId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setParentId(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setParentId.
 */
template<class T, typename CT> Callback_ContentSubmitter_setParentIdPtr
newCallback_ContentSubmitter_setParentId(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setParentId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setParentId.
 */
template<class T, typename CT> Callback_ContentSubmitter_setParentIdPtr
newCallback_ContentSubmitter_setParentId(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setParentId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setVideo.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setVideo.
 */
template<class T>
class CallbackNC_ContentSubmitter_setVideo : public Callback_ContentSubmitter_setVideo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ContentSubmitter_setVideo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setVideo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setVideo.
 */
template<class T> Callback_ContentSubmitter_setVideoPtr
newCallback_ContentSubmitter_setVideo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setVideo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setVideo.
 */
template<class T> Callback_ContentSubmitter_setVideoPtr
newCallback_ContentSubmitter_setVideo(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setVideo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setVideo.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setVideo.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_setVideo : public Callback_ContentSubmitter_setVideo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ContentSubmitter_setVideo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setVideo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setVideo.
 */
template<class T, typename CT> Callback_ContentSubmitter_setVideoPtr
newCallback_ContentSubmitter_setVideo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setVideo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setVideo.
 */
template<class T, typename CT> Callback_ContentSubmitter_setVideoPtr
newCallback_ContentSubmitter_setVideo(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setVideo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setDescription.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setDescription.
 */
template<class T>
class CallbackNC_ContentSubmitter_setDescription : public Callback_ContentSubmitter_setDescription_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ContentSubmitter_setDescription(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setDescription(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setDescription.
 */
template<class T> Callback_ContentSubmitter_setDescriptionPtr
newCallback_ContentSubmitter_setDescription(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setDescription<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setDescription.
 */
template<class T> Callback_ContentSubmitter_setDescriptionPtr
newCallback_ContentSubmitter_setDescription(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_setDescription<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_setDescription.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_setDescription.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_setDescription : public Callback_ContentSubmitter_setDescription_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ContentSubmitter_setDescription(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setDescription(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setDescription.
 */
template<class T, typename CT> Callback_ContentSubmitter_setDescriptionPtr
newCallback_ContentSubmitter_setDescription(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setDescription<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_setDescription.
 */
template<class T, typename CT> Callback_ContentSubmitter_setDescriptionPtr
newCallback_ContentSubmitter_setDescription(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_setDescription<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_uploadImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_uploadImage.
 */
template<class T>
class CallbackNC_ContentSubmitter_uploadImage : public Callback_ContentSubmitter_uploadImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&);

    CallbackNC_ContentSubmitter_uploadImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadImage(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_uploader);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_uploadImage.
 */
template<class T> Callback_ContentSubmitter_uploadImagePtr
newCallback_ContentSubmitter_uploadImage(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_uploadImage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_uploadImage.
 */
template<class T> Callback_ContentSubmitter_uploadImagePtr
newCallback_ContentSubmitter_uploadImage(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_uploadImage<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_uploadImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_uploadImage.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_uploadImage : public Callback_ContentSubmitter_uploadImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&, const CT&);

    Callback_ContentSubmitter_uploadImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadImage(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_uploader, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_uploadImage.
 */
template<class T, typename CT> Callback_ContentSubmitter_uploadImagePtr
newCallback_ContentSubmitter_uploadImage(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_uploadImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_uploadImage.
 */
template<class T, typename CT> Callback_ContentSubmitter_uploadImagePtr
newCallback_ContentSubmitter_uploadImage(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_uploadImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_uploadContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_uploadContent.
 */
template<class T>
class CallbackNC_ContentSubmitter_uploadContent : public Callback_ContentSubmitter_uploadContent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&);

    CallbackNC_ContentSubmitter_uploadContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadContent(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_uploader);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_uploadContent.
 */
template<class T> Callback_ContentSubmitter_uploadContentPtr
newCallback_ContentSubmitter_uploadContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_uploadContent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_uploadContent.
 */
template<class T> Callback_ContentSubmitter_uploadContentPtr
newCallback_ContentSubmitter_uploadContent(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_uploadContent<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_uploadContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_uploadContent.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_uploadContent : public Callback_ContentSubmitter_uploadContent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&, const CT&);

    Callback_ContentSubmitter_uploadContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadContent(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_uploader, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_uploadContent.
 */
template<class T, typename CT> Callback_ContentSubmitter_uploadContentPtr
newCallback_ContentSubmitter_uploadContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_uploadContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_uploadContent.
 */
template<class T, typename CT> Callback_ContentSubmitter_uploadContentPtr
newCallback_ContentSubmitter_uploadContent(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_uploadContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_cancel.
 */
template<class T>
class CallbackNC_ContentSubmitter_cancel : public Callback_ContentSubmitter_cancel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ContentSubmitter_cancel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_cancel.
 */
template<class T> Callback_ContentSubmitter_cancelPtr
newCallback_ContentSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_cancel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_cancel.
 */
template<class T> Callback_ContentSubmitter_cancelPtr
newCallback_ContentSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_cancel<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_cancel.
 */
template<class T> Callback_ContentSubmitter_cancelPtr
newCallback_ContentSubmitter_cancel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_cancel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_cancel.
 */
template<class T> Callback_ContentSubmitter_cancelPtr
newCallback_ContentSubmitter_cancel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_cancel<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_cancel.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_cancel : public Callback_ContentSubmitter_cancel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ContentSubmitter_cancel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ContentSubmitter_cancelPtr
newCallback_ContentSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_cancel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ContentSubmitter_cancelPtr
newCallback_ContentSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_cancel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ContentSubmitter_cancelPtr
newCallback_ContentSubmitter_cancel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_cancel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ContentSubmitter_cancelPtr
newCallback_ContentSubmitter_cancel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_cancel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_finish.
 */
template<class T>
class CallbackNC_ContentSubmitter_finish : public Callback_ContentSubmitter_finish_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ContentSubmitter_finish(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_finish(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_finish.
 */
template<class T> Callback_ContentSubmitter_finishPtr
newCallback_ContentSubmitter_finish(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_finish<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_finish.
 */
template<class T> Callback_ContentSubmitter_finishPtr
newCallback_ContentSubmitter_finish(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ContentSubmitter_finish<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ContentSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_ContentSubmitter_finish.
 */
template<class T, typename CT>
class Callback_ContentSubmitter_finish : public Callback_ContentSubmitter_finish_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ContentSubmitter_finish(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ContentSubmitterPrx proxy = ContentSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_finish(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_finish.
 */
template<class T, typename CT> Callback_ContentSubmitter_finishPtr
newCallback_ContentSubmitter_finish(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_finish<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ContentSubmitter::begin_finish.
 */
template<class T, typename CT> Callback_ContentSubmitter_finishPtr
newCallback_ContentSubmitter_finish(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ContentSubmitter_finish<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_setSetup.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_setSetup.
 */
template<class T>
class CallbackNC_EngineVersionSubmitter_setSetup : public Callback_EngineVersionSubmitter_setSetup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_EngineVersionSubmitter_setSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionSubmitterPrx proxy = EngineVersionSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setSetup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setSetup.
 */
template<class T> Callback_EngineVersionSubmitter_setSetupPtr
newCallback_EngineVersionSubmitter_setSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_setSetup<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setSetup.
 */
template<class T> Callback_EngineVersionSubmitter_setSetupPtr
newCallback_EngineVersionSubmitter_setSetup(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_setSetup<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_setSetup.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_setSetup.
 */
template<class T, typename CT>
class Callback_EngineVersionSubmitter_setSetup : public Callback_EngineVersionSubmitter_setSetup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_EngineVersionSubmitter_setSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionSubmitterPrx proxy = EngineVersionSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setSetup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setSetup.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_setSetupPtr
newCallback_EngineVersionSubmitter_setSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_setSetup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setSetup.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_setSetupPtr
newCallback_EngineVersionSubmitter_setSetup(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_setSetup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_setUnSetup.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_setUnSetup.
 */
template<class T>
class CallbackNC_EngineVersionSubmitter_setUnSetup : public Callback_EngineVersionSubmitter_setUnSetup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_EngineVersionSubmitter_setUnSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionSubmitterPrx proxy = EngineVersionSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setUnSetup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setUnSetup.
 */
template<class T> Callback_EngineVersionSubmitter_setUnSetupPtr
newCallback_EngineVersionSubmitter_setUnSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_setUnSetup<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setUnSetup.
 */
template<class T> Callback_EngineVersionSubmitter_setUnSetupPtr
newCallback_EngineVersionSubmitter_setUnSetup(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_setUnSetup<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_setUnSetup.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_setUnSetup.
 */
template<class T, typename CT>
class Callback_EngineVersionSubmitter_setUnSetup : public Callback_EngineVersionSubmitter_setUnSetup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_EngineVersionSubmitter_setUnSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionSubmitterPrx proxy = EngineVersionSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setUnSetup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setUnSetup.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_setUnSetupPtr
newCallback_EngineVersionSubmitter_setUnSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_setUnSetup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setUnSetup.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_setUnSetupPtr
newCallback_EngineVersionSubmitter_setUnSetup(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_setUnSetup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_setInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_setInfo.
 */
template<class T>
class CallbackNC_EngineVersionSubmitter_setInfo : public Callback_EngineVersionSubmitter_setInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_EngineVersionSubmitter_setInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionSubmitterPrx proxy = EngineVersionSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setInfo.
 */
template<class T> Callback_EngineVersionSubmitter_setInfoPtr
newCallback_EngineVersionSubmitter_setInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_setInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setInfo.
 */
template<class T> Callback_EngineVersionSubmitter_setInfoPtr
newCallback_EngineVersionSubmitter_setInfo(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_setInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_setInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_setInfo.
 */
template<class T, typename CT>
class Callback_EngineVersionSubmitter_setInfo : public Callback_EngineVersionSubmitter_setInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_EngineVersionSubmitter_setInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionSubmitterPrx proxy = EngineVersionSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setInfo.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_setInfoPtr
newCallback_EngineVersionSubmitter_setInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_setInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_setInfo.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_setInfoPtr
newCallback_EngineVersionSubmitter_setInfo(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_setInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_uploadEngine.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_uploadEngine.
 */
template<class T>
class CallbackNC_EngineVersionSubmitter_uploadEngine : public Callback_EngineVersionSubmitter_uploadEngine_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&);

    CallbackNC_EngineVersionSubmitter_uploadEngine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionSubmitterPrx proxy = EngineVersionSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadEngine(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_uploader);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_uploadEngine.
 */
template<class T> Callback_EngineVersionSubmitter_uploadEnginePtr
newCallback_EngineVersionSubmitter_uploadEngine(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_uploadEngine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_uploadEngine.
 */
template<class T> Callback_EngineVersionSubmitter_uploadEnginePtr
newCallback_EngineVersionSubmitter_uploadEngine(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_uploadEngine<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_uploadEngine.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_uploadEngine.
 */
template<class T, typename CT>
class Callback_EngineVersionSubmitter_uploadEngine : public Callback_EngineVersionSubmitter_uploadEngine_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&, const CT&);

    Callback_EngineVersionSubmitter_uploadEngine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionSubmitterPrx proxy = EngineVersionSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadEngine(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_uploader, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_uploadEngine.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_uploadEnginePtr
newCallback_EngineVersionSubmitter_uploadEngine(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_uploadEngine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_uploadEngine.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_uploadEnginePtr
newCallback_EngineVersionSubmitter_uploadEngine(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_uploadEngine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_cancel.
 */
template<class T>
class CallbackNC_EngineVersionSubmitter_cancel : public Callback_EngineVersionSubmitter_cancel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_EngineVersionSubmitter_cancel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_cancel.
 */
template<class T> Callback_EngineVersionSubmitter_cancelPtr
newCallback_EngineVersionSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_cancel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_cancel.
 */
template<class T> Callback_EngineVersionSubmitter_cancelPtr
newCallback_EngineVersionSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_cancel<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_cancel.
 */
template<class T> Callback_EngineVersionSubmitter_cancelPtr
newCallback_EngineVersionSubmitter_cancel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_cancel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_cancel.
 */
template<class T> Callback_EngineVersionSubmitter_cancelPtr
newCallback_EngineVersionSubmitter_cancel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_cancel<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_cancel.
 */
template<class T, typename CT>
class Callback_EngineVersionSubmitter_cancel : public Callback_EngineVersionSubmitter_cancel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_EngineVersionSubmitter_cancel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_cancelPtr
newCallback_EngineVersionSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_cancel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_cancelPtr
newCallback_EngineVersionSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_cancel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_cancelPtr
newCallback_EngineVersionSubmitter_cancel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_cancel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_cancelPtr
newCallback_EngineVersionSubmitter_cancel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_cancel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_finish.
 */
template<class T>
class CallbackNC_EngineVersionSubmitter_finish : public Callback_EngineVersionSubmitter_finish_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_EngineVersionSubmitter_finish(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionSubmitterPrx proxy = EngineVersionSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_finish(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_finish.
 */
template<class T> Callback_EngineVersionSubmitter_finishPtr
newCallback_EngineVersionSubmitter_finish(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_finish<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_finish.
 */
template<class T> Callback_EngineVersionSubmitter_finishPtr
newCallback_EngineVersionSubmitter_finish(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_EngineVersionSubmitter_finish<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::EngineVersionSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_EngineVersionSubmitter_finish.
 */
template<class T, typename CT>
class Callback_EngineVersionSubmitter_finish : public Callback_EngineVersionSubmitter_finish_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_EngineVersionSubmitter_finish(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        EngineVersionSubmitterPrx proxy = EngineVersionSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_finish(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_finish.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_finishPtr
newCallback_EngineVersionSubmitter_finish(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_finish<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::EngineVersionSubmitter::begin_finish.
 */
template<class T, typename CT> Callback_EngineVersionSubmitter_finishPtr
newCallback_EngineVersionSubmitter_finish(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_EngineVersionSubmitter_finish<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setParentId.
 */
template<class T>
class CallbackNC_ExtraSubmitter_setParentId : public Callback_ExtraSubmitter_setParentId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ExtraSubmitter_setParentId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setParentId(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setParentId.
 */
template<class T> Callback_ExtraSubmitter_setParentIdPtr
newCallback_ExtraSubmitter_setParentId(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_setParentId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setParentId.
 */
template<class T> Callback_ExtraSubmitter_setParentIdPtr
newCallback_ExtraSubmitter_setParentId(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_setParentId<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setParentId.
 */
template<class T, typename CT>
class Callback_ExtraSubmitter_setParentId : public Callback_ExtraSubmitter_setParentId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ExtraSubmitter_setParentId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setParentId(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setParentId.
 */
template<class T, typename CT> Callback_ExtraSubmitter_setParentIdPtr
newCallback_ExtraSubmitter_setParentId(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_setParentId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setParentId.
 */
template<class T, typename CT> Callback_ExtraSubmitter_setParentIdPtr
newCallback_ExtraSubmitter_setParentId(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_setParentId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setTitle.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setTitle.
 */
template<class T>
class CallbackNC_ExtraSubmitter_setTitle : public Callback_ExtraSubmitter_setTitle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ExtraSubmitter_setTitle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setTitle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setTitle.
 */
template<class T> Callback_ExtraSubmitter_setTitlePtr
newCallback_ExtraSubmitter_setTitle(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_setTitle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setTitle.
 */
template<class T> Callback_ExtraSubmitter_setTitlePtr
newCallback_ExtraSubmitter_setTitle(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_setTitle<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setTitle.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setTitle.
 */
template<class T, typename CT>
class Callback_ExtraSubmitter_setTitle : public Callback_ExtraSubmitter_setTitle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ExtraSubmitter_setTitle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setTitle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setTitle.
 */
template<class T, typename CT> Callback_ExtraSubmitter_setTitlePtr
newCallback_ExtraSubmitter_setTitle(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_setTitle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setTitle.
 */
template<class T, typename CT> Callback_ExtraSubmitter_setTitlePtr
newCallback_ExtraSubmitter_setTitle(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_setTitle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setSetup.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setSetup.
 */
template<class T>
class CallbackNC_ExtraSubmitter_setSetup : public Callback_ExtraSubmitter_setSetup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ExtraSubmitter_setSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setSetup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setSetup.
 */
template<class T> Callback_ExtraSubmitter_setSetupPtr
newCallback_ExtraSubmitter_setSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_setSetup<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setSetup.
 */
template<class T> Callback_ExtraSubmitter_setSetupPtr
newCallback_ExtraSubmitter_setSetup(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_setSetup<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setSetup.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setSetup.
 */
template<class T, typename CT>
class Callback_ExtraSubmitter_setSetup : public Callback_ExtraSubmitter_setSetup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ExtraSubmitter_setSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setSetup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setSetup.
 */
template<class T, typename CT> Callback_ExtraSubmitter_setSetupPtr
newCallback_ExtraSubmitter_setSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_setSetup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setSetup.
 */
template<class T, typename CT> Callback_ExtraSubmitter_setSetupPtr
newCallback_ExtraSubmitter_setSetup(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_setSetup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setCategory.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setCategory.
 */
template<class T>
class CallbackNC_ExtraSubmitter_setCategory : public Callback_ExtraSubmitter_setCategory_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ExtraSubmitter_setCategory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setCategory(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setCategory.
 */
template<class T> Callback_ExtraSubmitter_setCategoryPtr
newCallback_ExtraSubmitter_setCategory(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_setCategory<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setCategory.
 */
template<class T> Callback_ExtraSubmitter_setCategoryPtr
newCallback_ExtraSubmitter_setCategory(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_setCategory<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setCategory.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setCategory.
 */
template<class T, typename CT>
class Callback_ExtraSubmitter_setCategory : public Callback_ExtraSubmitter_setCategory_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ExtraSubmitter_setCategory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setCategory(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setCategory.
 */
template<class T, typename CT> Callback_ExtraSubmitter_setCategoryPtr
newCallback_ExtraSubmitter_setCategory(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_setCategory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setCategory.
 */
template<class T, typename CT> Callback_ExtraSubmitter_setCategoryPtr
newCallback_ExtraSubmitter_setCategory(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_setCategory<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setInfo.
 */
template<class T>
class CallbackNC_ExtraSubmitter_setInfo : public Callback_ExtraSubmitter_setInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ExtraSubmitter_setInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setInfo.
 */
template<class T> Callback_ExtraSubmitter_setInfoPtr
newCallback_ExtraSubmitter_setInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_setInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setInfo.
 */
template<class T> Callback_ExtraSubmitter_setInfoPtr
newCallback_ExtraSubmitter_setInfo(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_setInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_setInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_setInfo.
 */
template<class T, typename CT>
class Callback_ExtraSubmitter_setInfo : public Callback_ExtraSubmitter_setInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ExtraSubmitter_setInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setInfo.
 */
template<class T, typename CT> Callback_ExtraSubmitter_setInfoPtr
newCallback_ExtraSubmitter_setInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_setInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_setInfo.
 */
template<class T, typename CT> Callback_ExtraSubmitter_setInfoPtr
newCallback_ExtraSubmitter_setInfo(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_setInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_uploadImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_uploadImage.
 */
template<class T>
class CallbackNC_ExtraSubmitter_uploadImage : public Callback_ExtraSubmitter_uploadImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&);

    CallbackNC_ExtraSubmitter_uploadImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadImage(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_uploader);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_uploadImage.
 */
template<class T> Callback_ExtraSubmitter_uploadImagePtr
newCallback_ExtraSubmitter_uploadImage(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_uploadImage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_uploadImage.
 */
template<class T> Callback_ExtraSubmitter_uploadImagePtr
newCallback_ExtraSubmitter_uploadImage(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_uploadImage<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_uploadImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_uploadImage.
 */
template<class T, typename CT>
class Callback_ExtraSubmitter_uploadImage : public Callback_ExtraSubmitter_uploadImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&, const CT&);

    Callback_ExtraSubmitter_uploadImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadImage(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_uploader, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_uploadImage.
 */
template<class T, typename CT> Callback_ExtraSubmitter_uploadImagePtr
newCallback_ExtraSubmitter_uploadImage(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_uploadImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_uploadImage.
 */
template<class T, typename CT> Callback_ExtraSubmitter_uploadImagePtr
newCallback_ExtraSubmitter_uploadImage(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_uploadImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_uploadExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_uploadExtra.
 */
template<class T>
class CallbackNC_ExtraSubmitter_uploadExtra : public Callback_ExtraSubmitter_uploadExtra_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&);

    CallbackNC_ExtraSubmitter_uploadExtra(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadExtra(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_uploader);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_uploadExtra.
 */
template<class T> Callback_ExtraSubmitter_uploadExtraPtr
newCallback_ExtraSubmitter_uploadExtra(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_uploadExtra<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_uploadExtra.
 */
template<class T> Callback_ExtraSubmitter_uploadExtraPtr
newCallback_ExtraSubmitter_uploadExtra(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_uploadExtra<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_uploadExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_uploadExtra.
 */
template<class T, typename CT>
class Callback_ExtraSubmitter_uploadExtra : public Callback_ExtraSubmitter_uploadExtra_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&, const CT&);

    Callback_ExtraSubmitter_uploadExtra(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadExtra(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_uploader, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_uploadExtra.
 */
template<class T, typename CT> Callback_ExtraSubmitter_uploadExtraPtr
newCallback_ExtraSubmitter_uploadExtra(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_uploadExtra<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_uploadExtra.
 */
template<class T, typename CT> Callback_ExtraSubmitter_uploadExtraPtr
newCallback_ExtraSubmitter_uploadExtra(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_uploadExtra<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_cancel.
 */
template<class T>
class CallbackNC_ExtraSubmitter_cancel : public Callback_ExtraSubmitter_cancel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ExtraSubmitter_cancel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_cancel.
 */
template<class T> Callback_ExtraSubmitter_cancelPtr
newCallback_ExtraSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_cancel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_cancel.
 */
template<class T> Callback_ExtraSubmitter_cancelPtr
newCallback_ExtraSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_cancel<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_cancel.
 */
template<class T> Callback_ExtraSubmitter_cancelPtr
newCallback_ExtraSubmitter_cancel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_cancel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_cancel.
 */
template<class T> Callback_ExtraSubmitter_cancelPtr
newCallback_ExtraSubmitter_cancel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_cancel<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_cancel.
 */
template<class T, typename CT>
class Callback_ExtraSubmitter_cancel : public Callback_ExtraSubmitter_cancel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ExtraSubmitter_cancel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ExtraSubmitter_cancelPtr
newCallback_ExtraSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_cancel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ExtraSubmitter_cancelPtr
newCallback_ExtraSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_cancel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ExtraSubmitter_cancelPtr
newCallback_ExtraSubmitter_cancel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_cancel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ExtraSubmitter_cancelPtr
newCallback_ExtraSubmitter_cancel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_cancel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_finish.
 */
template<class T>
class CallbackNC_ExtraSubmitter_finish : public Callback_ExtraSubmitter_finish_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ExtraSubmitter_finish(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_finish(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_finish.
 */
template<class T> Callback_ExtraSubmitter_finishPtr
newCallback_ExtraSubmitter_finish(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_finish<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_finish.
 */
template<class T> Callback_ExtraSubmitter_finishPtr
newCallback_ExtraSubmitter_finish(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ExtraSubmitter_finish<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ExtraSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_ExtraSubmitter_finish.
 */
template<class T, typename CT>
class Callback_ExtraSubmitter_finish : public Callback_ExtraSubmitter_finish_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ExtraSubmitter_finish(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ExtraSubmitterPrx proxy = ExtraSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_finish(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_finish.
 */
template<class T, typename CT> Callback_ExtraSubmitter_finishPtr
newCallback_ExtraSubmitter_finish(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_finish<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ExtraSubmitter::begin_finish.
 */
template<class T, typename CT> Callback_ExtraSubmitter_finishPtr
newCallback_ExtraSubmitter_finish(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ExtraSubmitter_finish<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ClientBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientBrowser_next.
 */
template<class T>
class CallbackNC_ClientBrowser_next : public Callback_ClientBrowser_next_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ClientInfoSeq&);

    CallbackNC_ClientBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ClientBrowserPrx proxy = ClientBrowserPrx::uncheckedCast(result->getProxy());
        ClientInfoSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_items);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientBrowser::begin_next.
 */
template<class T> Callback_ClientBrowser_nextPtr
newCallback_ClientBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ClientInfoSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientBrowser::begin_next.
 */
template<class T> Callback_ClientBrowser_nextPtr
newCallback_ClientBrowser_next(T* instance, void (T::*cb)(ErrorCode, const ClientInfoSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ClientBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientBrowser_next.
 */
template<class T, typename CT>
class Callback_ClientBrowser_next : public Callback_ClientBrowser_next_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ClientInfoSeq&, const CT&);

    Callback_ClientBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ClientBrowserPrx proxy = ClientBrowserPrx::uncheckedCast(result->getProxy());
        ClientInfoSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_items, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientBrowser::begin_next.
 */
template<class T, typename CT> Callback_ClientBrowser_nextPtr
newCallback_ClientBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ClientInfoSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientBrowser::begin_next.
 */
template<class T, typename CT> Callback_ClientBrowser_nextPtr
newCallback_ClientBrowser_next(T* instance, void (T::*cb)(ErrorCode, const ClientInfoSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_setInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_setInfo.
 */
template<class T>
class CallbackNC_ClientSubmitter_setInfo : public Callback_ClientSubmitter_setInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ClientSubmitter_setInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ClientSubmitterPrx proxy = ClientSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_setInfo.
 */
template<class T> Callback_ClientSubmitter_setInfoPtr
newCallback_ClientSubmitter_setInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientSubmitter_setInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_setInfo.
 */
template<class T> Callback_ClientSubmitter_setInfoPtr
newCallback_ClientSubmitter_setInfo(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientSubmitter_setInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_setInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_setInfo.
 */
template<class T, typename CT>
class Callback_ClientSubmitter_setInfo : public Callback_ClientSubmitter_setInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ClientSubmitter_setInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ClientSubmitterPrx proxy = ClientSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_setInfo.
 */
template<class T, typename CT> Callback_ClientSubmitter_setInfoPtr
newCallback_ClientSubmitter_setInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientSubmitter_setInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_setInfo.
 */
template<class T, typename CT> Callback_ClientSubmitter_setInfoPtr
newCallback_ClientSubmitter_setInfo(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientSubmitter_setInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_uploadClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_uploadClient.
 */
template<class T>
class CallbackNC_ClientSubmitter_uploadClient : public Callback_ClientSubmitter_uploadClient_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&);

    CallbackNC_ClientSubmitter_uploadClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ClientSubmitterPrx proxy = ClientSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadClient(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_uploader);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_uploadClient.
 */
template<class T> Callback_ClientSubmitter_uploadClientPtr
newCallback_ClientSubmitter_uploadClient(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientSubmitter_uploadClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_uploadClient.
 */
template<class T> Callback_ClientSubmitter_uploadClientPtr
newCallback_ClientSubmitter_uploadClient(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientSubmitter_uploadClient<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_uploadClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_uploadClient.
 */
template<class T, typename CT>
class Callback_ClientSubmitter_uploadClient : public Callback_ClientSubmitter_uploadClient_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const UploaderPrx&, const CT&);

    Callback_ClientSubmitter_uploadClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ClientSubmitterPrx proxy = ClientSubmitterPrx::uncheckedCast(result->getProxy());
        UploaderPrx iceP_uploader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_uploadClient(iceP_uploader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_uploader, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_uploadClient.
 */
template<class T, typename CT> Callback_ClientSubmitter_uploadClientPtr
newCallback_ClientSubmitter_uploadClient(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientSubmitter_uploadClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_uploadClient.
 */
template<class T, typename CT> Callback_ClientSubmitter_uploadClientPtr
newCallback_ClientSubmitter_uploadClient(T* instance, void (T::*cb)(ErrorCode, const UploaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientSubmitter_uploadClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_cancel.
 */
template<class T>
class CallbackNC_ClientSubmitter_cancel : public Callback_ClientSubmitter_cancel_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ClientSubmitter_cancel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_cancel.
 */
template<class T> Callback_ClientSubmitter_cancelPtr
newCallback_ClientSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientSubmitter_cancel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_cancel.
 */
template<class T> Callback_ClientSubmitter_cancelPtr
newCallback_ClientSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientSubmitter_cancel<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_cancel.
 */
template<class T> Callback_ClientSubmitter_cancelPtr
newCallback_ClientSubmitter_cancel(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientSubmitter_cancel<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_cancel.
 */
template<class T> Callback_ClientSubmitter_cancelPtr
newCallback_ClientSubmitter_cancel(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientSubmitter_cancel<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_cancel.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_cancel.
 */
template<class T, typename CT>
class Callback_ClientSubmitter_cancel : public Callback_ClientSubmitter_cancel_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ClientSubmitter_cancel(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ClientSubmitter_cancelPtr
newCallback_ClientSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientSubmitter_cancel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ClientSubmitter_cancelPtr
newCallback_ClientSubmitter_cancel(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientSubmitter_cancel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ClientSubmitter_cancelPtr
newCallback_ClientSubmitter_cancel(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientSubmitter_cancel<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_cancel.
 */
template<class T, typename CT> Callback_ClientSubmitter_cancelPtr
newCallback_ClientSubmitter_cancel(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientSubmitter_cancel<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_finish.
 */
template<class T>
class CallbackNC_ClientSubmitter_finish : public Callback_ClientSubmitter_finish_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_ClientSubmitter_finish(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ClientSubmitterPrx proxy = ClientSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_finish(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_finish.
 */
template<class T> Callback_ClientSubmitter_finishPtr
newCallback_ClientSubmitter_finish(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientSubmitter_finish<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_finish.
 */
template<class T> Callback_ClientSubmitter_finishPtr
newCallback_ClientSubmitter_finish(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ClientSubmitter_finish<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::ClientSubmitter::begin_finish.
 * Create a wrapper instance by calling ::Rpc::newCallback_ClientSubmitter_finish.
 */
template<class T, typename CT>
class Callback_ClientSubmitter_finish : public Callback_ClientSubmitter_finish_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_ClientSubmitter_finish(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ClientSubmitterPrx proxy = ClientSubmitterPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_finish(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_finish.
 */
template<class T, typename CT> Callback_ClientSubmitter_finishPtr
newCallback_ClientSubmitter_finish(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientSubmitter_finish<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::ClientSubmitter::begin_finish.
 */
template<class T, typename CT> Callback_ClientSubmitter_finishPtr
newCallback_ClientSubmitter_finish(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ClientSubmitter_finish<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::CommentBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_CommentBrowser_next.
 */
template<class T>
class CallbackNC_CommentBrowser_next : public Callback_CommentBrowser_next_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const CommentSeq&);

    CallbackNC_CommentBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        CommentBrowserPrx proxy = CommentBrowserPrx::uncheckedCast(result->getProxy());
        CommentSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_items);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::CommentBrowser::begin_next.
 */
template<class T> Callback_CommentBrowser_nextPtr
newCallback_CommentBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CommentSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CommentBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::CommentBrowser::begin_next.
 */
template<class T> Callback_CommentBrowser_nextPtr
newCallback_CommentBrowser_next(T* instance, void (T::*cb)(ErrorCode, const CommentSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_CommentBrowser_next<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::CommentBrowser::begin_next.
 * Create a wrapper instance by calling ::Rpc::newCallback_CommentBrowser_next.
 */
template<class T, typename CT>
class Callback_CommentBrowser_next : public Callback_CommentBrowser_next_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CommentSeq&, const CT&);

    Callback_CommentBrowser_next(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        CommentBrowserPrx proxy = CommentBrowserPrx::uncheckedCast(result->getProxy());
        CommentSeq iceP_items;
        ErrorCode ret;
        try
        {
            ret = proxy->end_next(iceP_items, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_items, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::CommentBrowser::begin_next.
 */
template<class T, typename CT> Callback_CommentBrowser_nextPtr
newCallback_CommentBrowser_next(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CommentSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CommentBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::CommentBrowser::begin_next.
 */
template<class T, typename CT> Callback_CommentBrowser_nextPtr
newCallback_CommentBrowser_next(T* instance, void (T::*cb)(ErrorCode, const CommentSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_CommentBrowser_next<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_refresh.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_refresh.
 */
template<class T>
class CallbackNC_Session_refresh : public Callback_Session_refresh_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Session_refresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_refresh.
 */
template<class T> Callback_Session_refreshPtr
newCallback_Session_refresh(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_refresh<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_refresh.
 */
template<class T> Callback_Session_refreshPtr
newCallback_Session_refresh(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_refresh<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_refresh.
 */
template<class T> Callback_Session_refreshPtr
newCallback_Session_refresh(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_refresh<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_refresh.
 */
template<class T> Callback_Session_refreshPtr
newCallback_Session_refresh(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_refresh<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_refresh.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_refresh.
 */
template<class T, typename CT>
class Callback_Session_refresh : public Callback_Session_refresh_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Session_refresh(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_refresh.
 */
template<class T, typename CT> Callback_Session_refreshPtr
newCallback_Session_refresh(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_refresh<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_refresh.
 */
template<class T, typename CT> Callback_Session_refreshPtr
newCallback_Session_refresh(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_refresh<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_refresh.
 */
template<class T, typename CT> Callback_Session_refreshPtr
newCallback_Session_refresh(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_refresh<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_refresh.
 */
template<class T, typename CT> Callback_Session_refreshPtr
newCallback_Session_refresh(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_refresh<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_getCurrentUser.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getCurrentUser.
 */
template<class T>
class CallbackNC_Session_getCurrentUser : public Callback_Session_getCurrentUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ::std::string&);

    CallbackNC_Session_getCurrentUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_user;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getCurrentUser(iceP_user, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_user);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getCurrentUser.
 */
template<class T> Callback_Session_getCurrentUserPtr
newCallback_Session_getCurrentUser(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getCurrentUser<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getCurrentUser.
 */
template<class T> Callback_Session_getCurrentUserPtr
newCallback_Session_getCurrentUser(T* instance, void (T::*cb)(ErrorCode, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getCurrentUser<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_getCurrentUser.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getCurrentUser.
 */
template<class T, typename CT>
class Callback_Session_getCurrentUser : public Callback_Session_getCurrentUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ::std::string&, const CT&);

    Callback_Session_getCurrentUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_user;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getCurrentUser(iceP_user, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_user, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getCurrentUser.
 */
template<class T, typename CT> Callback_Session_getCurrentUserPtr
newCallback_Session_getCurrentUser(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getCurrentUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getCurrentUser.
 */
template<class T, typename CT> Callback_Session_getCurrentUserPtr
newCallback_Session_getCurrentUser(T* instance, void (T::*cb)(ErrorCode, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getCurrentUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_getCurrentUserGroup.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getCurrentUserGroup.
 */
template<class T>
class CallbackNC_Session_getCurrentUserGroup : public Callback_Session_getCurrentUserGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ::std::string&);

    CallbackNC_Session_getCurrentUserGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_group;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getCurrentUserGroup(iceP_group, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_group);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getCurrentUserGroup.
 */
template<class T> Callback_Session_getCurrentUserGroupPtr
newCallback_Session_getCurrentUserGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getCurrentUserGroup<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getCurrentUserGroup.
 */
template<class T> Callback_Session_getCurrentUserGroupPtr
newCallback_Session_getCurrentUserGroup(T* instance, void (T::*cb)(ErrorCode, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getCurrentUserGroup<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_getCurrentUserGroup.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getCurrentUserGroup.
 */
template<class T, typename CT>
class Callback_Session_getCurrentUserGroup : public Callback_Session_getCurrentUserGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ::std::string&, const CT&);

    Callback_Session_getCurrentUserGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_group;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getCurrentUserGroup(iceP_group, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_group, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getCurrentUserGroup.
 */
template<class T, typename CT> Callback_Session_getCurrentUserGroupPtr
newCallback_Session_getCurrentUserGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getCurrentUserGroup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getCurrentUserGroup.
 */
template<class T, typename CT> Callback_Session_getCurrentUserGroupPtr
newCallback_Session_getCurrentUserGroup(T* instance, void (T::*cb)(ErrorCode, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getCurrentUserGroup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_setPages.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setPages.
 */
template<class T>
class CallbackNC_Session_setPages : public Callback_Session_setPages_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_setPages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setPages(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setPages.
 */
template<class T> Callback_Session_setPagesPtr
newCallback_Session_setPages(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_setPages<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setPages.
 */
template<class T> Callback_Session_setPagesPtr
newCallback_Session_setPages(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_setPages<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_setPages.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setPages.
 */
template<class T, typename CT>
class Callback_Session_setPages : public Callback_Session_setPages_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_setPages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setPages(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setPages.
 */
template<class T, typename CT> Callback_Session_setPagesPtr
newCallback_Session_setPages(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_setPages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setPages.
 */
template<class T, typename CT> Callback_Session_setPagesPtr
newCallback_Session_setPages(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_setPages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_getPages.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getPages.
 */
template<class T>
class CallbackNC_Session_getPages : public Callback_Session_getPages_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const StringSeq&);

    CallbackNC_Session_getPages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        StringSeq iceP_pages;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getPages(iceP_pages, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_pages);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getPages.
 */
template<class T> Callback_Session_getPagesPtr
newCallback_Session_getPages(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const StringSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getPages<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getPages.
 */
template<class T> Callback_Session_getPagesPtr
newCallback_Session_getPages(T* instance, void (T::*cb)(ErrorCode, const StringSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getPages<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_getPages.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getPages.
 */
template<class T, typename CT>
class Callback_Session_getPages : public Callback_Session_getPages_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const StringSeq&, const CT&);

    Callback_Session_getPages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        StringSeq iceP_pages;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getPages(iceP_pages, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_pages, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getPages.
 */
template<class T, typename CT> Callback_Session_getPagesPtr
newCallback_Session_getPages(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const StringSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getPages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getPages.
 */
template<class T, typename CT> Callback_Session_getPagesPtr
newCallback_Session_getPages(T* instance, void (T::*cb)(ErrorCode, const StringSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getPages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_setContentCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setContentCategories.
 */
template<class T>
class CallbackNC_Session_setContentCategories : public Callback_Session_setContentCategories_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_setContentCategories(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setContentCategories(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setContentCategories.
 */
template<class T> Callback_Session_setContentCategoriesPtr
newCallback_Session_setContentCategories(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_setContentCategories<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setContentCategories.
 */
template<class T> Callback_Session_setContentCategoriesPtr
newCallback_Session_setContentCategories(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_setContentCategories<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_setContentCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setContentCategories.
 */
template<class T, typename CT>
class Callback_Session_setContentCategories : public Callback_Session_setContentCategories_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_setContentCategories(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setContentCategories(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setContentCategories.
 */
template<class T, typename CT> Callback_Session_setContentCategoriesPtr
newCallback_Session_setContentCategories(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_setContentCategories<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setContentCategories.
 */
template<class T, typename CT> Callback_Session_setContentCategoriesPtr
newCallback_Session_setContentCategories(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_setContentCategories<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_getContentCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getContentCategories.
 */
template<class T>
class CallbackNC_Session_getContentCategories : public Callback_Session_getContentCategories_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const StringSeq&);

    CallbackNC_Session_getContentCategories(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        StringSeq iceP_categories;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getContentCategories(iceP_categories, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_categories);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getContentCategories.
 */
template<class T> Callback_Session_getContentCategoriesPtr
newCallback_Session_getContentCategories(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const StringSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getContentCategories<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getContentCategories.
 */
template<class T> Callback_Session_getContentCategoriesPtr
newCallback_Session_getContentCategories(T* instance, void (T::*cb)(ErrorCode, const StringSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getContentCategories<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_getContentCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getContentCategories.
 */
template<class T, typename CT>
class Callback_Session_getContentCategories : public Callback_Session_getContentCategories_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const StringSeq&, const CT&);

    Callback_Session_getContentCategories(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        StringSeq iceP_categories;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getContentCategories(iceP_categories, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_categories, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getContentCategories.
 */
template<class T, typename CT> Callback_Session_getContentCategoriesPtr
newCallback_Session_getContentCategories(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const StringSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getContentCategories<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getContentCategories.
 */
template<class T, typename CT> Callback_Session_getContentCategoriesPtr
newCallback_Session_getContentCategories(T* instance, void (T::*cb)(ErrorCode, const StringSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getContentCategories<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_setExtraCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setExtraCategories.
 */
template<class T>
class CallbackNC_Session_setExtraCategories : public Callback_Session_setExtraCategories_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_setExtraCategories(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setExtraCategories(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setExtraCategories.
 */
template<class T> Callback_Session_setExtraCategoriesPtr
newCallback_Session_setExtraCategories(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_setExtraCategories<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setExtraCategories.
 */
template<class T> Callback_Session_setExtraCategoriesPtr
newCallback_Session_setExtraCategories(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_setExtraCategories<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_setExtraCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setExtraCategories.
 */
template<class T, typename CT>
class Callback_Session_setExtraCategories : public Callback_Session_setExtraCategories_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_setExtraCategories(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setExtraCategories(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setExtraCategories.
 */
template<class T, typename CT> Callback_Session_setExtraCategoriesPtr
newCallback_Session_setExtraCategories(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_setExtraCategories<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setExtraCategories.
 */
template<class T, typename CT> Callback_Session_setExtraCategoriesPtr
newCallback_Session_setExtraCategories(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_setExtraCategories<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_getExtraCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getExtraCategories.
 */
template<class T>
class CallbackNC_Session_getExtraCategories : public Callback_Session_getExtraCategories_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const StringSeq&);

    CallbackNC_Session_getExtraCategories(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        StringSeq iceP_categories;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getExtraCategories(iceP_categories, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_categories);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getExtraCategories.
 */
template<class T> Callback_Session_getExtraCategoriesPtr
newCallback_Session_getExtraCategories(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const StringSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getExtraCategories<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getExtraCategories.
 */
template<class T> Callback_Session_getExtraCategoriesPtr
newCallback_Session_getExtraCategories(T* instance, void (T::*cb)(ErrorCode, const StringSeq&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getExtraCategories<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_getExtraCategories.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getExtraCategories.
 */
template<class T, typename CT>
class Callback_Session_getExtraCategories : public Callback_Session_getExtraCategories_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const StringSeq&, const CT&);

    Callback_Session_getExtraCategories(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        StringSeq iceP_categories;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getExtraCategories(iceP_categories, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_categories, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getExtraCategories.
 */
template<class T, typename CT> Callback_Session_getExtraCategoriesPtr
newCallback_Session_getExtraCategories(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const StringSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getExtraCategories<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getExtraCategories.
 */
template<class T, typename CT> Callback_Session_getExtraCategoriesPtr
newCallback_Session_getExtraCategories(T* instance, void (T::*cb)(ErrorCode, const StringSeq&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getExtraCategories<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_setUniformInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setUniformInfo.
 */
template<class T>
class CallbackNC_Session_setUniformInfo : public Callback_Session_setUniformInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_setUniformInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setUniformInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setUniformInfo.
 */
template<class T> Callback_Session_setUniformInfoPtr
newCallback_Session_setUniformInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_setUniformInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setUniformInfo.
 */
template<class T> Callback_Session_setUniformInfoPtr
newCallback_Session_setUniformInfo(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_setUniformInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_setUniformInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setUniformInfo.
 */
template<class T, typename CT>
class Callback_Session_setUniformInfo : public Callback_Session_setUniformInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_setUniformInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setUniformInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setUniformInfo.
 */
template<class T, typename CT> Callback_Session_setUniformInfoPtr
newCallback_Session_setUniformInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_setUniformInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setUniformInfo.
 */
template<class T, typename CT> Callback_Session_setUniformInfoPtr
newCallback_Session_setUniformInfo(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_setUniformInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_getUniformInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getUniformInfo.
 */
template<class T>
class CallbackNC_Session_getUniformInfo : public Callback_Session_getUniformInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ::std::string&);

    CallbackNC_Session_getUniformInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_value;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getUniformInfo(iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_value);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getUniformInfo.
 */
template<class T> Callback_Session_getUniformInfoPtr
newCallback_Session_getUniformInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getUniformInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getUniformInfo.
 */
template<class T> Callback_Session_getUniformInfoPtr
newCallback_Session_getUniformInfo(T* instance, void (T::*cb)(ErrorCode, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getUniformInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_getUniformInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getUniformInfo.
 */
template<class T, typename CT>
class Callback_Session_getUniformInfo : public Callback_Session_getUniformInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ::std::string&, const CT&);

    Callback_Session_getUniformInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_value;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getUniformInfo(iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_value, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getUniformInfo.
 */
template<class T, typename CT> Callback_Session_getUniformInfoPtr
newCallback_Session_getUniformInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getUniformInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getUniformInfo.
 */
template<class T, typename CT> Callback_Session_getUniformInfoPtr
newCallback_Session_getUniformInfo(T* instance, void (T::*cb)(ErrorCode, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getUniformInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_browseContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseContent.
 */
template<class T>
class CallbackNC_Session_browseContent : public Callback_Session_browseContent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ContentBrowserPrx&);

    CallbackNC_Session_browseContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseContent(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_browser);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseContent.
 */
template<class T> Callback_Session_browseContentPtr
newCallback_Session_browseContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseContent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseContent.
 */
template<class T> Callback_Session_browseContentPtr
newCallback_Session_browseContent(T* instance, void (T::*cb)(ErrorCode, const ContentBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseContent<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_browseContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseContent.
 */
template<class T, typename CT>
class Callback_Session_browseContent : public Callback_Session_browseContent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ContentBrowserPrx&, const CT&);

    Callback_Session_browseContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseContent(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_browser, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseContent.
 */
template<class T, typename CT> Callback_Session_browseContentPtr
newCallback_Session_browseContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseContent.
 */
template<class T, typename CT> Callback_Session_browseContentPtr
newCallback_Session_browseContent(T* instance, void (T::*cb)(ErrorCode, const ContentBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_browseContentByParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseContentByParentId.
 */
template<class T>
class CallbackNC_Session_browseContentByParentId : public Callback_Session_browseContentByParentId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ContentBrowserPrx&);

    CallbackNC_Session_browseContentByParentId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseContentByParentId(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_browser);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseContentByParentId.
 */
template<class T> Callback_Session_browseContentByParentIdPtr
newCallback_Session_browseContentByParentId(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseContentByParentId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseContentByParentId.
 */
template<class T> Callback_Session_browseContentByParentIdPtr
newCallback_Session_browseContentByParentId(T* instance, void (T::*cb)(ErrorCode, const ContentBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseContentByParentId<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_browseContentByParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseContentByParentId.
 */
template<class T, typename CT>
class Callback_Session_browseContentByParentId : public Callback_Session_browseContentByParentId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ContentBrowserPrx&, const CT&);

    Callback_Session_browseContentByParentId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseContentByParentId(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_browser, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseContentByParentId.
 */
template<class T, typename CT> Callback_Session_browseContentByParentIdPtr
newCallback_Session_browseContentByParentId(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseContentByParentId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseContentByParentId.
 */
template<class T, typename CT> Callback_Session_browseContentByParentIdPtr
newCallback_Session_browseContentByParentId(T* instance, void (T::*cb)(ErrorCode, const ContentBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseContentByParentId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_getContentInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getContentInfo.
 */
template<class T>
class CallbackNC_Session_getContentInfo : public Callback_Session_getContentInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ContentInfo&);

    CallbackNC_Session_getContentInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentInfo iceP_info;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getContentInfo(iceP_info, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_info);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getContentInfo.
 */
template<class T> Callback_Session_getContentInfoPtr
newCallback_Session_getContentInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getContentInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getContentInfo.
 */
template<class T> Callback_Session_getContentInfoPtr
newCallback_Session_getContentInfo(T* instance, void (T::*cb)(ErrorCode, const ContentInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getContentInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_getContentInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getContentInfo.
 */
template<class T, typename CT>
class Callback_Session_getContentInfo : public Callback_Session_getContentInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ContentInfo&, const CT&);

    Callback_Session_getContentInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentInfo iceP_info;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getContentInfo(iceP_info, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_info, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getContentInfo.
 */
template<class T, typename CT> Callback_Session_getContentInfoPtr
newCallback_Session_getContentInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getContentInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getContentInfo.
 */
template<class T, typename CT> Callback_Session_getContentInfoPtr
newCallback_Session_getContentInfo(T* instance, void (T::*cb)(ErrorCode, const ContentInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getContentInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_downloadContentImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadContentImage.
 */
template<class T>
class CallbackNC_Session_downloadContentImage : public Callback_Session_downloadContentImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const DownloaderPrx&);

    CallbackNC_Session_downloadContentImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        DownloaderPrx iceP_downloader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_downloadContentImage(iceP_downloader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_downloader);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadContentImage.
 */
template<class T> Callback_Session_downloadContentImagePtr
newCallback_Session_downloadContentImage(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const DownloaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_downloadContentImage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadContentImage.
 */
template<class T> Callback_Session_downloadContentImagePtr
newCallback_Session_downloadContentImage(T* instance, void (T::*cb)(ErrorCode, const DownloaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_downloadContentImage<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_downloadContentImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadContentImage.
 */
template<class T, typename CT>
class Callback_Session_downloadContentImage : public Callback_Session_downloadContentImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const DownloaderPrx&, const CT&);

    Callback_Session_downloadContentImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        DownloaderPrx iceP_downloader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_downloadContentImage(iceP_downloader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_downloader, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadContentImage.
 */
template<class T, typename CT> Callback_Session_downloadContentImagePtr
newCallback_Session_downloadContentImage(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const DownloaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_downloadContentImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadContentImage.
 */
template<class T, typename CT> Callback_Session_downloadContentImagePtr
newCallback_Session_downloadContentImage(T* instance, void (T::*cb)(ErrorCode, const DownloaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_downloadContentImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_downloadContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadContent.
 */
template<class T>
class CallbackNC_Session_downloadContent : public Callback_Session_downloadContent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const DownloaderPrx&);

    CallbackNC_Session_downloadContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        DownloaderPrx iceP_downloader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_downloadContent(iceP_downloader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_downloader);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadContent.
 */
template<class T> Callback_Session_downloadContentPtr
newCallback_Session_downloadContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const DownloaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_downloadContent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadContent.
 */
template<class T> Callback_Session_downloadContentPtr
newCallback_Session_downloadContent(T* instance, void (T::*cb)(ErrorCode, const DownloaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_downloadContent<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_downloadContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadContent.
 */
template<class T, typename CT>
class Callback_Session_downloadContent : public Callback_Session_downloadContent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const DownloaderPrx&, const CT&);

    Callback_Session_downloadContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        DownloaderPrx iceP_downloader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_downloadContent(iceP_downloader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_downloader, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadContent.
 */
template<class T, typename CT> Callback_Session_downloadContentPtr
newCallback_Session_downloadContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const DownloaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_downloadContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadContent.
 */
template<class T, typename CT> Callback_Session_downloadContentPtr
newCallback_Session_downloadContent(T* instance, void (T::*cb)(ErrorCode, const DownloaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_downloadContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_submitContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitContent.
 */
template<class T>
class CallbackNC_Session_submitContent : public Callback_Session_submitContent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ContentSubmitterPrx&);

    CallbackNC_Session_submitContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_submitContent(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_submitter);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitContent.
 */
template<class T> Callback_Session_submitContentPtr
newCallback_Session_submitContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_submitContent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitContent.
 */
template<class T> Callback_Session_submitContentPtr
newCallback_Session_submitContent(T* instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_submitContent<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_submitContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitContent.
 */
template<class T, typename CT>
class Callback_Session_submitContent : public Callback_Session_submitContent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ContentSubmitterPrx&, const CT&);

    Callback_Session_submitContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_submitContent(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_submitter, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitContent.
 */
template<class T, typename CT> Callback_Session_submitContentPtr
newCallback_Session_submitContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_submitContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitContent.
 */
template<class T, typename CT> Callback_Session_submitContentPtr
newCallback_Session_submitContent(T* instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_submitContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_copyContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_copyContent.
 */
template<class T>
class CallbackNC_Session_copyContent : public Callback_Session_copyContent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ContentSubmitterPrx&);

    CallbackNC_Session_copyContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_copyContent(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_submitter);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_copyContent.
 */
template<class T> Callback_Session_copyContentPtr
newCallback_Session_copyContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_copyContent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_copyContent.
 */
template<class T> Callback_Session_copyContentPtr
newCallback_Session_copyContent(T* instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_copyContent<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_copyContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_copyContent.
 */
template<class T, typename CT>
class Callback_Session_copyContent : public Callback_Session_copyContent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ContentSubmitterPrx&, const CT&);

    Callback_Session_copyContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_copyContent(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_submitter, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_copyContent.
 */
template<class T, typename CT> Callback_Session_copyContentPtr
newCallback_Session_copyContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_copyContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_copyContent.
 */
template<class T, typename CT> Callback_Session_copyContentPtr
newCallback_Session_copyContent(T* instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_copyContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_editContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_editContent.
 */
template<class T>
class CallbackNC_Session_editContent : public Callback_Session_editContent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ContentSubmitterPrx&);

    CallbackNC_Session_editContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_editContent(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_submitter);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_editContent.
 */
template<class T> Callback_Session_editContentPtr
newCallback_Session_editContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_editContent<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_editContent.
 */
template<class T> Callback_Session_editContentPtr
newCallback_Session_editContent(T* instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_editContent<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_editContent.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_editContent.
 */
template<class T, typename CT>
class Callback_Session_editContent : public Callback_Session_editContent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ContentSubmitterPrx&, const CT&);

    Callback_Session_editContent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ContentSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_editContent(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_submitter, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_editContent.
 */
template<class T, typename CT> Callback_Session_editContentPtr
newCallback_Session_editContent(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_editContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_editContent.
 */
template<class T, typename CT> Callback_Session_editContentPtr
newCallback_Session_editContent(T* instance, void (T::*cb)(ErrorCode, const ContentSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_editContent<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_changeContentState.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeContentState.
 */
template<class T>
class CallbackNC_Session_changeContentState : public Callback_Session_changeContentState_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_changeContentState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_changeContentState(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeContentState.
 */
template<class T> Callback_Session_changeContentStatePtr
newCallback_Session_changeContentState(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_changeContentState<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeContentState.
 */
template<class T> Callback_Session_changeContentStatePtr
newCallback_Session_changeContentState(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_changeContentState<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_changeContentState.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeContentState.
 */
template<class T, typename CT>
class Callback_Session_changeContentState : public Callback_Session_changeContentState_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_changeContentState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_changeContentState(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeContentState.
 */
template<class T, typename CT> Callback_Session_changeContentStatePtr
newCallback_Session_changeContentState(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_changeContentState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeContentState.
 */
template<class T, typename CT> Callback_Session_changeContentStatePtr
newCallback_Session_changeContentState(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_changeContentState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_changeContentDisplayPriority.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeContentDisplayPriority.
 */
template<class T>
class CallbackNC_Session_changeContentDisplayPriority : public Callback_Session_changeContentDisplayPriority_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_changeContentDisplayPriority(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_changeContentDisplayPriority(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeContentDisplayPriority.
 */
template<class T> Callback_Session_changeContentDisplayPriorityPtr
newCallback_Session_changeContentDisplayPriority(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_changeContentDisplayPriority<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeContentDisplayPriority.
 */
template<class T> Callback_Session_changeContentDisplayPriorityPtr
newCallback_Session_changeContentDisplayPriority(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_changeContentDisplayPriority<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_changeContentDisplayPriority.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeContentDisplayPriority.
 */
template<class T, typename CT>
class Callback_Session_changeContentDisplayPriority : public Callback_Session_changeContentDisplayPriority_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_changeContentDisplayPriority(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_changeContentDisplayPriority(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeContentDisplayPriority.
 */
template<class T, typename CT> Callback_Session_changeContentDisplayPriorityPtr
newCallback_Session_changeContentDisplayPriority(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_changeContentDisplayPriority<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeContentDisplayPriority.
 */
template<class T, typename CT> Callback_Session_changeContentDisplayPriorityPtr
newCallback_Session_changeContentDisplayPriority(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_changeContentDisplayPriority<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_browseEngineVersions.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseEngineVersions.
 */
template<class T>
class CallbackNC_Session_browseEngineVersions : public Callback_Session_browseEngineVersions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const EngineVersionBrowserPrx&);

    CallbackNC_Session_browseEngineVersions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        EngineVersionBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseEngineVersions(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_browser);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseEngineVersions.
 */
template<class T> Callback_Session_browseEngineVersionsPtr
newCallback_Session_browseEngineVersions(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const EngineVersionBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseEngineVersions<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseEngineVersions.
 */
template<class T> Callback_Session_browseEngineVersionsPtr
newCallback_Session_browseEngineVersions(T* instance, void (T::*cb)(ErrorCode, const EngineVersionBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseEngineVersions<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_browseEngineVersions.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseEngineVersions.
 */
template<class T, typename CT>
class Callback_Session_browseEngineVersions : public Callback_Session_browseEngineVersions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const EngineVersionBrowserPrx&, const CT&);

    Callback_Session_browseEngineVersions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        EngineVersionBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseEngineVersions(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_browser, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseEngineVersions.
 */
template<class T, typename CT> Callback_Session_browseEngineVersionsPtr
newCallback_Session_browseEngineVersions(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const EngineVersionBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseEngineVersions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseEngineVersions.
 */
template<class T, typename CT> Callback_Session_browseEngineVersionsPtr
newCallback_Session_browseEngineVersions(T* instance, void (T::*cb)(ErrorCode, const EngineVersionBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseEngineVersions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_downloadEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadEngineVersion.
 */
template<class T>
class CallbackNC_Session_downloadEngineVersion : public Callback_Session_downloadEngineVersion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const DownloaderPrx&);

    CallbackNC_Session_downloadEngineVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        DownloaderPrx iceP_downloader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_downloadEngineVersion(iceP_downloader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_downloader);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadEngineVersion.
 */
template<class T> Callback_Session_downloadEngineVersionPtr
newCallback_Session_downloadEngineVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const DownloaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_downloadEngineVersion<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadEngineVersion.
 */
template<class T> Callback_Session_downloadEngineVersionPtr
newCallback_Session_downloadEngineVersion(T* instance, void (T::*cb)(ErrorCode, const DownloaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_downloadEngineVersion<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_downloadEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadEngineVersion.
 */
template<class T, typename CT>
class Callback_Session_downloadEngineVersion : public Callback_Session_downloadEngineVersion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const DownloaderPrx&, const CT&);

    Callback_Session_downloadEngineVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        DownloaderPrx iceP_downloader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_downloadEngineVersion(iceP_downloader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_downloader, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadEngineVersion.
 */
template<class T, typename CT> Callback_Session_downloadEngineVersionPtr
newCallback_Session_downloadEngineVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const DownloaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_downloadEngineVersion<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadEngineVersion.
 */
template<class T, typename CT> Callback_Session_downloadEngineVersionPtr
newCallback_Session_downloadEngineVersion(T* instance, void (T::*cb)(ErrorCode, const DownloaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_downloadEngineVersion<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_removeEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeEngineVersion.
 */
template<class T>
class CallbackNC_Session_removeEngineVersion : public Callback_Session_removeEngineVersion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_removeEngineVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_removeEngineVersion(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeEngineVersion.
 */
template<class T> Callback_Session_removeEngineVersionPtr
newCallback_Session_removeEngineVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_removeEngineVersion<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeEngineVersion.
 */
template<class T> Callback_Session_removeEngineVersionPtr
newCallback_Session_removeEngineVersion(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_removeEngineVersion<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_removeEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeEngineVersion.
 */
template<class T, typename CT>
class Callback_Session_removeEngineVersion : public Callback_Session_removeEngineVersion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_removeEngineVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_removeEngineVersion(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeEngineVersion.
 */
template<class T, typename CT> Callback_Session_removeEngineVersionPtr
newCallback_Session_removeEngineVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_removeEngineVersion<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeEngineVersion.
 */
template<class T, typename CT> Callback_Session_removeEngineVersionPtr
newCallback_Session_removeEngineVersion(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_removeEngineVersion<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_submitEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitEngineVersion.
 */
template<class T>
class CallbackNC_Session_submitEngineVersion : public Callback_Session_submitEngineVersion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const EngineVersionSubmitterPrx&);

    CallbackNC_Session_submitEngineVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        EngineVersionSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_submitEngineVersion(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_submitter);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitEngineVersion.
 */
template<class T> Callback_Session_submitEngineVersionPtr
newCallback_Session_submitEngineVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const EngineVersionSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_submitEngineVersion<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitEngineVersion.
 */
template<class T> Callback_Session_submitEngineVersionPtr
newCallback_Session_submitEngineVersion(T* instance, void (T::*cb)(ErrorCode, const EngineVersionSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_submitEngineVersion<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_submitEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitEngineVersion.
 */
template<class T, typename CT>
class Callback_Session_submitEngineVersion : public Callback_Session_submitEngineVersion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const EngineVersionSubmitterPrx&, const CT&);

    Callback_Session_submitEngineVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        EngineVersionSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_submitEngineVersion(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_submitter, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitEngineVersion.
 */
template<class T, typename CT> Callback_Session_submitEngineVersionPtr
newCallback_Session_submitEngineVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const EngineVersionSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_submitEngineVersion<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitEngineVersion.
 */
template<class T, typename CT> Callback_Session_submitEngineVersionPtr
newCallback_Session_submitEngineVersion(T* instance, void (T::*cb)(ErrorCode, const EngineVersionSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_submitEngineVersion<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_updateEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_updateEngineVersion.
 */
template<class T>
class CallbackNC_Session_updateEngineVersion : public Callback_Session_updateEngineVersion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const EngineVersionSubmitterPrx&);

    CallbackNC_Session_updateEngineVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        EngineVersionSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_updateEngineVersion(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_submitter);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateEngineVersion.
 */
template<class T> Callback_Session_updateEngineVersionPtr
newCallback_Session_updateEngineVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const EngineVersionSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_updateEngineVersion<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateEngineVersion.
 */
template<class T> Callback_Session_updateEngineVersionPtr
newCallback_Session_updateEngineVersion(T* instance, void (T::*cb)(ErrorCode, const EngineVersionSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_updateEngineVersion<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_updateEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_updateEngineVersion.
 */
template<class T, typename CT>
class Callback_Session_updateEngineVersion : public Callback_Session_updateEngineVersion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const EngineVersionSubmitterPrx&, const CT&);

    Callback_Session_updateEngineVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        EngineVersionSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_updateEngineVersion(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_submitter, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateEngineVersion.
 */
template<class T, typename CT> Callback_Session_updateEngineVersionPtr
newCallback_Session_updateEngineVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const EngineVersionSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_updateEngineVersion<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateEngineVersion.
 */
template<class T, typename CT> Callback_Session_updateEngineVersionPtr
newCallback_Session_updateEngineVersion(T* instance, void (T::*cb)(ErrorCode, const EngineVersionSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_updateEngineVersion<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_getEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getEngineVersion.
 */
template<class T>
class CallbackNC_Session_getEngineVersion : public Callback_Session_getEngineVersion_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const EngineVersionInfo&);

    CallbackNC_Session_getEngineVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        EngineVersionInfo iceP_engineVersion;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getEngineVersion(iceP_engineVersion, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_engineVersion);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getEngineVersion.
 */
template<class T> Callback_Session_getEngineVersionPtr
newCallback_Session_getEngineVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const EngineVersionInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getEngineVersion<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getEngineVersion.
 */
template<class T> Callback_Session_getEngineVersionPtr
newCallback_Session_getEngineVersion(T* instance, void (T::*cb)(ErrorCode, const EngineVersionInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getEngineVersion<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_getEngineVersion.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getEngineVersion.
 */
template<class T, typename CT>
class Callback_Session_getEngineVersion : public Callback_Session_getEngineVersion_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const EngineVersionInfo&, const CT&);

    Callback_Session_getEngineVersion(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        EngineVersionInfo iceP_engineVersion;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getEngineVersion(iceP_engineVersion, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_engineVersion, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getEngineVersion.
 */
template<class T, typename CT> Callback_Session_getEngineVersionPtr
newCallback_Session_getEngineVersion(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const EngineVersionInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getEngineVersion<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getEngineVersion.
 */
template<class T, typename CT> Callback_Session_getEngineVersionPtr
newCallback_Session_getEngineVersion(T* instance, void (T::*cb)(ErrorCode, const EngineVersionInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getEngineVersion<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_changeEngineVersionDisplayPriority.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeEngineVersionDisplayPriority.
 */
template<class T>
class CallbackNC_Session_changeEngineVersionDisplayPriority : public Callback_Session_changeEngineVersionDisplayPriority_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_changeEngineVersionDisplayPriority(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_changeEngineVersionDisplayPriority(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeEngineVersionDisplayPriority.
 */
template<class T> Callback_Session_changeEngineVersionDisplayPriorityPtr
newCallback_Session_changeEngineVersionDisplayPriority(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_changeEngineVersionDisplayPriority<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeEngineVersionDisplayPriority.
 */
template<class T> Callback_Session_changeEngineVersionDisplayPriorityPtr
newCallback_Session_changeEngineVersionDisplayPriority(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_changeEngineVersionDisplayPriority<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_changeEngineVersionDisplayPriority.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeEngineVersionDisplayPriority.
 */
template<class T, typename CT>
class Callback_Session_changeEngineVersionDisplayPriority : public Callback_Session_changeEngineVersionDisplayPriority_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_changeEngineVersionDisplayPriority(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_changeEngineVersionDisplayPriority(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeEngineVersionDisplayPriority.
 */
template<class T, typename CT> Callback_Session_changeEngineVersionDisplayPriorityPtr
newCallback_Session_changeEngineVersionDisplayPriority(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_changeEngineVersionDisplayPriority<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeEngineVersionDisplayPriority.
 */
template<class T, typename CT> Callback_Session_changeEngineVersionDisplayPriorityPtr
newCallback_Session_changeEngineVersionDisplayPriority(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_changeEngineVersionDisplayPriority<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_browseExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseExtra.
 */
template<class T>
class CallbackNC_Session_browseExtra : public Callback_Session_browseExtra_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ExtraBrowserPrx&);

    CallbackNC_Session_browseExtra(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ExtraBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseExtra(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_browser);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseExtra.
 */
template<class T> Callback_Session_browseExtraPtr
newCallback_Session_browseExtra(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseExtra<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseExtra.
 */
template<class T> Callback_Session_browseExtraPtr
newCallback_Session_browseExtra(T* instance, void (T::*cb)(ErrorCode, const ExtraBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseExtra<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_browseExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseExtra.
 */
template<class T, typename CT>
class Callback_Session_browseExtra : public Callback_Session_browseExtra_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ExtraBrowserPrx&, const CT&);

    Callback_Session_browseExtra(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ExtraBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseExtra(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_browser, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseExtra.
 */
template<class T, typename CT> Callback_Session_browseExtraPtr
newCallback_Session_browseExtra(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseExtra<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseExtra.
 */
template<class T, typename CT> Callback_Session_browseExtraPtr
newCallback_Session_browseExtra(T* instance, void (T::*cb)(ErrorCode, const ExtraBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseExtra<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_browseExtraByParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseExtraByParentId.
 */
template<class T>
class CallbackNC_Session_browseExtraByParentId : public Callback_Session_browseExtraByParentId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ExtraBrowserPrx&);

    CallbackNC_Session_browseExtraByParentId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ExtraBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseExtraByParentId(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_browser);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseExtraByParentId.
 */
template<class T> Callback_Session_browseExtraByParentIdPtr
newCallback_Session_browseExtraByParentId(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseExtraByParentId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseExtraByParentId.
 */
template<class T> Callback_Session_browseExtraByParentIdPtr
newCallback_Session_browseExtraByParentId(T* instance, void (T::*cb)(ErrorCode, const ExtraBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseExtraByParentId<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_browseExtraByParentId.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseExtraByParentId.
 */
template<class T, typename CT>
class Callback_Session_browseExtraByParentId : public Callback_Session_browseExtraByParentId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ExtraBrowserPrx&, const CT&);

    Callback_Session_browseExtraByParentId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ExtraBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseExtraByParentId(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_browser, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseExtraByParentId.
 */
template<class T, typename CT> Callback_Session_browseExtraByParentIdPtr
newCallback_Session_browseExtraByParentId(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseExtraByParentId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseExtraByParentId.
 */
template<class T, typename CT> Callback_Session_browseExtraByParentIdPtr
newCallback_Session_browseExtraByParentId(T* instance, void (T::*cb)(ErrorCode, const ExtraBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseExtraByParentId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_getExtraInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getExtraInfo.
 */
template<class T>
class CallbackNC_Session_getExtraInfo : public Callback_Session_getExtraInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ExtraInfo&);

    CallbackNC_Session_getExtraInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ExtraInfo iceP_info;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getExtraInfo(iceP_info, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_info);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getExtraInfo.
 */
template<class T> Callback_Session_getExtraInfoPtr
newCallback_Session_getExtraInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getExtraInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getExtraInfo.
 */
template<class T> Callback_Session_getExtraInfoPtr
newCallback_Session_getExtraInfo(T* instance, void (T::*cb)(ErrorCode, const ExtraInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getExtraInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_getExtraInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getExtraInfo.
 */
template<class T, typename CT>
class Callback_Session_getExtraInfo : public Callback_Session_getExtraInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ExtraInfo&, const CT&);

    Callback_Session_getExtraInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ExtraInfo iceP_info;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getExtraInfo(iceP_info, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_info, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getExtraInfo.
 */
template<class T, typename CT> Callback_Session_getExtraInfoPtr
newCallback_Session_getExtraInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getExtraInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getExtraInfo.
 */
template<class T, typename CT> Callback_Session_getExtraInfoPtr
newCallback_Session_getExtraInfo(T* instance, void (T::*cb)(ErrorCode, const ExtraInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getExtraInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_downloadExtraImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadExtraImage.
 */
template<class T>
class CallbackNC_Session_downloadExtraImage : public Callback_Session_downloadExtraImage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const DownloaderPrx&);

    CallbackNC_Session_downloadExtraImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        DownloaderPrx iceP_downloader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_downloadExtraImage(iceP_downloader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_downloader);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadExtraImage.
 */
template<class T> Callback_Session_downloadExtraImagePtr
newCallback_Session_downloadExtraImage(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const DownloaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_downloadExtraImage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadExtraImage.
 */
template<class T> Callback_Session_downloadExtraImagePtr
newCallback_Session_downloadExtraImage(T* instance, void (T::*cb)(ErrorCode, const DownloaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_downloadExtraImage<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_downloadExtraImage.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadExtraImage.
 */
template<class T, typename CT>
class Callback_Session_downloadExtraImage : public Callback_Session_downloadExtraImage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const DownloaderPrx&, const CT&);

    Callback_Session_downloadExtraImage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        DownloaderPrx iceP_downloader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_downloadExtraImage(iceP_downloader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_downloader, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadExtraImage.
 */
template<class T, typename CT> Callback_Session_downloadExtraImagePtr
newCallback_Session_downloadExtraImage(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const DownloaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_downloadExtraImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadExtraImage.
 */
template<class T, typename CT> Callback_Session_downloadExtraImagePtr
newCallback_Session_downloadExtraImage(T* instance, void (T::*cb)(ErrorCode, const DownloaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_downloadExtraImage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_downloadExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadExtra.
 */
template<class T>
class CallbackNC_Session_downloadExtra : public Callback_Session_downloadExtra_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const DownloaderPrx&);

    CallbackNC_Session_downloadExtra(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        DownloaderPrx iceP_downloader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_downloadExtra(iceP_downloader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_downloader);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadExtra.
 */
template<class T> Callback_Session_downloadExtraPtr
newCallback_Session_downloadExtra(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const DownloaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_downloadExtra<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadExtra.
 */
template<class T> Callback_Session_downloadExtraPtr
newCallback_Session_downloadExtra(T* instance, void (T::*cb)(ErrorCode, const DownloaderPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_downloadExtra<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_downloadExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_downloadExtra.
 */
template<class T, typename CT>
class Callback_Session_downloadExtra : public Callback_Session_downloadExtra_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const DownloaderPrx&, const CT&);

    Callback_Session_downloadExtra(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        DownloaderPrx iceP_downloader;
        ErrorCode ret;
        try
        {
            ret = proxy->end_downloadExtra(iceP_downloader, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_downloader, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadExtra.
 */
template<class T, typename CT> Callback_Session_downloadExtraPtr
newCallback_Session_downloadExtra(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const DownloaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_downloadExtra<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_downloadExtra.
 */
template<class T, typename CT> Callback_Session_downloadExtraPtr
newCallback_Session_downloadExtra(T* instance, void (T::*cb)(ErrorCode, const DownloaderPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_downloadExtra<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_submitExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitExtra.
 */
template<class T>
class CallbackNC_Session_submitExtra : public Callback_Session_submitExtra_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ExtraSubmitterPrx&);

    CallbackNC_Session_submitExtra(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ExtraSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_submitExtra(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_submitter);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitExtra.
 */
template<class T> Callback_Session_submitExtraPtr
newCallback_Session_submitExtra(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_submitExtra<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitExtra.
 */
template<class T> Callback_Session_submitExtraPtr
newCallback_Session_submitExtra(T* instance, void (T::*cb)(ErrorCode, const ExtraSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_submitExtra<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_submitExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitExtra.
 */
template<class T, typename CT>
class Callback_Session_submitExtra : public Callback_Session_submitExtra_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ExtraSubmitterPrx&, const CT&);

    Callback_Session_submitExtra(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ExtraSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_submitExtra(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_submitter, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitExtra.
 */
template<class T, typename CT> Callback_Session_submitExtraPtr
newCallback_Session_submitExtra(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_submitExtra<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitExtra.
 */
template<class T, typename CT> Callback_Session_submitExtraPtr
newCallback_Session_submitExtra(T* instance, void (T::*cb)(ErrorCode, const ExtraSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_submitExtra<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_updateExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_updateExtra.
 */
template<class T>
class CallbackNC_Session_updateExtra : public Callback_Session_updateExtra_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ExtraSubmitterPrx&);

    CallbackNC_Session_updateExtra(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ExtraSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_updateExtra(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_submitter);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateExtra.
 */
template<class T> Callback_Session_updateExtraPtr
newCallback_Session_updateExtra(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_updateExtra<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateExtra.
 */
template<class T> Callback_Session_updateExtraPtr
newCallback_Session_updateExtra(T* instance, void (T::*cb)(ErrorCode, const ExtraSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_updateExtra<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_updateExtra.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_updateExtra.
 */
template<class T, typename CT>
class Callback_Session_updateExtra : public Callback_Session_updateExtra_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ExtraSubmitterPrx&, const CT&);

    Callback_Session_updateExtra(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ExtraSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_updateExtra(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_submitter, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateExtra.
 */
template<class T, typename CT> Callback_Session_updateExtraPtr
newCallback_Session_updateExtra(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ExtraSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_updateExtra<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateExtra.
 */
template<class T, typename CT> Callback_Session_updateExtraPtr
newCallback_Session_updateExtra(T* instance, void (T::*cb)(ErrorCode, const ExtraSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_updateExtra<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_changeExtraState.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeExtraState.
 */
template<class T>
class CallbackNC_Session_changeExtraState : public Callback_Session_changeExtraState_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_changeExtraState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_changeExtraState(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeExtraState.
 */
template<class T> Callback_Session_changeExtraStatePtr
newCallback_Session_changeExtraState(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_changeExtraState<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeExtraState.
 */
template<class T> Callback_Session_changeExtraStatePtr
newCallback_Session_changeExtraState(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_changeExtraState<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_changeExtraState.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeExtraState.
 */
template<class T, typename CT>
class Callback_Session_changeExtraState : public Callback_Session_changeExtraState_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_changeExtraState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_changeExtraState(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeExtraState.
 */
template<class T, typename CT> Callback_Session_changeExtraStatePtr
newCallback_Session_changeExtraState(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_changeExtraState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeExtraState.
 */
template<class T, typename CT> Callback_Session_changeExtraStatePtr
newCallback_Session_changeExtraState(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_changeExtraState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_changeExtraDisplayPriority.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeExtraDisplayPriority.
 */
template<class T>
class CallbackNC_Session_changeExtraDisplayPriority : public Callback_Session_changeExtraDisplayPriority_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_changeExtraDisplayPriority(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_changeExtraDisplayPriority(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeExtraDisplayPriority.
 */
template<class T> Callback_Session_changeExtraDisplayPriorityPtr
newCallback_Session_changeExtraDisplayPriority(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_changeExtraDisplayPriority<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeExtraDisplayPriority.
 */
template<class T> Callback_Session_changeExtraDisplayPriorityPtr
newCallback_Session_changeExtraDisplayPriority(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_changeExtraDisplayPriority<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_changeExtraDisplayPriority.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_changeExtraDisplayPriority.
 */
template<class T, typename CT>
class Callback_Session_changeExtraDisplayPriority : public Callback_Session_changeExtraDisplayPriority_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_changeExtraDisplayPriority(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_changeExtraDisplayPriority(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeExtraDisplayPriority.
 */
template<class T, typename CT> Callback_Session_changeExtraDisplayPriorityPtr
newCallback_Session_changeExtraDisplayPriority(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_changeExtraDisplayPriority<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_changeExtraDisplayPriority.
 */
template<class T, typename CT> Callback_Session_changeExtraDisplayPriorityPtr
newCallback_Session_changeExtraDisplayPriority(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_changeExtraDisplayPriority<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_browseClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseClient.
 */
template<class T>
class CallbackNC_Session_browseClient : public Callback_Session_browseClient_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ClientBrowserPrx&);

    CallbackNC_Session_browseClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ClientBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseClient(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_browser);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseClient.
 */
template<class T> Callback_Session_browseClientPtr
newCallback_Session_browseClient(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ClientBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseClient.
 */
template<class T> Callback_Session_browseClientPtr
newCallback_Session_browseClient(T* instance, void (T::*cb)(ErrorCode, const ClientBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseClient<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_browseClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseClient.
 */
template<class T, typename CT>
class Callback_Session_browseClient : public Callback_Session_browseClient_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ClientBrowserPrx&, const CT&);

    Callback_Session_browseClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ClientBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseClient(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_browser, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseClient.
 */
template<class T, typename CT> Callback_Session_browseClientPtr
newCallback_Session_browseClient(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ClientBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseClient.
 */
template<class T, typename CT> Callback_Session_browseClientPtr
newCallback_Session_browseClient(T* instance, void (T::*cb)(ErrorCode, const ClientBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_getClientInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getClientInfo.
 */
template<class T>
class CallbackNC_Session_getClientInfo : public Callback_Session_getClientInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ClientInfo&);

    CallbackNC_Session_getClientInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ClientInfo iceP_info;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getClientInfo(iceP_info, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_info);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getClientInfo.
 */
template<class T> Callback_Session_getClientInfoPtr
newCallback_Session_getClientInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ClientInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getClientInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getClientInfo.
 */
template<class T> Callback_Session_getClientInfoPtr
newCallback_Session_getClientInfo(T* instance, void (T::*cb)(ErrorCode, const ClientInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getClientInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_getClientInfo.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getClientInfo.
 */
template<class T, typename CT>
class Callback_Session_getClientInfo : public Callback_Session_getClientInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ClientInfo&, const CT&);

    Callback_Session_getClientInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ClientInfo iceP_info;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getClientInfo(iceP_info, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_info, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getClientInfo.
 */
template<class T, typename CT> Callback_Session_getClientInfoPtr
newCallback_Session_getClientInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ClientInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getClientInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getClientInfo.
 */
template<class T, typename CT> Callback_Session_getClientInfoPtr
newCallback_Session_getClientInfo(T* instance, void (T::*cb)(ErrorCode, const ClientInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getClientInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_submitClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitClient.
 */
template<class T>
class CallbackNC_Session_submitClient : public Callback_Session_submitClient_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ClientSubmitterPrx&);

    CallbackNC_Session_submitClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ClientSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_submitClient(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_submitter);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitClient.
 */
template<class T> Callback_Session_submitClientPtr
newCallback_Session_submitClient(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ClientSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_submitClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitClient.
 */
template<class T> Callback_Session_submitClientPtr
newCallback_Session_submitClient(T* instance, void (T::*cb)(ErrorCode, const ClientSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_submitClient<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_submitClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_submitClient.
 */
template<class T, typename CT>
class Callback_Session_submitClient : public Callback_Session_submitClient_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ClientSubmitterPrx&, const CT&);

    Callback_Session_submitClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ClientSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_submitClient(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_submitter, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitClient.
 */
template<class T, typename CT> Callback_Session_submitClientPtr
newCallback_Session_submitClient(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ClientSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_submitClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_submitClient.
 */
template<class T, typename CT> Callback_Session_submitClientPtr
newCallback_Session_submitClient(T* instance, void (T::*cb)(ErrorCode, const ClientSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_submitClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_updateClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_updateClient.
 */
template<class T>
class CallbackNC_Session_updateClient : public Callback_Session_updateClient_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ClientSubmitterPrx&);

    CallbackNC_Session_updateClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ClientSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_updateClient(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_submitter);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateClient.
 */
template<class T> Callback_Session_updateClientPtr
newCallback_Session_updateClient(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ClientSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_updateClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateClient.
 */
template<class T> Callback_Session_updateClientPtr
newCallback_Session_updateClient(T* instance, void (T::*cb)(ErrorCode, const ClientSubmitterPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_updateClient<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_updateClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_updateClient.
 */
template<class T, typename CT>
class Callback_Session_updateClient : public Callback_Session_updateClient_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ClientSubmitterPrx&, const CT&);

    Callback_Session_updateClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ClientSubmitterPrx iceP_submitter;
        ErrorCode ret;
        try
        {
            ret = proxy->end_updateClient(iceP_submitter, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_submitter, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateClient.
 */
template<class T, typename CT> Callback_Session_updateClientPtr
newCallback_Session_updateClient(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ClientSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_updateClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_updateClient.
 */
template<class T, typename CT> Callback_Session_updateClientPtr
newCallback_Session_updateClient(T* instance, void (T::*cb)(ErrorCode, const ClientSubmitterPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_updateClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_removeClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeClient.
 */
template<class T>
class CallbackNC_Session_removeClient : public Callback_Session_removeClient_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_removeClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_removeClient(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeClient.
 */
template<class T> Callback_Session_removeClientPtr
newCallback_Session_removeClient(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_removeClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeClient.
 */
template<class T> Callback_Session_removeClientPtr
newCallback_Session_removeClient(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_removeClient<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_removeClient.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeClient.
 */
template<class T, typename CT>
class Callback_Session_removeClient : public Callback_Session_removeClient_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_removeClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_removeClient(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeClient.
 */
template<class T, typename CT> Callback_Session_removeClientPtr
newCallback_Session_removeClient(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_removeClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeClient.
 */
template<class T, typename CT> Callback_Session_removeClientPtr
newCallback_Session_removeClient(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_removeClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_browseUsers.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseUsers.
 */
template<class T>
class CallbackNC_Session_browseUsers : public Callback_Session_browseUsers_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const UserBrowserPrx&);

    CallbackNC_Session_browseUsers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        UserBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseUsers(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_browser);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseUsers.
 */
template<class T> Callback_Session_browseUsersPtr
newCallback_Session_browseUsers(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UserBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseUsers<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseUsers.
 */
template<class T> Callback_Session_browseUsersPtr
newCallback_Session_browseUsers(T* instance, void (T::*cb)(ErrorCode, const UserBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseUsers<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_browseUsers.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseUsers.
 */
template<class T, typename CT>
class Callback_Session_browseUsers : public Callback_Session_browseUsers_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const UserBrowserPrx&, const CT&);

    Callback_Session_browseUsers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        UserBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseUsers(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_browser, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseUsers.
 */
template<class T, typename CT> Callback_Session_browseUsersPtr
newCallback_Session_browseUsers(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const UserBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseUsers<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseUsers.
 */
template<class T, typename CT> Callback_Session_browseUsersPtr
newCallback_Session_browseUsers(T* instance, void (T::*cb)(ErrorCode, const UserBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseUsers<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_setUserGroup.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setUserGroup.
 */
template<class T>
class CallbackNC_Session_setUserGroup : public Callback_Session_setUserGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_setUserGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setUserGroup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setUserGroup.
 */
template<class T> Callback_Session_setUserGroupPtr
newCallback_Session_setUserGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_setUserGroup<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setUserGroup.
 */
template<class T> Callback_Session_setUserGroupPtr
newCallback_Session_setUserGroup(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_setUserGroup<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_setUserGroup.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_setUserGroup.
 */
template<class T, typename CT>
class Callback_Session_setUserGroup : public Callback_Session_setUserGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_setUserGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_setUserGroup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setUserGroup.
 */
template<class T, typename CT> Callback_Session_setUserGroupPtr
newCallback_Session_setUserGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_setUserGroup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_setUserGroup.
 */
template<class T, typename CT> Callback_Session_setUserGroupPtr
newCallback_Session_setUserGroup(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_setUserGroup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_removeUser.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeUser.
 */
template<class T>
class CallbackNC_Session_removeUser : public Callback_Session_removeUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_removeUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_removeUser(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeUser.
 */
template<class T> Callback_Session_removeUserPtr
newCallback_Session_removeUser(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_removeUser<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeUser.
 */
template<class T> Callback_Session_removeUserPtr
newCallback_Session_removeUser(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_removeUser<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_removeUser.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeUser.
 */
template<class T, typename CT>
class Callback_Session_removeUser : public Callback_Session_removeUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_removeUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_removeUser(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeUser.
 */
template<class T, typename CT> Callback_Session_removeUserPtr
newCallback_Session_removeUser(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_removeUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeUser.
 */
template<class T, typename CT> Callback_Session_removeUserPtr
newCallback_Session_removeUser(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_removeUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_browseComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseComment.
 */
template<class T>
class CallbackNC_Session_browseComment : public Callback_Session_browseComment_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const CommentBrowserPrx&);

    CallbackNC_Session_browseComment(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        CommentBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseComment(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_browser);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseComment.
 */
template<class T> Callback_Session_browseCommentPtr
newCallback_Session_browseComment(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CommentBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseComment<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseComment.
 */
template<class T> Callback_Session_browseCommentPtr
newCallback_Session_browseComment(T* instance, void (T::*cb)(ErrorCode, const CommentBrowserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_browseComment<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_browseComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_browseComment.
 */
template<class T, typename CT>
class Callback_Session_browseComment : public Callback_Session_browseComment_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CommentBrowserPrx&, const CT&);

    Callback_Session_browseComment(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        CommentBrowserPrx iceP_browser;
        ErrorCode ret;
        try
        {
            ret = proxy->end_browseComment(iceP_browser, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_browser, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseComment.
 */
template<class T, typename CT> Callback_Session_browseCommentPtr
newCallback_Session_browseComment(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CommentBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseComment<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_browseComment.
 */
template<class T, typename CT> Callback_Session_browseCommentPtr
newCallback_Session_browseComment(T* instance, void (T::*cb)(ErrorCode, const CommentBrowserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_browseComment<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_getComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getComment.
 */
template<class T>
class CallbackNC_Session_getComment : public Callback_Session_getComment_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, const ::std::string&);

    CallbackNC_Session_getComment(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_comment;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getComment(iceP_comment, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_comment);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getComment.
 */
template<class T> Callback_Session_getCommentPtr
newCallback_Session_getComment(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getComment<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getComment.
 */
template<class T> Callback_Session_getCommentPtr
newCallback_Session_getComment(T* instance, void (T::*cb)(ErrorCode, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_getComment<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_getComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_getComment.
 */
template<class T, typename CT>
class Callback_Session_getComment : public Callback_Session_getComment_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const ::std::string&, const CT&);

    Callback_Session_getComment(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_comment;
        ErrorCode ret;
        try
        {
            ret = proxy->end_getComment(iceP_comment, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_comment, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getComment.
 */
template<class T, typename CT> Callback_Session_getCommentPtr
newCallback_Session_getComment(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getComment<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_getComment.
 */
template<class T, typename CT> Callback_Session_getCommentPtr
newCallback_Session_getComment(T* instance, void (T::*cb)(ErrorCode, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_getComment<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_addComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_addComment.
 */
template<class T>
class CallbackNC_Session_addComment : public Callback_Session_addComment_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_addComment(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_addComment(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_addComment.
 */
template<class T> Callback_Session_addCommentPtr
newCallback_Session_addComment(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_addComment<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_addComment.
 */
template<class T> Callback_Session_addCommentPtr
newCallback_Session_addComment(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_addComment<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_addComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_addComment.
 */
template<class T, typename CT>
class Callback_Session_addComment : public Callback_Session_addComment_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_addComment(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_addComment(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_addComment.
 */
template<class T, typename CT> Callback_Session_addCommentPtr
newCallback_Session_addComment(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_addComment<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_addComment.
 */
template<class T, typename CT> Callback_Session_addCommentPtr
newCallback_Session_addComment(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_addComment<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_editComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_editComment.
 */
template<class T>
class CallbackNC_Session_editComment : public Callback_Session_editComment_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_editComment(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_editComment(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_editComment.
 */
template<class T> Callback_Session_editCommentPtr
newCallback_Session_editComment(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_editComment<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_editComment.
 */
template<class T> Callback_Session_editCommentPtr
newCallback_Session_editComment(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_editComment<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_editComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_editComment.
 */
template<class T, typename CT>
class Callback_Session_editComment : public Callback_Session_editComment_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_editComment(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_editComment(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_editComment.
 */
template<class T, typename CT> Callback_Session_editCommentPtr
newCallback_Session_editComment(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_editComment<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_editComment.
 */
template<class T, typename CT> Callback_Session_editCommentPtr
newCallback_Session_editComment(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_editComment<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_removeComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeComment.
 */
template<class T>
class CallbackNC_Session_removeComment : public Callback_Session_removeComment_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode);

    CallbackNC_Session_removeComment(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_removeComment(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeComment.
 */
template<class T> Callback_Session_removeCommentPtr
newCallback_Session_removeComment(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_removeComment<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeComment.
 */
template<class T> Callback_Session_removeCommentPtr
newCallback_Session_removeComment(T* instance, void (T::*cb)(ErrorCode), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_removeComment<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_removeComment.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_removeComment.
 */
template<class T, typename CT>
class Callback_Session_removeComment : public Callback_Session_removeComment_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, const CT&);

    Callback_Session_removeComment(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ErrorCode ret;
        try
        {
            ret = proxy->end_removeComment(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeComment.
 */
template<class T, typename CT> Callback_Session_removeCommentPtr
newCallback_Session_removeComment(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_removeComment<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_removeComment.
 */
template<class T, typename CT> Callback_Session_removeCommentPtr
newCallback_Session_removeComment(T* instance, void (T::*cb)(ErrorCode, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_removeComment<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_queryDownloadCount.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_queryDownloadCount.
 */
template<class T>
class CallbackNC_Session_queryDownloadCount : public Callback_Session_queryDownloadCount_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, ::Ice::Int);

    CallbackNC_Session_queryDownloadCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_count;
        ErrorCode ret;
        try
        {
            ret = proxy->end_queryDownloadCount(iceP_count, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_count);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_queryDownloadCount.
 */
template<class T> Callback_Session_queryDownloadCountPtr
newCallback_Session_queryDownloadCount(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_queryDownloadCount<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_queryDownloadCount.
 */
template<class T> Callback_Session_queryDownloadCountPtr
newCallback_Session_queryDownloadCount(T* instance, void (T::*cb)(ErrorCode, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_queryDownloadCount<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_queryDownloadCount.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_queryDownloadCount.
 */
template<class T, typename CT>
class Callback_Session_queryDownloadCount : public Callback_Session_queryDownloadCount_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, ::Ice::Int, const CT&);

    Callback_Session_queryDownloadCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_count;
        ErrorCode ret;
        try
        {
            ret = proxy->end_queryDownloadCount(iceP_count, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_count, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_queryDownloadCount.
 */
template<class T, typename CT> Callback_Session_queryDownloadCountPtr
newCallback_Session_queryDownloadCount(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_queryDownloadCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_queryDownloadCount.
 */
template<class T, typename CT> Callback_Session_queryDownloadCountPtr
newCallback_Session_queryDownloadCount(T* instance, void (T::*cb)(ErrorCode, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_queryDownloadCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_isUserOnline.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_isUserOnline.
 */
template<class T>
class CallbackNC_Session_isUserOnline : public Callback_Session_isUserOnline_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, bool);

    CallbackNC_Session_isUserOnline(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        bool iceP_result;
        ErrorCode ret;
        try
        {
            ret = proxy->end_isUserOnline(iceP_result, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_result);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_isUserOnline.
 */
template<class T> Callback_Session_isUserOnlinePtr
newCallback_Session_isUserOnline(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_isUserOnline<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_isUserOnline.
 */
template<class T> Callback_Session_isUserOnlinePtr
newCallback_Session_isUserOnline(T* instance, void (T::*cb)(ErrorCode, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_isUserOnline<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_isUserOnline.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_isUserOnline.
 */
template<class T, typename CT>
class Callback_Session_isUserOnline : public Callback_Session_isUserOnline_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, bool, const CT&);

    Callback_Session_isUserOnline(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        bool iceP_result;
        ErrorCode ret;
        try
        {
            ret = proxy->end_isUserOnline(iceP_result, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_result, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_isUserOnline.
 */
template<class T, typename CT> Callback_Session_isUserOnlinePtr
newCallback_Session_isUserOnline(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_isUserOnline<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_isUserOnline.
 */
template<class T, typename CT> Callback_Session_isUserOnlinePtr
newCallback_Session_isUserOnline(T* instance, void (T::*cb)(ErrorCode, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_isUserOnline<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::Rpc::Session::begin_onlineUserCount.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_onlineUserCount.
 */
template<class T>
class CallbackNC_Session_onlineUserCount : public Callback_Session_onlineUserCount_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(ErrorCode, ::Ice::Int);

    CallbackNC_Session_onlineUserCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_count;
        ErrorCode ret;
        try
        {
            ret = proxy->end_onlineUserCount(iceP_count, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_count);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_onlineUserCount.
 */
template<class T> Callback_Session_onlineUserCountPtr
newCallback_Session_onlineUserCount(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_onlineUserCount<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_onlineUserCount.
 */
template<class T> Callback_Session_onlineUserCountPtr
newCallback_Session_onlineUserCount(T* instance, void (T::*cb)(ErrorCode, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Session_onlineUserCount<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::Rpc::Session::begin_onlineUserCount.
 * Create a wrapper instance by calling ::Rpc::newCallback_Session_onlineUserCount.
 */
template<class T, typename CT>
class Callback_Session_onlineUserCount : public Callback_Session_onlineUserCount_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(ErrorCode, ::Ice::Int, const CT&);

    Callback_Session_onlineUserCount(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SessionPrx proxy = SessionPrx::uncheckedCast(result->getProxy());
        ::Ice::Int iceP_count;
        ErrorCode ret;
        try
        {
            ret = proxy->end_onlineUserCount(iceP_count, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_count, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_onlineUserCount.
 */
template<class T, typename CT> Callback_Session_onlineUserCountPtr
newCallback_Session_onlineUserCount(const IceUtil::Handle<T>& instance, void (T::*cb)(ErrorCode, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_onlineUserCount<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::Rpc::Session::begin_onlineUserCount.
 */
template<class T, typename CT> Callback_Session_onlineUserCountPtr
newCallback_Session_onlineUserCount(T* instance, void (T::*cb)(ErrorCode, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Session_onlineUserCount<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
